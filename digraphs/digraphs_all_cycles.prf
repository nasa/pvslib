(digraphs_all_cycles (vertsl?_is_vertlist 0 (vertsl?_is_vertlist-2 "" 3744330303 ("" (skeep) (("" (split 1) (("1" (typepred "x") (("1" (expand "vertsl?") (("1" (expand "vert?") (("1" (expand "digraph_verts") (("1" (use "every_nth[T]") (("1" (replace -1 :hide? t) (("1" (skeep) (("1" (inst -1 "nth(x, i)") (("1" (assert) (("1" (expand "member" -1 2) (("1" (use "nth_member[T]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "x") (("2" (skeep) (("2" (expand "vertsl?") (("2" (flatten) (("2" (inst -1 "v") (("2" (typepred "v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (expand "member" -2 2) (("2" (assert) (("2" (use "member_nth[T]") (("2" (assert) (("2" (skeep) (("2" (inst 1 "i") (("2" (split 1) (("1" (propax) nil nil) ("2" (use "no_rep_vertsl") (("2" (expand "no_repetitions?") (("2" (skeep) (("2" (inst?) (("2" (inst -1 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (member const-decl "bool" sets nil) (nth_member formula-decl nil more_list_props structures) (PRED type-eq-decl nil defined_types nil) (every_nth formula-decl nil list_props nil) (vert? const-decl "bool" digraphs_ nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil digraphs_all_cycles nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (digraph type-eq-decl nil digraph_def nil) (list type-decl nil list_adt nil) (vertsl? const-decl "bool" c_digraphs_digraphs nil) (vert type-eq-decl nil digraphs_ nil) (member_nth formula-decl nil more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (no_rep_vertsl formula-decl nil c_digraphs_digraphs nil) (every adt-def-decl "boolean" list_adt nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (vert_list const-decl "bool" digraphs_ nil)) shostak (vertsl?_is_vertlist subtype "digraphs_all_cycles.x" "VertList[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)")) (vertsl?_is_vertlist-1 nil 3659367212 ("" (skeep) (("" (split 1) (("1" (typepred "x") (("1" (expand "vertsl?") (("1" (expand "vert?") (("1" (expand "digraph_verts") (("1" (use "every_nth[T]") (("1" (replace -1 :hide? t) (("1" (skeep) (("1" (inst -1 "nth(x, i)") (("1" (assert) (("1" (expand "member" -1 2) (("1" (use "nth_member[T]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "x") (("2" (skeep) (("2" (expand "vertsl?") (("2" (flatten) (("2" (inst -1 "v") (("2" (typepred "v") (("2" (expand "vert?") (("2" (expand "digraph_verts") (("2" (expand "member" -2 2) (("2" (assert) (("2" (use "member_nth[T]") (("2" (assert) (("2" (skeep) (("2" (inst 1 "i") (("1" (split 1) (("1" (hide-all-but (1 -1)) (("1" (use "nth_overloading[T,digraphs_
                    [T, digraphs_imp[T].digraph_type,
                     digraphs_imp[T].digraph_verts,
                     digraphs_imp[T].digraph_edges,
                     digraphs_imp[T].digraph_size,
                     digraphs_imp[T].digraph_make].vert(G)]") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (use "length_overloading[T,digraphs_
                    [T, digraphs_imp[T].digraph_type,
                     digraphs_imp[T].digraph_verts,
                     digraphs_imp[T].digraph_edges,
                     digraphs_imp[T].digraph_size,
                     digraphs_imp[T].digraph_make].vert(G)]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (use "no_rep_vertsl") (("2" (expand "no_repetitions?") (("2" (skeep) (("2" (inst?) (("2" (inst -1 "j") (("1" (assert) (("1" (hide-all-but (-1 -2)) (("1" (use "nth_overloading[T,digraphs_
                    [T, digraphs_imp[T].digraph_type,
                     digraphs_imp[T].digraph_verts,
                     digraphs_imp[T].digraph_edges,
                     digraphs_imp[T].digraph_size,
                     digraphs_imp[T].digraph_make].vert(G)]") (("1" (replace -1 :hide? t) (("1" (use "nth_overloading[T,digraphs_
                    [T, digraphs_imp[T].digraph_type,
                     digraphs_imp[T].digraph_verts,
                     digraphs_imp[T].digraph_edges,
                     digraphs_imp[T].digraph_size,
                     digraphs_imp[T].digraph_make].vert(G)]") (("1" (replace -1 :hide? t) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i") (("2" (use "length_overloading[T,digraphs_
                    [T, digraphs_imp[T].digraph_type,
                     digraphs_imp[T].digraph_verts,
                     digraphs_imp[T].digraph_edges,
                     digraphs_imp[T].digraph_size,
                     digraphs_imp[T].digraph_make].vert(G)]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "j") (("2" (use "length_overloading[T,digraphs_
                    [T, digraphs_imp[T].digraph_type,
                     digraphs_imp[T].digraph_verts,
                     digraphs_imp[T].digraph_edges,
                     digraphs_imp[T].digraph_size,
                     digraphs_imp[T].digraph_make].vert(G)]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "i") (("2" (use "length_overloading[T,digraphs_
                    [T, digraphs_imp[T].digraph_type,
                     digraphs_imp[T].digraph_verts,
                     digraphs_imp[T].digraph_edges,
                     digraphs_imp[T].digraph_size,
                     digraphs_imp[T].digraph_make].vert(G)]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (member const-decl "bool" sets nil) (nth_member formula-decl nil more_list_props structures) (vert? const-decl "bool" digraphs_ nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (digraph type-eq-decl nil digraph_def nil) (vertsl? const-decl "bool" c_digraphs_digraphs nil) (vert type-eq-decl nil digraphs_ nil) (member_nth formula-decl nil more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (no_rep_vertsl formula-decl nil c_digraphs_digraphs nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (vert_list const-decl "bool" digraphs_ nil)) nil (vertsl?_is_vertlist subtype "digraphs_all_cycles.x" "VertList[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)"))) (walk_eq_TCC1 0 (walk_eq_TCC1-1 nil 3659295519 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil digraphs_all_cycles nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (digraph type-eq-decl nil digraph_def nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (digraph_type type-eq-decl nil digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (walk_eq subtype "digraphs_all_cycles.i" "below[length[nat](w2)]"))) (walk_eq_TCC2 0 (walk_eq_TCC2-1 nil 3659295519 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil digraphs_all_cycles nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (digraph type-eq-decl nil digraph_def nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (digraph_type type-eq-decl nil digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (nth def-decl "T" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (C!1 skolem-const-decl "cdigraph_eq[T](G!1)" digraphs_all_cycles nil) (length def-decl "nat" list_props nil) (i!1 skolem-const-decl "below(length(w1!1))" digraphs_all_cycles nil) (w1!1 skolem-const-decl "Walk[T, digraph_type[T], digraph_verts[T], digraph_edges[T],
     digraph_size[T], digraph_make[T]](G!1)" digraphs_all_cycles nil) (G!1 skolem-const-decl "digraph[T]" digraphs_all_cycles nil) (edge? const-decl "bool" digraphs_ nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (verts_in? const-decl "bool" walks_ nil) (member const-decl "bool" sets nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (walk_eq subtype "list_props[nat].nth(digraphs_all_cycles.w2, digraphs_all_cycles.i)" "below[length[T](data(C))]"))) (walki2walk_TCC1 0 (walki2walk_TCC1-1 nil 3659286530 ("" (existence-tcc) nil nil) nil nil (walki2walk subtype "digraphs_all_cycles.C" "cdigraph_eq[digraphs_all_cycles.T](digraphs_all_cycles.G)"))) (walki2walk_TCC2 0 (walki2walk_TCC2-1 nil 3659292745 ("" (existence-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil digraphs_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (digraph type-eq-decl nil digraph_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph_eq type-eq-decl nil c_digraphs_digraphs nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (C!1 skolem-const-decl "(cdigraph[T])" digraphs_all_cycles nil) (member const-decl "bool" sets nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (size const-decl "nat" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (walki2walk subtype "list_props[nat].nth(digraphs_all_cycles.cw, digraphs_all_cycles.i)" "below[length[T](data(C))]"))) (walki2walk_TCC3 0 (walki2walk_TCC3-1 nil 3659300598 ("" (skeep) (("" (typepred "cw") (("" (expand "walk?" -3) (("" (flatten) (("" (split 2) (("1" (grind) nil nil) ("2" (expand "walk?") (("2" (expand "finseq_appl") (("2" (expand "verts_in?") (("2" (expand "digraph_verts") (("2" (typepred "G") (("2" (expand "eq") (("2" (flatten) (("2" (split 1) (("1" (skeep) (("1" (replace -2 :hide? t :dir rl) (("1" (typepred "list2set(data(C))") (("1" (replace -2 :hide? t) (("1" (assert) (("1" (use "nth_member[T]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "edge?") (("2" (expand "digraph_edges") (("2" (expand "member" -4 2) (("2" (inst? -4 :where 1) (("2" (assert) (("2" (inst? -6 :where 2) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (walk_eq const-decl "bool" digraphs_all_cycles nil) (walk? const-decl "bool" walks_ nil) (verts_in? const-decl "bool" walks_ nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (digraph type-eq-decl nil digraph_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph_eq type-eq-decl nil c_digraphs_digraphs nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (member const-decl "bool" sets nil) (edge? const-decl "bool" digraphs_ nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (member def-decl "bool" list_props nil) (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}" set_as_list structures) (nth_member formula-decl nil more_list_props structures) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (size const-decl "nat" c_digraphs_def nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (walki2walk subtype "(# length := list_props[nat].length(digraphs_all_cycles.cw), seq := (LAMBDA (i: naturalnumbers.below(list_props[nat].length(digraphs_all_cycles.cw))): list_props[digraphs_all_cycles.T].nth(data(digraphs_all_cycles.C), list_props[nat].nth(digraphs_all_cycles.cw, i))) #)" "{w: walks_[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make].Walk(digraphs_all_cycles.G) | digraphs_all_cycles.walk_eq(digraphs_all_cycles.G, digraphs_all_cycles.C)(w, digraphs_all_cycles.cw)}"))) (walk2walki_rec_TCC1 0 (walk2walki_rec_TCC1-1 nil 3659302045 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil digraphs_all_cycles nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (digraph type-eq-decl nil digraph_def nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (digraph_type type-eq-decl nil digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (member const-decl "bool" sets nil) (verts_in? const-decl "bool" walks_ nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edge? const-decl "bool" digraphs_ nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (walk2walki_rec subtype "(number_fields.+)(digraphs_all_cycles.i, digraphs_all_cycles.offset)" "below[length(w)]"))) (walk2walki_rec_TCC2 0 (walk2walki_rec_TCC2-1 nil 3659302045 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil digraphs_all_cycles nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (digraph type-eq-decl nil digraph_def nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (digraph_type type-eq-decl nil digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (size const-decl "nat" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (member const-decl "bool" sets nil) (verts_in? const-decl "bool" walks_ nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edge? const-decl "bool" digraphs_ nil) (G!1 skolem-const-decl "digraph[T]" digraphs_all_cycles nil) (C!1 skolem-const-decl "cdigraph_eq[T](G!1)" digraphs_all_cycles nil) (wi!1 skolem-const-decl "(walk?[T](C!1))" digraphs_all_cycles nil) (i!1 skolem-const-decl "below(length[nat](wi!1))" digraphs_all_cycles nil) (w!1 skolem-const-decl "Walk[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](G!1)" digraphs_all_cycles nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nth def-decl "T" list_props nil) (length def-decl "nat" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (walk2walki_rec subtype "list_props[nat].nth(digraphs_all_cycles.wi, digraphs_all_cycles.i)" "below[length[T](data(C))]"))) (walk2walki_rec_TCC3 0 (walk2walki_rec_TCC3-1 nil 3659302045 ("" (subtype-tcc) nil nil) nil nil (walk2walki_rec subtype "(number_fields.-)(length(digraphs_all_cycles.w), digraphs_all_cycles.offset)" "naturalnumber"))) (walk2walki_rec_TCC4 0 (walk2walki_rec_TCC4-1 nil 3659302045 ("" (skeep) (("" (expand "finseq_appl") (("" (typepred "C") (("" (typepred "w") (("" (expand "walk?") (("" (flatten) (("" (expand "verts_in?") (("" (expand "digraph_verts") (("" (expand "eq") (("" (flatten) (("" (inst -2 "offset") (("" (replace -5 -2 :dir rl) (("" (typepred "list2set(data(C::ComputableDigraph[T]))") (("" (replace -2 :hide? t) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (Walk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}" set_as_list structures) (member def-decl "bool" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (verts_in? const-decl "bool" walks_ nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil digraphs_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph type-eq-decl nil digraph_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil)) nil (walk2walki_rec subtype "finite_sequences[digraphs_all_cycles.T].finseq_appl(digraphs_all_cycles.w)(digraphs_all_cycles.offset)" "{a: digraphs_all_cycles.T | list_props[digraphs_all_cycles.T].member(a, data(digraphs_all_cycles.C))}"))) (walk2walki_rec_TCC5 0 (walk2walki_rec_TCC6-1 nil 3659302045 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil digraphs_all_cycles nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (digraph type-eq-decl nil digraph_def nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (digraph_type type-eq-decl nil digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (member const-decl "bool" sets nil) (verts_in? const-decl "bool" walks_ nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (edge? const-decl "bool" digraphs_ nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (walk2walki_rec subtype "(number_fields.+)(digraphs_all_cycles.offset, 1)" "below(length(digraphs_all_cycles.w))"))) (walk2walki_rec_TCC6 0 (walk2walki_rec_TCC7-1 nil 3659302045 ("" (subtype-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (walk2walki_rec termination "digraphs_all_cycles.walk2walki_rec(digraphs_all_cycles.G, digraphs_all_cycles.C)(digraphs_all_cycles.w, (number_fields.+)(digraphs_all_cycles.offset, 1))" "nil"))) (walk2walki_rec_TCC7 0 (walk2walki_rec_TCC5-1 nil 3659302045 ("" (skeep) (("" (lift-if 1) (("" (split 1) (("1" (flatten) (("1" (split 1) (("1" (expand "list_of_idxs") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (expand "finseq_appl") (("4" (skeep) (("4" (typepred "i") (("4" (assert) (("4" (case "i=0") (("1" (replace -1 :hide? t) (("1" (replace -2 :hide? t) (("1" (expand "nth" 1 2) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "v(G, C) (w, offset + 1)") (("1" (hide -1) (("1" (expand "finseq_appl") (("1" (split 2) (("1" (expand "list_of_idxs") (("1" (skeep) (("1" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1) (("1" (expand "size") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst -1 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "walk?") (("2" (skeep 1) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1 3) (("1" (expand "nth" 1 1) (("1" (typepred "w") (("1" (expand "walk?") (("1" (flatten) (("1" (inst -3 "offset") (("1" (assert) (("1" (expand "finseq_appl") (("1" (inst -7 "0") (("1" (assert) (("1" (replace -7 :hide? t) (("1" (typepred "C") (("1" (expand "eq") (("1" (flatten) (("1" (expand "member" -3 2) (("1" (expand "verts_in?") (("1" (inst -5 "offset") (("1" (expand "digraph_verts") (("1" (replace -2 :hide? t :dir rl) (("1" (typepred "list2set(data(C::ComputableDigraph))") (("1" (replace -2 :hide? t) (("1" (assert) (("1" (use "member_nth[T]") (("1" (assert) (("1" (skeep) (("1" (replace -1 :hide? t :dir rl) (("1" (expand "edge?") (("1" (expand "digraph_edges") (("1" (inst? -3 :where -6) (("1" (assert) (("1" (hide-all-but (-5 1)) (("1" (use "idx_nth_no_rep") (("1" (assert) nil nil) ("2" (typepred "C") (("2" (expand "cdigraph") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2 3) (("2" (assert) (("2" (expand "nth" 2 1) (("2" (inst -2 "i-1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (expand "length" -1 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "length" 1 1) (("3" (assert) nil nil)) nil) ("4" (skeep) (("4" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1 2) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "nth" 2 2) (("2" (assert) (("2" (inst -4 "i-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (w skolem-const-decl "Walk[T, digraph_type[T], digraph_verts[T], digraph_edges[T],
     digraph_size[T], digraph_make[T]](G)" digraphs_all_cycles nil) (offset skolem-const-decl "below(length(w))" digraphs_all_cycles nil) (v skolem-const-decl "[d1: [G: digraph[T], cdigraph_eq[T](G)] ->
   [d2:
      {z:
         [w:
            Walk[T, digraph_type[T], digraph_verts, digraph_edges,
                 digraph_size, digraph_make](d1`1),
          below(length(w))] |
         length(z`1) - z`2 < length(w) - offset} ->
      {wi: (walk?(d1`2)) |
         length(wi) + d2`2 = length(d2`1) AND
          FORALL (i: below(length(wi))):
            finseq_appl[T](d2`1)(i + d2`2) = nth(data(d1`2), nth(wi, i))}]]" digraphs_all_cycles nil) (i skolem-const-decl "below(length(cons[nat]
                 (idx[T](data(C), w`seq(offset)), v(G, C)(w, 1 + offset)))
       - 1)" digraphs_all_cycles nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (verts_in? const-decl "bool" walks_ nil) (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}" set_as_list structures) (idx_nth_no_rep formula-decl nil more_list_props structures) (C skolem-const-decl "cdigraph_eq[T](G)" digraphs_all_cycles nil) (G skolem-const-decl "digraph[T]" digraphs_all_cycles nil) (no_repetitions? const-decl "bool" more_list_props structures) (edge? const-decl "bool" digraphs_ nil) (member_nth formula-decl nil more_list_props structures) (member const-decl "bool" sets nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (length_singleton formula-decl nil more_list_props structures) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Walk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (member def-decl "bool" list_props nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (T formal-type-decl nil digraphs_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (walk2walki_rec subtype "list_adt[nat].cons(more_list_props[digraphs_all_cycles.T].idx(data(digraphs_all_cycles.C), finite_sequences[digraphs_all_cycles.T].finseq_appl(digraphs_all_cycles.w)(digraphs_all_cycles.offset)), IF digraphs_all_cycles.offset = (number_fields.-)(length(digraphs_all_cycles.w), 1) THEN list_adt[nat].null ELSE digraphs_all_cycles.walk2walki_rec(digraphs_all_cycles.G, digraphs_all_cycles.C)(digraphs_all_cycles.w, (number_fields.+)(digraphs_all_cycles.offset, 1)) ENDIF)" "{wi: (c_digraph_all_cycles[digraphs_all_cycles.T].walk?(digraphs_all_cycles.C)) | booleans.AND((number_fields.+)(digraphs_all_cycles.offset, list_props[nat].length(wi)) = length(digraphs_all_cycles.w), FORALL (i: naturalnumbers.below(list_props[nat].length(wi))): finite_sequences[digraphs_all_cycles.T].finseq_appl(digraphs_all_cycles.w)((number_fields.+)(i, digraphs_all_cycles.offset)) = list_props[digraphs_all_cycles.T].nth(data(digraphs_all_cycles.C), list_props[nat].nth(wi, i)))}"))) (walk2walki_TCC1 0 (walk2walki_TCC1-1 nil 3659302045 ("" (subtype-tcc) nil nil) nil nil (walk2walki subtype "0" "below(length(digraphs_all_cycles.w))"))) (walk2walki_TCC2 0 (walk2walki_TCC2-1 nil 3659302045 ("" (skeep) (("" (typepred "walk2walki_rec(G, C)(w, 0)") (("" (expand "walk_eq") (("" (assert) (("" (skeep) (("" (inst -5 "i") nil nil)) nil)) nil)) nil)) nil)) nil) ((walk2walki_rec def-decl "{wi: (walk?(C)) |
   length(wi) + offset = length(w) AND
    FORALL (i: below(length(wi))):
      finseq_appl[T](w)(i + offset) = nth(data(C), nth(wi, i))}" digraphs_all_cycles nil) (nth def-decl "T" list_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (Walk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (digraph type-eq-decl nil digraph_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (walk_eq const-decl "bool" digraphs_all_cycles nil)) nil (walk2walki subtype "digraphs_all_cycles.walk2walki_rec(digraphs_all_cycles.G, digraphs_all_cycles.C)(digraphs_all_cycles.w, 0)" "{wi: (c_digraph_all_cycles[digraphs_all_cycles.T].walk?(digraphs_all_cycles.C)) | digraphs_all_cycles.walk_eq(digraphs_all_cycles.G, digraphs_all_cycles.C)(digraphs_all_cycles.w, wi)}"))) (w2wi_circuit 0 (w2wi_circuit-1 nil 3659348443 ("" (skeep) (("" (typepred "walk2walki(G,C)(w)") (("" (hide -1) (("" (expand "circuit?") (("" (flatten) (("" (split 1) (("1" (expand "pre_circuit?") (("1" (expand "finseq_appl") (("1" (expand "walk_eq") (("1" (flatten) (("1" (expand "finseq_appl") (("1" (inst? :copy? t) (("1" (expand "last") (("1" (inst -4 "length(w)-1") (("1" (replace -4 :hide? t) (("1" (replace -3 :hide? t) (("1" (replace -3 :hide? t) (("1" (hide-all-but (-3 1)) (("1" (expand "nth" -1 2) (("1" (typepred "C") (("1" (expand "cdigraph") (("1" (flatten) (("1" (hide-all-but (-6 1 -3)) (("1" (expand "no_repetitions?") (("1" (inst -1 "car(walk2walki(G, C)(w))" "nth(walk2walki(G, C)(w), length(walk2walki(G, C)(w)) - 1)") (("1" (assert) nil nil) ("2" (typepred "walk2walki(G, C)(w)") (("2" (expand "walk?") (("2" (flatten) (("2" (expand "length" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "walk2walki(G, C)(w)") (("2" (expand "walk_eq") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((walk2walki const-decl "{wi: (walk?(C)) | walk_eq(G, C)(w, wi)}" digraphs_all_cycles nil) (walk_eq const-decl "bool" digraphs_all_cycles nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (Walk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (digraph type-eq-decl nil digraph_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" circuits_ nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (no_repetitions? const-decl "bool" more_list_props structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (w skolem-const-decl "Walk[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](G)" digraphs_all_cycles nil) (C skolem-const-decl "cdigraph_eq[T](G)" digraphs_all_cycles nil) (G skolem-const-decl "digraph[T]" digraphs_all_cycles nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (last const-decl "T" more_list_props structures) (pre_circuit? const-decl "bool" circuits_ nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (w2wi_cycle_TCC1 0 (w2wi_cycle_TCC1-1 nil 3659348801 ("" (skeep) (("" (use "w2wi_circuit") (("" (assert) (("" (expand "cycle?") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((w2wi_circuit formula-decl nil digraphs_all_cycles nil) (Walk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (digraph type-eq-decl nil digraph_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil digraphs_all_cycles nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cycle? const-decl "bool" cycles_ nil)) nil (w2wi_cycle subtype "digraphs_all_cycles.walk2walki(digraphs_all_cycles.G, digraphs_all_cycles.C)(digraphs_all_cycles.w)" "(c_digraph_all_cycles[digraphs_all_cycles.T].circuit?(digraphs_all_cycles.C))"))) (w2wi_cycle 0 (w2wi_cycle-1 nil 3659348880 ("" (skeep) (("" (typepred "walk2walki(G,C)(w)") (("" (hide -1) (("" (expand "cycle?") (("" (flatten) (("" (expand "finseq_appl") (("" (expand "no_repetitions?") (("" (skeep :preds? t) (("" (expand "walk_eq") (("" (flatten) (("" (expand "finseq_appl") (("" (expand "length" -5) (("" (lift-if -5) (("" (split -5) (("1" (flatten) (("1" (expand "walk?") (("1" (flatten) nil nil)) nil)) nil) ("2" (flatten) (("2" (case "i < length(w) -1") (("1" (hide -3) (("1" (case "j<length(w)-1") (("1" (hide -4) (("1" (case "i+1=length(w)-1") (("1" (expand "circuit?") (("1" (flatten) (("1" (expand "pre_circuit?") (("1" (expand "finseq_appl") (("1" (inst -10 "0" "j+1") (("1" (assert) (("1" (inst-cp -7 "j+1") (("1" (replace -8 2 :hide? t) (("1" (expand "nth" 2 2) (("1" (replace -10 :dir rl :hide? t) (("1" (assert) (("1" (inst -7 "length(w)-1") (("1" (replace -7 -8 :hide? t) (("1" (replace -1 :hide? t :dir rl) (("1" (expand "nth" -6 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "j+1=length(w)-1") (("1" (expand "circuit?") (("1" (flatten) (("1" (expand "pre_circuit?") (("1" (expand "finseq_appl") (("1" (inst -10 "0" "i+1") (("1" (assert) (("1" (inst-cp -7 "i+1") (("1" (replace -8 3 :hide? t) (("1" (expand "nth" 3 2) (("1" (replace -10 :hide? t) (("1" (inst -7 "length(w)-1") (("1" (replace -7 -8 :hide? t) (("1" (replace -1 :hide? t :dir rl) (("1" (expand "nth" -6 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst-cp -6 "i+1") (("1" (expand "nth" -7 2) (("1" (inst -6 "j+1") (("1" (expand "nth" -6 2) (("1" (inst -9 "i+1" "j+1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((walk2walki const-decl "{wi: (walk?(C)) | walk_eq(G, C)(w, wi)}" digraphs_all_cycles nil) (walk_eq const-decl "bool" digraphs_all_cycles nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (Walk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (digraph type-eq-decl nil digraph_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" cycles_ nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (< const-decl "bool" reals nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (below type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nth def-decl "T" list_props nil) (j skolem-const-decl "below(length[nat](cdr(walk2walki(G, C)(w))))" digraphs_all_cycles nil) (C skolem-const-decl "cdigraph_eq[T](G)" digraphs_all_cycles nil) (w skolem-const-decl "Walk[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](G)" digraphs_all_cycles nil) (G skolem-const-decl "digraph[T]" digraphs_all_cycles nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pre_circuit? const-decl "bool" circuits_ nil) (circuit? const-decl "bool" circuits_ nil) (i skolem-const-decl "below(length[nat](cdr(walk2walki(G, C)(w))))" digraphs_all_cycles nil) (no_repetitions? const-decl "bool" more_list_props structures)) shostak)) (circuit_walk_eq 0 (circuit_walk_eq-1 nil 3659352769 ("" (skeep) (("" (typepred "ci") (("" (hide -1) (("" (expand "circuit?") (("" (flatten) (("" (expand "walk_eq") (("" (flatten) (("" (assert) (("" (expand "finseq_appl") (("" (expand "pre_circuit?") (("" (expand "finseq_appl") (("" (inst-cp -6 "0") (("" (inst -6 "length(ci)-1") (("" (replace -5 :dir rl) (("" (replace -6 :hide? t) (("" (replace -6 :hide? t) (("" (expand "last") (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (circuit? const-decl "bool" circuits_ nil) (walk_eq const-decl "bool" digraphs_all_cycles nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (pre_circuit? const-decl "bool" circuits_ nil) (below type-eq-decl nil naturalnumbers nil) (Walk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nth def-decl "T" list_props nil) (size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak)) (cycle_walk_eq 0 (cycle_walk_eq-1 nil 3659352396 ("" (skeep) (("" (typepred "ci") (("" (hide -1) (("" (expand "cycle?") (("" (split 1) (("1" (use "circuit_walk_eq") (("1" (assert) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (skeep) (("2" (case "i=0") (("1" (expand "circuit?") (("1" (flatten) (("1" (expand "no_repetitions?") (("1" (expand "last") (("1" (expand "nth" -5) (("1" (lift-if -5) (("1" (split -5) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "length" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst -7 "length(cdr(ci))-1" "j-1") (("1" (split -7) (("1" (expand "/=") (("1" (replace -1 :dir rl :hide? t) (("1" (expand "walk_eq") (("1" (flatten) (("1" (inst-cp -7 "0") (("1" (inst -7 "j") (("1" (expand "finseq_appl") (("1" (expand "nth" -8 2) (("1" (expand "nth" -7 2) (("1" (replace -1 -2) (("1" (replace -7 :hide? t) (("1" (replace -7 :hide? t) (("1" (replace -1 :hide? t) (("1" (hide-all-but (-1 1 4)) (("1" (typepred "C") (("1" (expand "cdigraph") (("1" (flatten) (("1" (hide-all-but (-3 -6 1 2)) (("1" (expand "no_repetitions?") (("1" (inst -1 "car(ci)" "nth(cdr(ci),j-1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil) ("3" (expand "length" -6) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "j=0") (("1" (expand "circuit?") (("1" (flatten) (("1" (expand "no_repetitions?") (("1" (expand "last") (("1" (expand "nth" -5) (("1" (lift-if -5) (("1" (split -5) (("1" (grind) nil nil) ("2" (flatten) (("2" (expand "length" -1) (("2" (lift-if -1) (("2" (split -1) (("1" (flatten) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (inst -7 "i-1" "length(cdr(ci))-1") (("1" (split -7) (("1" (expand "/=") (("1" (replace -1 :dir rl :hide? t) (("1" (expand "walk_eq") (("1" (flatten) (("1" (inst-cp -7 "0") (("1" (inst -7 "i") (("1" (expand "finseq_appl") (("1" (expand "nth" -8 2) (("1" (expand "nth" -7 2) (("1" (replace -1 -2) (("1" (replace -7 :hide? t) (("1" (replace -7 :hide? t) (("1" (replace -1 :hide? t) (("1" (hide-all-but (-1 1 4)) (("1" (typepred "C") (("1" (expand "cdigraph") (("1" (flatten) (("1" (hide-all-but (-3 -6 1 2)) (("1" (expand "no_repetitions?") (("1" (inst -1 "car(ci)" "nth(cdr(ci),i-1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "/=") (("2" (grind) nil nil)) nil)) nil) ("2" (expand "length" -6) (("2" (assert) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "no_repetitions?") (("2" (expand "walk_eq") (("2" (flatten) (("2" (inst-cp -7 "i") (("2" (expand "finseq_appl") (("2" (expand "nth" -8 2) (("2" (assert) (("2" (inst -7 "j") (("2" (expand "nth" -7 2) (("2" (replace -7 :hide? t) (("2" (replace -7 :hide? t) (("2" (inst -5 "i-1" "j-1") (("2" (assert) (("2" (hide-all-but (-1 -5)) (("2" (typepred "C") (("2" (expand "cdigraph") (("2" (flatten) (("2" (hide-all-but (-3 -6 1)) (("2" (expand "no_repetitions?") (("2" (inst -1 "nth(cdr(ci), i - 1)" "nth(cdr(ci), j - 1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cycle? const-decl "bool" cycles_ nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (below type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (last const-decl "T" more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (G skolem-const-decl "digraph[T]" digraphs_all_cycles nil) (C skolem-const-decl "cdigraph_eq[T](G)" digraphs_all_cycles nil) (ci skolem-const-decl "(cycle?(C))" digraphs_all_cycles nil) (w skolem-const-decl "Walk[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](G)" digraphs_all_cycles nil) (j skolem-const-decl "below(length(w) - 1)" digraphs_all_cycles nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (/= const-decl "boolean" notequal nil) (walk_eq const-decl "bool" digraphs_all_cycles nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_minus_even_is_even application-judgement "even_int" integers nil) (length def-decl "nat" list_props nil) (size const-decl "nat" c_digraphs_def nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (nth def-decl "T" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (i skolem-const-decl "below(length(w) - 1)" digraphs_all_cycles nil) (circuit_walk_eq formula-decl nil digraphs_all_cycles nil) (Walk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil)) shostak)) (walk_eq_inj_1 0 (walk_eq_inj_1-1 nil 3659301267 ("" (skeep) (("" (expand "walk_eq") (("" (apply-extensionality) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (apply-extensionality) (("2" (flatten) (("2" (inst?) (("2" (inst?) (("2" (assert) (("2" (expand "finseq_appl") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((walk_eq const-decl "bool" digraphs_all_cycles nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (digraph_type type-eq-decl nil digraphs_imp nil) (digraph type-eq-decl nil digraph_def nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (finseq type-eq-decl nil finite_sequences nil) (T formal-type-decl nil digraphs_all_cycles nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (cyclesi2cycles_TCC1 0 (cyclesi2cycles_TCC2-1 nil 3659286530 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil digraphs_all_cycles nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (digraph type-eq-decl nil digraph_def nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (finseq type-eq-decl nil finite_sequences nil) (> const-decl "bool" reals nil) (digraph_type type-eq-decl nil digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cyclesi2cycles subtype "digraphs_all_cycles.i" "below[length[(cycle?[T](C))](cycles)]"))) (cyclesi2cycles_TCC2 0 (cyclesi2cycles_TCC1-1 nil 3659286530 ("" (skeep) (("" (typepred "nth(cycles,i)") (("" (expand "circuit?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (cyclesi2cycles subtype "0" "below[length[nat](nth[(cycle?(C))](cycles, i))]"))) (cyclesi2cycles_TCC3 0 (cyclesi2cycles_TCC3-1 "" 3884638972 ("" (skeep) (("" (typepred "nth(cycles,i)") (("" (expand "circuit?") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil) nil shostak (cyclesi2cycles subtype "0" "below[length[nat](nth[(cycle?(C))](cycles, i))]")) (cyclesi2cycles_TCC4-2 "" 3744337511 ("" (grind) nil nil) ((below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (cyclesi2cycles subtype "0" "below[length[nat](nth[(cycle?(C))](cycles, i))]")) (cyclesi2cycles_TCC4-1 nil 3659286530 ("" (subtype-tcc) nil nil) ((finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (digraph type-eq-decl nil digraph_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (Walk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (last const-decl "T" more_list_props structures) (member const-decl "bool" sets nil) (no_repetitions? const-decl "bool" more_list_props structures)) nil (cyclesi2cycles subtype "0" "below[length[nat](nth[(cycle?(C))](cycles, i))]"))) (cyclesi2cycles_TCC4 0 (cyclesi2cycles_TCC4-1 "" 3884639052 ("" (grind) nil nil) nil shostak (cyclesi2cycles subtype "list_adt[Walk[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].null" "{cs: list_adt[Walk[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].list | booleans.AND(list_props[Walk[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].length(cs) = list_props[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].length(digraphs_all_cycles.cycles), FORALL (i: naturalnumbers.below(list_props[Walk[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].length(cs))): digraphs_all_cycles.walk_eq(digraphs_all_cycles.G, digraphs_all_cycles.C)(list_props[Walk[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].nth(cs, i), list_props[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].nth(digraphs_all_cycles.cycles, i)))}")) (cyclesi2cycles_TCC8-1 nil 3744308794 ("" (skeep) (("" (split 1) (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil) ("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (typepred "v(G, C)(v_idx, cycles_)") (("1" (hide -1) (("1" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1) (("1" (replace -4 :hide? t) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst -2 "i-1") (("2" (assert) (("2" (replace -4 :hide? t) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "cycles") (("2" (hide -1) (("2" (skeep) (("2" (replace -3) (("2" (inst -1 "i!1+1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil digraphs_all_cycles nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (digraph type-eq-decl nil digraph_def nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (Walk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (C!1 skolem-const-decl "cdigraph_eq[T](G!1)" digraphs_all_cycles nil) (G!1 skolem-const-decl "digraph[T]" digraphs_all_cycles nil) (last const-decl "T" more_list_props structures) (member const-decl "bool" sets nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (walk_eq const-decl "bool" digraphs_all_cycles nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cyclesi2cycles subtype "list_adt[Walk[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].null" "{cs: list_adt[Walk[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].list | booleans.AND(list_props[Walk[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].length(cs) = list_props[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].length(digraphs_all_cycles.cycles), FORALL (i: naturalnumbers.below(list_props[Walk[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].length(cs))): digraphs_all_cycles.walk_eq(digraphs_all_cycles.G, digraphs_all_cycles.C)(list_props[Walk[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].nth(cs, i), list_props[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].nth(digraphs_all_cycles.cycles, i)))}"))) (cyclesi2cycles_TCC5 0 (cyclesi2cycles_TCC5-2 "" 3744337540 ("" (subtype-tcc) nil nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (cyclesi2cycles subtype "digraphs_all_cycles.G" "digraph_eq[digraphs_all_cycles.T](digraphs_all_cycles.C)")) (cyclesi2cycles_TCC5-1 nil 3659286530 ("" (skeep) (("" (skeep) (("" (typepred "cycles") (("" (hide -1) (("" (replace -2) (("" (inst -1 "i+1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (cyclesi2cycles subtype "digraphs_all_cycles.G" "digraph_eq[digraphs_all_cycles.T](digraphs_all_cycles.C)"))) (cyclesi2cycles_TCC6 0 (cyclesi2cycles_TCC6-1 nil 3659292745 ("" (skeep) (("" (skeep) (("" (typepred "cycles") (("" (hide -1) (("" (replace -2) (("" (inst -1 "i+1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((minus_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cycles skolem-const-decl "{cycles: list[(cycle?(C))] |
   FORALL (i: below(length(cycles))): nth(nth(cycles, i), 0) = v_idx}" digraphs_all_cycles nil) (v_idx skolem-const-decl "below(size[T](C))" digraphs_all_cycles nil) (i skolem-const-decl "below(length(cycles_))" digraphs_all_cycles nil) (cycles_ skolem-const-decl "list[(cycle?[T](C))]" digraphs_all_cycles nil) (C skolem-const-decl "cdigraph_eq[T](G)" digraphs_all_cycles nil) (G skolem-const-decl "digraph[T]" digraphs_all_cycles nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil digraphs_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph type-eq-decl nil digraph_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (size const-decl "nat" c_digraphs_def nil)) nil (cyclesi2cycles subtype "digraphs_all_cycles.cycles_" "{cycles: list_adt[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].list | FORALL (i: naturalnumbers.below(list_props[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].length(cycles))): list_props[nat].nth(list_props[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].nth(cycles, i), 0) = digraphs_all_cycles.v_idx}"))) (cyclesi2cycles_TCC7 0 (cyclesi2cycles_TCC7-2 "" 3790101705 ("" (skeep) (("" (replace -1 :hide? t) (("" (grind) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (cyclesi2cycles termination "digraphs_all_cycles.cyclesi2cycles(digraphs_all_cycles.G, digraphs_all_cycles.C)(digraphs_all_cycles.v_idx, digraphs_all_cycles.cycles_)" "nil")) (cyclesi2cycles_TCC7-1 nil 3659292745 ("" (skeep) (("" (split 1) (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil) ("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (typepred "v(G, C)(v_idx, cycles_)") (("1" (hide -1) (("1" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1) (("1" (replace -4 :hide? t) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst -2 "i-1") (("2" (assert) (("2" (replace -4 :hide? t) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "cycles") (("2" (hide -1) (("2" (skeep) (("2" (replace -3) (("2" (inst -1 "i!1+1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil (cyclesi2cycles termination "digraphs_all_cycles.cyclesi2cycles(digraphs_all_cycles.G, digraphs_all_cycles.C)(digraphs_all_cycles.v_idx, digraphs_all_cycles.cycles_)" "nil"))) (cyclesi2cycles_TCC8 0 (cyclesi2cycles_TCC8-1 nil 3884635216 ("" (skeep) (("" (split 1) (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil) ("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (typepred "v(G, C)(v_idx, cycles_)") (("1" (hide -1) (("1" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1) (("1" (replace -4 :hide? t) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst -2 "i-1") (("2" (assert) (("2" (replace -4 :hide? t) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "cycles") (("2" (hide -1) (("2" (skeep) (("2" (replace -3) (("2" (inst -1 "i!1+1") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (walki2walk const-decl "{w: Walk(G) | walk_eq(G, C)(w, cw)}" digraphs_all_cycles nil) (cycles skolem-const-decl "{cycles: list[(cycle?(C))] |
   FORALL (i: below(length(cycles))): nth(nth(cycles, i), 0) = v_idx}" digraphs_all_cycles nil) (v_idx skolem-const-decl "below(size[T](C))" digraphs_all_cycles nil) (i!1 skolem-const-decl "below(length(cycles_))" digraphs_all_cycles nil) (cycles_ skolem-const-decl "list[(cycle?[T](C))]" digraphs_all_cycles nil) (C skolem-const-decl "cdigraph_eq[T](G)" digraphs_all_cycles nil) (G skolem-const-decl "digraph[T]" digraphs_all_cycles nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (digraph_eq type-eq-decl nil c_digraphs_digraphs nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil digraphs_all_cycles nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph_type type-eq-decl nil digraphs_imp nil) (digraph type-eq-decl nil digraph_def nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (below type-eq-decl nil naturalnumbers nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (< const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (nth def-decl "T" list_props nil) (Walk type-eq-decl nil walks_ nil) (walk_eq const-decl "bool" digraphs_all_cycles nil)) nil (cyclesi2cycles subtype "list_adt[Walk[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].cons(digraphs_all_cycles.walki2walk(digraphs_all_cycles.C, digraphs_all_cycles.G)(digraphs_all_cycles.cycle), digraphs_all_cycles.cyclesi2cycles(digraphs_all_cycles.G, digraphs_all_cycles.C)(digraphs_all_cycles.v_idx, digraphs_all_cycles.cycles_))" "{cs: list_adt[Walk[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].list | booleans.AND(list_props[Walk[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].length(cs) = list_props[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].length(digraphs_all_cycles.cycles), FORALL (i: naturalnumbers.below(list_props[Walk[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].length(cs))): digraphs_all_cycles.walk_eq(digraphs_all_cycles.G, digraphs_all_cycles.C)(list_props[Walk[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].nth(cs, i), list_props[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].nth(digraphs_all_cycles.cycles, i)))}"))) (cac2dac_rec_TCC1 0 (cac2dac_rec_TCC2-1 nil 3659281098 ("" (skeep) (("" (typepred "C") (("" (skeep :preds? t) (("" (replace -4 1 :dir rl) (("" (typepred "cs") (("" (use "eq_same_size") (("" (assert) (("" (expand "size") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((VertList type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert? const-decl "bool" digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (= const-decl "[T, T -> boolean]" equalities nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (eq_same_size formula-decl nil c_digraphs_digraphs nil) (size const-decl "nat" digraph_def nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)) nil (cac2dac_rec subtype "(number_fields.+)(digraphs_all_cycles.n, digraphs_all_cycles.offset)" "below[length[T](vl)]"))) (cac2dac_rec_TCC2 0 (cac2dac_rec_TCC1-1 nil 3659281098 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (digraph type-eq-decl nil digraph_def nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (digraph_type type-eq-decl nil digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (vert? const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (VertList type-eq-decl nil digraphs_ nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (= const-decl "[T, T -> boolean]" equalities nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (member const-decl "bool" sets nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (last const-decl "T" more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (T formal-type-decl nil digraphs_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cac2dac_rec subtype "digraphs_all_cycles.cycle" "(list_adt[nat].cons?)"))) (cac2dac_rec_TCC3 0 (cac2dac_rec_TCC4-2 "" 3790101710 ("" (skeep) (("" (typepred "cs") (("" (hide -1) (("" (expand "size") (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (VertList type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert? const-decl "bool" digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (= const-decl "[T, T -> boolean]" equalities nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (VertCycles type-eq-decl nil cycles_ nil) (CyclesAt type-eq-decl nil cycles_ nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (cac2dac_rec subtype "list_adt[VertCycles[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].null" "{l: list_adt[VertCycles[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].list | booleans.AND(list_props[VertCycles[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].length(l) = list_props[list[(cycle?[T](C))]].length(digraphs_all_cycles.cs), FORALL (n: naturalnumbers.below(list_props[VertCycles[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].length(l))): list_props[digraphs_all_cycles.T].nth(digraphs_all_cycles.vl, (number_fields.+)(n, digraphs_all_cycles.offset)) = vert(list_props[VertCycles[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].nth(l, n)))}")) (cac2dac_rec_TCC4-1 nil 3659286530 ("" (skeep) (("" (typepred "cs") (("" (hide -1) (("" (expand "size") (("" (replace -1 :dir rl :hide? t) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((size const-decl "nat" c_digraphs_def nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (VertList type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert? const-decl "bool" digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (VertCycles type-eq-decl nil cycles_ nil) (CyclesAt type-eq-decl nil cycles_ nil)) nil (cac2dac_rec subtype "list_adt[VertCycles[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].null" "{l: list_adt[VertCycles[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].list | booleans.AND(list_props[VertCycles[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].length(l) = list_props[list[(cycle?[T](C))]].length(digraphs_all_cycles.cs), FORALL (n: naturalnumbers.below(list_props[VertCycles[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].length(l))): list_props[digraphs_all_cycles.T].nth(digraphs_all_cycles.vl, (number_fields.+)(n, digraphs_all_cycles.offset)) = vert(list_props[VertCycles[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].nth(l, n)))}"))) (cac2dac_rec_TCC4 0 (cac2dac_rec_TCC5-2 "" 3744337689 ("" (skeep) (("" (typepred "cs") (("" (hide -1) (("" (expand "size") (("" (replace -1 :dir rl :hide? t) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (VertList type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert? const-decl "bool" digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (= const-decl "[T, T -> boolean]" equalities nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (cac2dac_rec subtype "digraphs_all_cycles.offset" "below[length[T](data(C))]")) (cac2dac_rec_TCC5-1 nil 3659286530 ("" (skeep) (("" (typepred "C") (("" (expand "eq") (("" (expand "vert?") (("" (expand "digraph_verts") (("" (flatten) (("" (replace -2 :dir rl :hide? t) (("" (typepred "list2set[T]((C::{C: cdigraph_eq(G) | data(C) = vl})`data)") (("" (replace -2 :hide? t) (("" (assert) (("" (use "nth_member[T]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((size const-decl "nat" c_digraphs_def nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (VertList type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert? const-decl "bool" digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil)) nil (cac2dac_rec subtype "digraphs_all_cycles.offset" "below[length[T](data(C))]"))) (cac2dac_rec_TCC5 0 (cac2dac_rec_TCC6-2 "" 3744337724 ("" (skeep) (("" (typepred "C") (("" (expand "eq") (("" (expand "vert?") (("" (expand "digraph_verts") (("" (flatten) (("" (replace -2 :dir rl :hide? t) (("" (typepred "list2set[T]((C::{C: cdigraph_eq(G) | data(C) = vl})`data)") (("" (replace -2 :hide? t) (("" (assert) (("" (use "nth_member[T]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((VertList type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert? const-decl "bool" digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (= const-decl "[T, T -> boolean]" equalities nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}" set_as_list structures) (member def-decl "bool" list_props nil) (nth_member formula-decl nil more_list_props structures) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil)) shostak (cac2dac_rec subtype "list_props[digraphs_all_cycles.T].nth(data(digraphs_all_cycles.C), digraphs_all_cycles.offset)" "vert[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)")) (cac2dac_rec_TCC6-1 nil 3659286530 ("" (skeep) (("" (typepred "cs") (("" (grind) nil nil)) nil)) nil) ((VertList type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert? const-decl "bool" digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}" set_as_list structures) (nth_member formula-decl nil more_list_props structures)) nil (cac2dac_rec subtype "list_props[digraphs_all_cycles.T].nth(data(digraphs_all_cycles.C), digraphs_all_cycles.offset)" "vert[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)"))) (cac2dac_rec_TCC6 0 (cac2dac_rec_TCC7-2 "" 3744337751 ("" (skeep) (("" (typepred "cs") (("" (grind) nil nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (VertList type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert? const-decl "bool" digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (= const-decl "[T, T -> boolean]" equalities nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (last const-decl "T" more_list_props structures) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (cac2dac_rec subtype "digraphs_all_cycles.offset" "below(c_digraphs_def[digraphs_all_cycles.T].size(digraphs_all_cycles.C))")) (cac2dac_rec_TCC7-1 nil 3659286530 ("" (skeep) (("" (skeep) (("" (typepred "cs") (("" (hide -1) (("" (replace -3 :hide? t) (("" (inst -2 "0") (("1" (expand "nth" -2) (("1" (expand "nth" 1 1) (("1" (inst -2 "nth(cycles,i)") (("1" (assert) (("1" (use "nth_member[(cycle?(C))]") nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -2) (("2" (replace -1 :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((size const-decl "nat" c_digraphs_def nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (VertList type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert? const-decl "bool" digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (no_repetitions? const-decl "bool" more_list_props structures) (last const-decl "T" more_list_props structures)) nil (cac2dac_rec subtype "digraphs_all_cycles.offset" "below(c_digraphs_def[digraphs_all_cycles.T].size(digraphs_all_cycles.C))"))) (cac2dac_rec_TCC7 0 (cac2dac_rec_TCC8-2 "" 3744337784 ("" (skeep) (("" (skeep) (("" (typepred "cs") (("" (hide -1) (("" (replace -3 :hide? t) (("" (inst -2 "0") (("1" (expand "nth" -2) (("1" (expand "nth" 1 1) (("1" (inst -2 "nth(cycles,i)") (("1" (assert) (("1" (use "nth_member[(cycle?(C))]") nil nil)) nil)) nil)) nil)) nil) ("2" (reveal -2) (("2" (replace -1 :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cs skolem-const-decl "{cs: list[list[(cycle?(C))]] |
   length(cs) + offset = size(C) AND
    FORALL (i: below(length(cs))):
      FORALL (cycle: (cycle?(C))):
        member(cycle, nth(cs, i)) IFF car(cycle) = i + offset}" digraphs_all_cycles nil) (offset skolem-const-decl "nat" digraphs_all_cycles nil) (C skolem-const-decl "{C: cdigraph_eq(G) | data(C) = vl}" digraphs_all_cycles nil) (vl skolem-const-decl "VertList
    [T, digraph_type[T], digraph_verts[T], digraph_edges[T],
     digraph_size[T], digraph_make[T]](G)" digraphs_all_cycles nil) (G skolem-const-decl "digraph[T]" digraphs_all_cycles nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nth_member formula-decl nil more_list_props structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil digraphs_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph type-eq-decl nil digraph_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (= const-decl "[T, T -> boolean]" equalities nil) (digraph_type type-eq-decl nil digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (vert? const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (VertList type-eq-decl nil digraphs_ nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)) shostak (cac2dac_rec subtype "digraphs_all_cycles.cycles" "{cycles: list_adt[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].list | FORALL (i: naturalnumbers.below(list_props[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].length(cycles))): list_props[nat].nth(list_props[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].nth(cycles, i), 0) = digraphs_all_cycles.offset}")) (cac2dac_rec_TCC8-1 nil 3659286530 ("" (skeep) (("" (skeep) (("" (typepred "cs") (("" (hide -1) (("" (replace -3 :hide? t) (("" (inst -2 "0") (("1" (expand "nth" -2) (("1" (typepred "cyclesi2cycles(G, C)(offset, cycles)") (("1" (hide -1) (("1" (expand "cycle_at?") (("1" (expand "finseq_appl") (("1" (split 1) (("1" (flatten) (("1" (use "member_nth[Walk(G)]") (("1" (assert) (("1" (hide -2) (("1" (skeep -1) (("1" (inst -3 "i") (("1" (inst -5 "nth(cycles,i)") (("1" (use "nth_member[(cycle?(C))]") (("1" (assert) (("1" (expand "walk_eq") (("1" (flatten) (("1" (expand "finseq_appl") (("1" (replace -2 :hide? t) (("1" (inst -4 "0") (("1" (replace -4 :hide? t) (("1" (expand "nth" 1 2) (("1" (use "cycle_walk_eq") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "EXISTS(cc: (cycle?(C))): walk_eq(G,C)(walk,cc)") (("1" (skeep -1) (("1" (inst -7 "cc") (("1" (flatten -7) (("1" (hide -7) (("1" (split -) (("1" (use "member_nth[(cycle?(C))]") (("1" (assert) (("1" (skeep -1) (("1" (inst -7 "i") (("1" (replace -1 :hide? t) (("1" (lemma "walk_eq_inj_1") (("1" (inst? -1 :where -3) (("1" (inst? -1 :where -7) (("1" (assert) (("1" (replace -1) (("1" (use "nth_member[Walk(G)]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "walk_eq" -1) (("2" (flatten) (("2" (inst -2 "0") (("2" (expand "finseq_appl") (("2" (replace -2 :hide? t) (("2" (hide-all-but (-3 1)) (("2" (expand "nth" -1 2) (("2" (typepred "C") (("2" (expand "cdigraph") (("2" (flatten) (("2" (expand "no_repetitions?" -3) (("2" (inst -3 "car(cc)" "offset") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "walk2walki(G,C)(walk)") (("1" (typepred "walk2walki(G,C)(walk)") (("1" (propax) nil nil)) nil) ("2" (use "w2wi_cycle") (("2" (assert) (("2" (expand "cycle?") (("2" (flatten) (("2" (use "w2wi_circuit") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -2) (("2" (replace -1 :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth_member formula-decl nil more_list_props structures) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (digraph type-eq-decl nil digraph_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (digraph_type type-eq-decl nil digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (vert? const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (VertList type-eq-decl nil digraphs_ nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil)) nil (cac2dac_rec subtype "digraphs_all_cycles.cycles" "{cycles: list_adt[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].list | FORALL (i: naturalnumbers.below(list_props[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].length(cycles))): list_props[nat].nth(list_props[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].nth(cycles, i), 0) = digraphs_all_cycles.offset}"))) (cac2dac_rec_TCC8 0 (cac2dac_rec_TCC9-2 "" 3744337872 ("" (skeep) (("" (skeep) (("" (typepred "cs") (("" (hide -1) (("" (replace -3 :hide? t) (("" (inst -2 "0") (("1" (expand "nth" -2) (("1" (typepred "cyclesi2cycles(G, C)(offset, cycles)") (("1" (hide -1) (("1" (expand "cycle_at?") (("1" (expand "finseq_appl") (("1" (split 1) (("1" (flatten) (("1" (use "member_nth[Walk(G)]") (("1" (assert) (("1" (hide -2) (("1" (skeep -1) (("1" (inst -3 "i") (("1" (inst -5 "nth(cycles,i)") (("1" (use "nth_member[(cycle?(C))]") (("1" (assert) (("1" (expand "walk_eq") (("1" (flatten) (("1" (expand "finseq_appl") (("1" (replace -2 :hide? t) (("1" (inst -4 "0") (("1" (replace -4 :hide? t) (("1" (expand "nth" 1 2) (("1" (use "cycle_walk_eq") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "EXISTS(cc: (cycle?(C))): walk_eq(G,C)(walk,cc)") (("1" (skeep -1) (("1" (inst -7 "cc") (("1" (flatten -7) (("1" (hide -7) (("1" (split -) (("1" (use "member_nth[(cycle?(C))]") (("1" (assert) (("1" (skeep -1) (("1" (inst -7 "i") (("1" (replace -1 :hide? t) (("1" (lemma "walk_eq_inj_1") (("1" (inst? -1 :where -3) (("1" (inst? -1 :where -7) (("1" (assert) (("1" (replace -1) (("1" (use "nth_member[Walk(G)]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "walk_eq" -1) (("2" (flatten) (("2" (inst -2 "0") (("2" (expand "finseq_appl") (("2" (replace -2 :hide? t) (("2" (hide-all-but (-3 1)) (("2" (expand "nth" -1 2) (("2" (typepred "C") (("2" (expand "cdigraph") (("2" (flatten) (("2" (expand "no_repetitions?" -3) (("2" (inst -3 "car(cc)" "offset") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "walk2walki(G,C)(walk)") (("1" (typepred "walk2walki(G,C)(walk)") (("1" (propax) nil nil)) nil) ("2" (use "w2wi_cycle") (("2" (assert) (("2" (expand "cycle?") (("2" (flatten) (("2" (use "w2wi_circuit") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (reveal -2) (("2" (replace -1 :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (cs skolem-const-decl "{cs: list[list[(cycle?(C))]] |
   length(cs) + offset = size(C) AND
    FORALL (i: below(length(cs))):
      FORALL (cycle: (cycle?(C))):
        member(cycle, nth(cs, i)) IFF car(cycle) = i + offset}" digraphs_all_cycles nil) (offset skolem-const-decl "nat" digraphs_all_cycles nil) (C skolem-const-decl "{C: cdigraph_eq(G) | data(C) = vl}" digraphs_all_cycles nil) (vl skolem-const-decl "VertList
    [T, digraph_type[T], digraph_verts[T], digraph_edges[T],
     digraph_size[T], digraph_make[T]](G)" digraphs_all_cycles nil) (G skolem-const-decl "digraph[T]" digraphs_all_cycles nil) (finseq type-eq-decl nil finite_sequences nil) (> const-decl "bool" reals nil) (prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (walk_eq const-decl "bool" digraphs_all_cycles nil) (cyclesi2cycles def-decl "{cs:
   list[Walk[T, digraph_type[T], digraph_verts, digraph_edges,
             digraph_size, digraph_make](G)] |
   length(cs) = length(cycles) AND
    FORALL (i: below(length(cs))):
      walk_eq(G, C)(nth(cs, i), nth(cycles, i))}" digraphs_all_cycles nil) (cycle_at? const-decl "bool" cycles_ nil) (member_nth formula-decl nil more_list_props structures) (nth_member formula-decl nil more_list_props structures) (cycle_walk_eq formula-decl nil digraphs_all_cycles nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (no_repetitions? const-decl "bool" more_list_props structures) (walk_eq_inj_1 formula-decl nil digraphs_all_cycles nil) (w2wi_cycle formula-decl nil digraphs_all_cycles nil) (cycle? const-decl "bool" cycles_ nil) (w2wi_circuit formula-decl nil digraphs_all_cycles nil) (walk skolem-const-decl "Walk[T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
     digraph_make](G)" digraphs_all_cycles nil) (walk2walki const-decl "{wi: (walk?(C)) | walk_eq(G, C)(w, wi)}" digraphs_all_cycles nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil digraphs_all_cycles nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (digraph type-eq-decl nil digraph_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (= const-decl "[T, T -> boolean]" equalities nil) (digraph_type type-eq-decl nil digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (vert? const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (VertList type-eq-decl nil digraphs_ nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)) shostak (cac2dac_rec subtype "digraphs_all_cycles.cyclesi2cycles(digraphs_all_cycles.G, digraphs_all_cycles.C)(digraphs_all_cycles.offset, digraphs_all_cycles.cycles)" "CyclesAt[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G, list_props[digraphs_all_cycles.T].nth(data(digraphs_all_cycles.C), digraphs_all_cycles.offset))")) (cac2dac_rec_TCC9-1 nil 3659286530 ("" (skeep) (("" (typepred "cs") (("" (hide -1) (("" (replace -1 :dir rl) (("" (assert) (("" (replace -3) (("" (expand "length" 1 2) (("" (skeep :preds? t) (("" (inst -3 "i+1") (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (replace -3 :dir rl) (("1" (expand "nth" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((prewalk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (Walk type-eq-decl nil walks_ nil) (cycle_at? const-decl "bool" cycles_ nil) (member_nth formula-decl nil more_list_props structures) (nth_member formula-decl nil more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (cycle? const-decl "bool" cycles_ nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (digraph type-eq-decl nil digraph_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (digraph_type type-eq-decl nil digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (vert? const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (VertList type-eq-decl nil digraphs_ nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil)) nil (cac2dac_rec subtype "digraphs_all_cycles.cyclesi2cycles(digraphs_all_cycles.G, digraphs_all_cycles.C)(digraphs_all_cycles.offset, digraphs_all_cycles.cycles)" "CyclesAt[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G, list_props[digraphs_all_cycles.T].nth(data(digraphs_all_cycles.C), digraphs_all_cycles.offset))"))) (cac2dac_rec_TCC9 0 (cac2dac_rec_TCC10-1 nil 3659286530 ("" (skeep) (("" (typepred "cs") (("" (hide -1) (("" (replace -1 :dir rl) (("" (assert) (("" (replace -3) (("" (expand "length" 1 2) (("" (skeep :preds? t) (("" (inst -3 "i+1") (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (replace -3 :dir rl) (("1" (expand "nth" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replace -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (VertList type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert? const-decl "bool" digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (= const-decl "[T, T -> boolean]" equalities nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (G skolem-const-decl "digraph[T]" digraphs_all_cycles nil) (vl skolem-const-decl "VertList
    [T, digraph_type[T], digraph_verts[T], digraph_edges[T],
     digraph_size[T], digraph_make[T]](G)" digraphs_all_cycles nil) (C skolem-const-decl "{C: cdigraph_eq(G) | data(C) = vl}" digraphs_all_cycles nil) (cs_ skolem-const-decl "list[list[(cycle?[T](C))]]" digraphs_all_cycles nil) (i skolem-const-decl "below(length(cs_))" digraphs_all_cycles nil) (offset skolem-const-decl "nat" digraphs_all_cycles nil) (cs skolem-const-decl "{cs: list[list[(cycle?(C))]] |
   length(cs) + offset = size(C) AND
    FORALL (i: below(length(cs))):
      FORALL (cycle: (cycle?(C))):
        member(cycle, nth(cs, i)) IFF car(cycle) = i + offset}" digraphs_all_cycles nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (cac2dac_rec subtype "digraphs_all_cycles.cs_" "{cs: list_adt[list[(cycle?[T](C))]].list | booleans.AND((number_fields.+)((number_fields.+)(1, digraphs_all_cycles.offset), list_props[list[(cycle?[T](C))]].length(cs)) = c_digraphs_def[digraphs_all_cycles.T].size(digraphs_all_cycles.C), FORALL (i: naturalnumbers.below(list_props[list[(cycle?[T](C))]].length(cs))): FORALL (cycle: (c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].member(cycle, list_props[list[(cycle?[T](C))]].nth(cs, i)), list_adt[nat].car(cycle) = (number_fields.+)((number_fields.+)(1, i), digraphs_all_cycles.offset)))}"))) (cac2dac_rec_TCC10 0 (cac2dac_rec_TCC11-2 "" 3744337930 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil digraphs_all_cycles nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (digraph type-eq-decl nil digraph_def nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (digraph_type type-eq-decl nil digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (vert? const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (VertList type-eq-decl nil digraphs_ nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (= const-decl "[T, T -> boolean]" equalities nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (size const-decl "nat" c_digraphs_def nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (last const-decl "T" more_list_props structures) (member const-decl "bool" sets nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) shostak (cac2dac_rec termination "digraphs_all_cycles.cac2dac_rec(digraphs_all_cycles.G, digraphs_all_cycles.vl, digraphs_all_cycles.C)((number_fields.+)(digraphs_all_cycles.offset, 1), digraphs_all_cycles.cs_)" "nil")) (cac2dac_rec_TCC11-1 nil 3659293896 ("" (skeep) (("" (typepred "v(G, vl, C)(offset + 1, cs_)") (("1" (split 1) (("1" (replace -3 :hide? t) (("1" (expand "length" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (case "n=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1 2) (("1" (typepred "C") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -3 "n-1") (("1" (assert) (("1" (expand "nth" 2 2) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (typepred "cs") (("3" (replace -2 :dir rl) (("3" (assert) (("3" (replace -4) (("3" (expand "length" 1 2) (("3" (skeep :preds? t) (("3" (skeep) (("3" (inst -4 "i+1") (("1" (inst?) (("1" (replace -4 :dir rl) (("1" (expand "nth" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_set type-eq-decl nil finite_sets nil) (predigraph type-eq-decl nil digraph_def nil) (digraph type-eq-decl nil digraph_def nil) (digraph_type type-eq-decl nil digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (vert? const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (VertList type-eq-decl nil digraphs_ nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (last const-decl "T" more_list_props structures) (member const-decl "bool" sets nil) (no_repetitions? const-decl "bool" more_list_props structures)) nil (cac2dac_rec termination "digraphs_all_cycles.cac2dac_rec(digraphs_all_cycles.G, digraphs_all_cycles.vl, digraphs_all_cycles.C)((number_fields.+)(digraphs_all_cycles.offset, 1), digraphs_all_cycles.cs_)" "nil"))) (cac2dac_rec_TCC11 0 (cac2dac_rec_TCC12-1 nil 3744308794 ("" (skeep) (("" (typepred "v(G, vl, C)(offset + 1, cs_)") (("1" (split 1) (("1" (replace -3 :hide? t) (("1" (expand "length" 1) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (expand "length" -1) (("2" (case "n=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1 2) (("1" (typepred "C") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -3 "n-1") (("1" (assert) (("1" (expand "nth" 2 2) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (typepred "cs") (("3" (replace -2 :dir rl) (("3" (assert) (("3" (replace -4) (("3" (expand "length" 1 2) (("3" (skeep :preds? t) (("3" (skeep) (("3" (inst -4 "i+1") (("1" (inst?) (("1" (replace -4 :dir rl) (("1" (expand "nth" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (vert_list const-decl "bool" digraphs_ nil) (vert? const-decl "bool" digraphs_ nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (VertList type-eq-decl nil digraphs_ nil) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (VertCycles type-eq-decl nil cycles_ nil) (CyclesAt type-eq-decl nil cycles_ nil) (vert type-eq-decl nil digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph type-eq-decl nil digraph_def nil) (digraph_type type-eq-decl nil digraphs_imp nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil digraphs_all_cycles nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cyclesi2cycles def-decl "{cs:
   list[Walk[T, digraph_type[T], digraph_verts, digraph_edges,
             digraph_size, digraph_make](G)] |
   length(cs) = length(cycles) AND
    FORALL (i: below(length(cs))):
      walk_eq(G, C)(nth(cs, i), nth(cycles, i))}" digraphs_all_cycles nil) (walk_eq const-decl "bool" digraphs_all_cycles nil) (Walk type-eq-decl nil walks_ nil) (walk? const-decl "bool" walks_ nil) (prewalk type-eq-decl nil walks_ nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (G skolem-const-decl "digraph[T]" digraphs_all_cycles nil) (vl skolem-const-decl "VertList
    [T, digraph_type[T], digraph_verts[T], digraph_edges[T],
     digraph_size[T], digraph_make[T]](G)" digraphs_all_cycles nil) (C skolem-const-decl "{C: cdigraph_eq(G) | data(C) = vl}" digraphs_all_cycles nil) (offset skolem-const-decl "nat" digraphs_all_cycles nil) (cycles skolem-const-decl "list[(cycle?[T](C))]" digraphs_all_cycles nil) (cs skolem-const-decl "{cs: list[list[(cycle?(C))]] |
   length(cs) + offset = size(C) AND
    FORALL (i: below(length(cs))):
      FORALL (cycle: (cycle?(C))):
        member(cycle, nth(cs, i)) IFF car(cycle) = i + offset}" digraphs_all_cycles nil) (v skolem-const-decl "[d1:
   [G: digraph[T],
    vl:
      VertList
          [T, digraph_type[T], digraph_verts, digraph_edges, digraph_size,
           digraph_make](G),
    {C: cdigraph_eq(G) | data(C) = vl}] ->
   [d2:
      {z:
         [offset: nat,
          {cs: list[list[(cycle?(d1`3))]] |
             offset + length(cs) = size(d1`3) AND
              FORALL (i: below(length(cs))):
                FORALL (cycle: (cycle?(d1`3))):
                  member(cycle, nth(cs, i)) IFF car(cycle) = i + offset}] |
         length(z`2) < length(cs)} ->
      {l:
         list[VertCycles
                  [T, digraph_type[T], digraph_verts, digraph_edges,
                   digraph_size, digraph_make](d1`1)] |
         length(l) = length(d2`2) AND
          FORALL (n: below(length(l))):
            nth[T](d1`2, n + d2`1) = vert(nth(l, n))}]]" digraphs_all_cycles nil) (cs_ skolem-const-decl "list[list[(cycle?[T](C))]]" digraphs_all_cycles nil) (n skolem-const-decl "below(length(cons((# vert := nth(data(C), offset),
                     cycles := cyclesi2cycles(G, C)(offset, cycles) #),
                  v(G, vl, C)(1 + offset, cs_))))" digraphs_all_cycles nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (last const-decl "T" more_list_props structures) (i skolem-const-decl "below(length(cs_))" digraphs_all_cycles nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil)) nil (cac2dac_rec subtype "list_adt[VertCycles[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].cons((# vert := list_props[digraphs_all_cycles.T].nth(data(digraphs_all_cycles.C), digraphs_all_cycles.offset), cycles := digraphs_all_cycles.cyclesi2cycles(digraphs_all_cycles.G, digraphs_all_cycles.C)(digraphs_all_cycles.offset, digraphs_all_cycles.cycles) #), digraphs_all_cycles.cac2dac_rec(digraphs_all_cycles.G, digraphs_all_cycles.vl, digraphs_all_cycles.C)((number_fields.+)(digraphs_all_cycles.offset, 1), digraphs_all_cycles.cs_))" "{l: list_adt[VertCycles[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].list | booleans.AND(list_props[VertCycles[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].length(l) = list_props[list[(cycle?[T](C))]].length(digraphs_all_cycles.cs), FORALL (n: naturalnumbers.below(list_props[VertCycles[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].length(l))): list_props[digraphs_all_cycles.T].nth(digraphs_all_cycles.vl, (number_fields.+)(n, digraphs_all_cycles.offset)) = vert(list_props[VertCycles[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G)].nth(l, n)))}"))) (cac2dac_TCC1 0 (cac2dac_TCC3-1 nil 3659271042 ("" (skeep) (("" (typepred "all_cycles(C)") (("" (assert) (("" (skeep*) (("" (inst? -3) nil nil)) nil)) nil)) nil)) nil) ((all_cycles const-decl "{cs: list[list[(cycle?(C))]] |
   length(cs) = size(C) AND
    FORALL (i: below(size(C))):
      FORALL (cycle: (cycle?(C))):
        member(cycle, nth(cs, i)) IFF car(cycle) = i}" c_digraph_all_cycles nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (length def-decl "nat" list_props nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (VertList type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert? const-decl "bool" digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (= const-decl "[T, T -> boolean]" equalities nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (cac2dac subtype "c_digraph_all_cycles[digraphs_all_cycles.T].all_cycles(digraphs_all_cycles.C)" "{cs: list_adt[list[(cycle?[T](C))]].list | booleans.AND(list_props[list[(cycle?[T](C))]].length(cs) = c_digraphs_def[digraphs_all_cycles.T].size(digraphs_all_cycles.C), FORALL (i: naturalnumbers.below(list_props[list[(cycle?[T](C))]].length(cs))): FORALL (cycle: (c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))): booleans.IFF(list_props[(c_digraph_all_cycles[digraphs_all_cycles.T].cycle?(digraphs_all_cycles.C))].member(cycle, list_props[list[(cycle?[T](C))]].nth(cs, i)), list_adt[nat].car(cycle) = i))}"))) (cac2dac_TCC2 0 (cac2dac_TCC4-2 "" 3790101728 ("" (skeep) (("" (typepred "all_cycles(C)") (("" (typepred "cac2dac_rec(G, vl, C)(0, all_cycles[T](C))") (("1" (case "length
          [VertCycles(G)]
          (cac2dac_rec(G, vl, C)(0, all_cycles[T](C)))
       =
       length
           [vert(G)]
           (vl)") (("1" (assert) nil nil) ("2" (hide 2) (("2" (replace -1 :hide? t) (("2" (typepred "C") (("2" (replace -3 1 :dir rl :hide? t) (("2" (assert) (("2" (use "eq_same_size") (("2" (expand "size") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (skeep*) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((all_cycles const-decl "{cs: list[list[(cycle?(C))]] |
   length(cs) = size(C) AND
    FORALL (i: below(size(C))):
      FORALL (cycle: (cycle?(C))):
        member(cycle, nth(cs, i)) IFF car(cycle) = i}" c_digraph_all_cycles nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (length def-decl "nat" list_props nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (VertList type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert? const-decl "bool" digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (= const-decl "[T, T -> boolean]" equalities nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil digraphs_all_cycles nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_nzint_is_nzint application-judgement "nzint" integers nil) (eq_same_size formula-decl nil c_digraphs_digraphs nil) (size const-decl "nat" digraph_def nil) (CyclesAt type-eq-decl nil cycles_ nil) (VertCycles type-eq-decl nil cycles_ nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (cac2dac_rec def-decl "{l:
   list[VertCycles
            [T, digraph_type[T], digraph_verts, digraph_edges,
             digraph_size, digraph_make](G)] |
   length(l) = length(cs) AND
    FORALL (n: below(length(l))): nth[T](vl, n + offset) = vert(nth(l, n))}" digraphs_all_cycles nil)) shostak (cac2dac subtype "digraphs_all_cycles.cac2dac_rec(digraphs_all_cycles.G, digraphs_all_cycles.vl, digraphs_all_cycles.C)(0, c_digraph_all_cycles[digraphs_all_cycles.T].all_cycles(digraphs_all_cycles.C))" "VCList[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G, digraphs_all_cycles.vl)")) (cac2dac_TCC4-1 nil 3659281169 ("" (skeep) (("" (typepred "all_cycles(C)") (("" (typepred "cac2dac_rec(G, vl, C)(0, all_cycles[T](C))") (("1" (invoke (case "%1") (! 1 1)) (("1" (assert) (("1" (hide -4) (("1" (skeep :preds? t) (("1" (replace -2 :hide? t) (("1" (replace -2 :hide? t) (("1" (replace -3 :hide? t) (("1" (inst -2 "n") (("1" (hide-all-but (-2 1)) (("1" (use "nth_overloading[T,vert
                [T, digraph_type[T], digraph_verts, digraph_edges,
                 digraph_size, digraph_make](G)]") (("1" (replace -1 :hide? t) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (replace -1 :hide? t) (("2" (typepred "C") (("2" (replace -3 1 :dir rl :hide? t) (("2" (assert) (("2" (use "eq_same_size") (("2" (expand "size") (("2" (use "length_overloading[T,vert
                [T, digraph_type[T], digraph_verts, digraph_edges,
                 digraph_size, digraph_make](G)]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (skeep*) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((all_cycles const-decl "{cs: list[list[(cycle?(C))]] |
   length(cs) = size(C) AND
    FORALL (i: below(size(C))):
      FORALL (cycle: (cycle?(C))):
        member(cycle, nth(cs, i)) IFF car(cycle) = i}" c_digraph_all_cycles nil) (size const-decl "nat" c_digraphs_def nil) (cycle? const-decl "bool" c_digraph_all_cycles nil) (circuit? const-decl "bool" c_digraph_all_cycles nil) (walk? const-decl "bool" c_digraph_all_cycles nil) (VertList type-eq-decl nil digraphs_ nil) (vert_list const-decl "bool" digraphs_ nil) (vert type-eq-decl nil digraphs_ nil) (vert? const-decl "bool" digraphs_ nil) (digraph_make const-decl "[v: (is_finite[T]),
 {e: (is_finite[[T, T]]) |
    FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)} ->
   digraph]" digraphs_imp nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (digraph_size const-decl "[digraph -> nat]" digraphs_imp nil) (digraph_edges const-decl "[digraph -> [T, T -> bool]]" digraphs_imp nil) (digraph_verts const-decl "[digraph -> [T -> bool]]" digraphs_imp nil) (digraph_type type-eq-decl nil digraphs_imp nil) (cdigraph_eq type-eq-decl nil c_digraphs_digraphs nil) (eq const-decl "bool" c_digraphs_digraphs nil) (digraph type-eq-decl nil digraph_def nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (cdigraph const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (eq_same_size formula-decl nil c_digraphs_digraphs nil) (size const-decl "nat" digraph_def nil) (CyclesAt type-eq-decl nil cycles_ nil) (VertCycles type-eq-decl nil cycles_ nil)) nil (cac2dac subtype "digraphs_all_cycles.cac2dac_rec(digraphs_all_cycles.G, digraphs_all_cycles.vl, digraphs_all_cycles.C)(0, c_digraph_all_cycles[digraphs_all_cycles.T].all_cycles(digraphs_all_cycles.C))" "VCList[digraphs_all_cycles.T, digraph_type[T], digraphs_imp[digraphs_all_cycles.T].digraph_verts, digraphs_imp[digraphs_all_cycles.T].digraph_edges, digraphs_imp[digraphs_all_cycles.T].digraph_size, digraphs_imp[digraphs_all_cycles.T].digraph_make](digraphs_all_cycles.G, digraphs_all_cycles.vl)"))) (digraph_all_cycles_TCC1 0 (digraph_all_cycles_TCC1-1 nil 3659368121 ("" (skeep) (("" (use "vertsl?_is_vertlist") (("" (flatten) nil nil)) nil)) nil) ((vertsl?_is_vertlist judgement-tcc nil digraphs_all_cycles nil) (vertsl const-decl "(vertsl?(G))" c_digraphs_digraphs nil) (vertsl? const-decl "bool" c_digraphs_digraphs nil) (list type-decl nil list_adt nil) (digraph type-eq-decl nil digraph_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (predigraph type-eq-decl nil digraph_def nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil digraphs_all_cycles nil)) nil (digraph_all_cycles subtype "c_digraphs_digraphs[digraphs_all_cycles.T].vertsl(digraphs_all_cycles.G)" "list[vert[T, digraph_type[T], digraph_verts[T], digraph_edges[T], digraph_size[T], digraph_make[T]](G)]"))))
