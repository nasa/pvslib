(c_digraphs_def (loi_append 0 (loi_append-1 nil 3656092044 ("" (skeep) (("" (expand "list_of_idxs") (("" (skeep :preds? t) (("" (use "nth_append[nat]") (("" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (inst?) nil nil)) nil) ("2" (flatten) (("2" (inst -3 "i-length(l1)") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "length_append[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list_of_idxs const-decl "bool" c_digraphs_def nil) (nth_append formula-decl nil more_list_props structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (append def-decl "list[T]" list_props nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (length_append formula-decl nil list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (i skolem-const-decl "below(length(append(l1, l2)))" c_digraphs_def nil) (l2 skolem-const-decl "list[nat]" c_digraphs_def nil) (l1 skolem-const-decl "list[nat]" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (loi_permutation 0 (loi_permutation-1 nil 3656092299 ("" (skeep) (("" (expand "list_of_idxs") (("" (skeep) (("" (typepred "l2") (("" (hide -1) (("" (expand "permutation_list") (("" (expand "permutation?") (("" (flatten) (("" (expand "includes?") (("" (inst -1 "nth(l2, i)") (("" (case "count(nth(l2, i))(l2)>0") (("1" (case "member(nth(l2, i), l1)") (("1" (use "member_nth[nat]") (("1" (assert) (("1" (skeep -1) (("1" (inst -6 "i_1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 -1 -2)) (("2" (use "count_member[nat]") (("2" (assert) (("2" (lemma "count_member[nat]") (("2" (inst? -1 :where 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "count_nth[nat]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list_of_idxs const-decl "bool" c_digraphs_def nil) (permutation_list const-decl "bool" permutations_list structures) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (count_nth formula-decl nil permutations_list structures) (member def-decl "bool" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member_nth formula-decl nil more_list_props structures) (count_member formula-decl nil permutations_list structures) (count def-decl "nat" permutations_list structures) (> const-decl "bool" reals nil) (includes? const-decl "bool" permutations_list structures) (permutation? const-decl "bool" permutations_list structures)) shostak)) (sem_eq_TCC1 0 (sem_eq_TCC1-1 nil 3656438703 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (includes? const-decl "bool" permutations_list structures) (permutation? const-decl "bool" permutations_list structures)) nil (sem_eq subtype "c_digraphs_def.i" "below[length[list[nat]](adjs(cd1))]"))) (sem_eq_TCC2 0 (sem_eq_TCC2-1 nil 3656438703 ("" (skeep*) (("" (use "count_member[T]") (("" (assert) (("" (hide 2) (("" (expand "permutation?") (("" (flatten) (("" (expand "includes?" -2) (("" (inst -2 "nth[T](data(cd1), i)") (("" (lemma "count_nth[T]") (("" (inst -1 "data(cd1)" "i") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil c_digraphs_def nil) (count_member formula-decl nil permutations_list structures) (below type-eq-decl nil naturalnumbers nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (count_nth formula-decl nil permutations_list structures) (includes? const-decl "bool" permutations_list structures) (permutation? const-decl "bool" permutations_list structures) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (sem_eq subtype "list_props[c_digraphs_def.T].nth(data(c_digraphs_def.cd1), c_digraphs_def.i)" "{a: c_digraphs_def.T | list_props[c_digraphs_def.T].member(a, data(c_digraphs_def.cd2))}"))) (sem_eq_TCC3 0 (sem_eq_TCC3-1 nil 3656438703 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (includes? const-decl "bool" permutations_list structures) (permutation? const-decl "bool" permutations_list structures)) nil (sem_eq subtype "more_list_props[c_digraphs_def.T].idx(data(c_digraphs_def.cd2), list_props[c_digraphs_def.T].nth(data(c_digraphs_def.cd1), c_digraphs_def.i))" "below[length[list[nat]](adjs(cd2))]"))) (sem_eq_TCC4 0 (sem_eq_TCC4-1 nil 3656501990 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (includes? const-decl "bool" permutations_list structures) (permutation? const-decl "bool" permutations_list structures)) nil (sem_eq subtype "c_digraphs_def.adjs_i_cd1" "{idxs: list_adt[nat].list | FORALL (i: naturalnumbers.below(list_props[nat].length(idxs))): reals.<(list_props[nat].nth(idxs, i), list_props[c_digraphs_def.T].length(data(c_digraphs_def.cd1)))}"))) (sem_eq_TCC5 0 (sem_eq_TCC5-1 nil 3656501990 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (member def-decl "bool" list_props nil) (i!1 skolem-const-decl "below(length[T](data(cd1!1)))" c_digraphs_def nil) (cd1!1 skolem-const-decl "c_digraph" c_digraphs_def nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (i!2 skolem-const-decl "below(length(adjs_i_cd2!1))" c_digraphs_def nil) (adjs_i_cd2!1 skolem-const-decl "list[nat]" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (includes? const-decl "bool" permutations_list structures) (permutation? const-decl "bool" permutations_list structures)) nil (sem_eq subtype "c_digraphs_def.adjs_i_cd2" "{idxs: list_adt[nat].list | FORALL (i: naturalnumbers.below(list_props[nat].length(idxs))): reals.<(list_props[nat].nth(idxs, i), list_props[c_digraphs_def.T].length(data(c_digraphs_def.cd2)))}"))) (node_TCC1 0 (node_TCC1-1 nil 3657036105 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (< const-decl "bool" reals nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (list_of_idxs const-decl "bool" c_digraphs_def nil)) nil (node subtype "c_digraphs_def.i" "below[length[T](data(cd))]"))) (node_TCC2 0 (node_TCC2-2 nil 3657036151 ("" (skeep) (("" (use "nth_member[T]") nil nil)) nil) ((list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (size const-decl "nat" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (nth_member formula-decl nil more_list_props structures) (T formal-type-decl nil c_digraphs_def nil)) nil (node subtype "list_props[c_digraphs_def.T].nth(data(c_digraphs_def.cd), c_digraphs_def.i)" "{v: c_digraphs_def.T | list_props[c_digraphs_def.T].member(v, data(c_digraphs_def.cd))}")) (node_TCC2-1 nil 3657036105 ("" (subtype-tcc) nil nil) nil nil (node subtype "list_props[c_digraphs_def.T].nth(data(c_digraphs_def.cd), c_digraphs_def.i)" "{v: c_digraphs_def.T | list_props[c_digraphs_def.T].member(v, data(c_digraphs_def.cd))}"))) (vert_finite 0 (vert_finite-1 nil 3657037028 ("" (skeep) (("" (typepred "list2set(data(cd))") (("" (replace -2 -1 :hide? t) (("" (grind) nil nil)) nil)) nil)) nil) ((c_digraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}" set_as_list structures) (member def-decl "bool" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (finite_set type-eq-decl nil finite_sets nil) (list type-decl nil list_adt nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil c_digraphs_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (vert const-decl "bool" c_digraphs_def nil) (injective? const-decl "bool" functions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil)) shostak)) (edges_TCC1 0 (edges_TCC1-1 nil 3657036637 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (vert const-decl "bool" c_digraphs_def nil)) nil (edges subtype "c_digraphs_def.y" "{a: c_digraphs_def.T | list_props[c_digraphs_def.T].member(a, data(c_digraphs_def.cd))}"))) (edges_TCC2 0 (edges_TCC2-1 nil 3657036637 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (vert const-decl "bool" c_digraphs_def nil)) nil (edges subtype "c_digraphs_def.x" "{a: c_digraphs_def.T | list_props[c_digraphs_def.T].member(a, data(c_digraphs_def.cd))}"))) (edges_TCC3 0 (edges_TCC3-1 nil 3657036637 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (vert const-decl "bool" c_digraphs_def nil)) nil (edges subtype "more_list_props[c_digraphs_def.T].idx(data(c_digraphs_def.cd), c_digraphs_def.x)" "below[length[list[nat]](adjs(cd))]"))) (edges_finite 0 (edges_finite-1 nil 3657044638 ("" (skeep) (("" (expand "edges") (("" (expand "vert") (("" (case "subset?(LAMBDA (x, y: T):
                         member(x, data(cd)) AND
                          member(y, data(cd)) AND
                           member(idx(data(cd), y),
                                  nth(adjs(cd), idx(data(cd), x))), LAMBDA(x,y:T): member(x,data(cd)) AND
                          member(y, data(cd)))") (("1" (use "finite_subset[[T,T]]") (("1" (assert) nil nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (typepred "idx[T](data(cd), x)") (("2" (assert) (("2" (typepred "cd") (("2" (expand "cdigraph") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (case "is_finite_type[[(set_as_list.list2set(data(cd))),(set_as_list.list2set(data(cd)))]]") (("1" (expand "is_finite_type") (("1" (expand "is_finite") (("1" (skeep) (("1" (inst 1 "N" "LAMBDA(z: (LAMBDA (x, y: T):
                    member[T](x, data(cd)) AND member[T](y, data(cd)))): g(z)") (("1" (expand "injective?") (("1" (skeep) (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "list2set(data(cd))") (("2" (replace -2 :hide? t) (("2" (typepred "z") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "is_finite_cross[(set_as_list.list2set(data(cd))),(set_as_list.list2set(data(cd)))]") (("2" (assert) (("2" (hide 2) (("2" (case "is_finite_type[(set_as_list.list2set(data(cd)))]") (("1" (assert) nil nil) ("2" (hide 2) (("2" (typepred "list2set(data(cd))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "subset?") (("2" (skeep) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (typepred "idx[T](data(cd), x)") (("3" (assert) (("3" (typepred "cd") (("3" (expand "cdigraph") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((edges const-decl "bool" c_digraphs_def nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (member def-decl "bool" list_props nil) (list type-decl nil list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil c_digraphs_def nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (is_finite_cross formula-decl nil finite_cross finite_sets) (injective? const-decl "bool" functions nil) (is_finite_type const-decl "bool" finite_sets nil) (list2set def-decl "{s: finite_set[T] | s = {x | member(x, l)}}" set_as_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (is_finite const-decl "bool" finite_sets nil) (cd skolem-const-decl "c_digraph" c_digraphs_def nil) (finite_set type-eq-decl nil finite_sets nil) (finite_subset formula-decl nil finite_sets nil) (member const-decl "bool" sets nil) (vert const-decl "bool" c_digraphs_def nil)) shostak)) (edges_list_vert_adjs_TCC1 0 (edges_list_vert_adjs_TCC1-1 nil 3658517076 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (vert const-decl "bool" c_digraphs_def nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil)) nil (edges_list_vert_adjs subtype "c_digraphs_def.v" "{a: c_digraphs_def.T | list_props[c_digraphs_def.T].member(a, data(c_digraphs_def.cd))}"))) (edges_list_vert_adjs_TCC2 0 (edges_list_vert_adjs_TCC2-1 nil 3658517076 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (vert const-decl "bool" c_digraphs_def nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (edges_list_vert_adjs subtype "more_list_props[c_digraphs_def.T].idx(data(c_digraphs_def.cd), c_digraphs_def.v)" "below[length[list[nat]](adjs(cd))]"))) (edges_list_vert_adjs_TCC3 0 (edges_list_vert_adjs_TCC3-1 nil 3658517076 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (vert const-decl "bool" c_digraphs_def nil)) nil (edges_list_vert_adjs subtype "c_digraphs_def.w" "{a: c_digraphs_def.T | list_props[c_digraphs_def.T].member(a, data(c_digraphs_def.cd))}"))) (edges_list_vert_adjs_TCC4 0 (edges_list_vert_adjs_TCC6-2 "" 3744347238 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (suffix? def-decl "bool" more_list_props structures) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (edges const-decl "bool" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member def-decl "bool" list_props nil) (vert const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures)) shostak (edges_list_vert_adjs subtype "list_adt[(c_digraphs_def.edges(c_digraphs_def.cd))].null" "{l: list_adt[(c_digraphs_def.edges(c_digraphs_def.cd))].list | booleans.AND(FORALL (v_, w: c_digraphs_def.T): booleans.IFF(list_props[[c_digraphs_def.T, c_digraphs_def.T]].member((v_, w), l), booleans.AND(c_digraphs_def.v = v_, booleans.AND(c_digraphs_def.vert(c_digraphs_def.cd)(w), list_props[nat].member(more_list_props[c_digraphs_def.T].idx(data(c_digraphs_def.cd), w), c_digraphs_def.adjs_v)))), more_list_props[[c_digraphs_def.T, c_digraphs_def.T]].no_repetitions?(l))}")) (edges_list_vert_adjs_TCC6-1 nil 3658569750 ("" (skeep) (("" (expand "edges") (("" (split 1) (("1" (expand "vert") (("1" (use "nth_member[T]") nil nil)) nil) ("2" (case "idx(data(cd), nth[T](data(cd), a)) = a") (("1" (replace -1 :hide? t) (("1" (typepred "adjs_v") (("1" (hide -1) (("1" (replace -2 :hide? t) (("1" (use "suffix_member[nat]") (("1" (assert) (("1" (inst -1 "a") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "idx_nth_no_rep[T]") (("2" (typepred "cd") (("2" (expand "cdigraph") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((suffix? def-decl "bool" more_list_props structures) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures)) nil (edges_list_vert_adjs subtype "list_adt[(c_digraphs_def.edges(c_digraphs_def.cd))].null" "{l: list_adt[(c_digraphs_def.edges(c_digraphs_def.cd))].list | booleans.AND(FORALL (v_, w: c_digraphs_def.T): booleans.IFF(list_props[[c_digraphs_def.T, c_digraphs_def.T]].member((v_, w), l), booleans.AND(c_digraphs_def.v = v_, booleans.AND(c_digraphs_def.vert(c_digraphs_def.cd)(w), list_props[nat].member(more_list_props[c_digraphs_def.T].idx(data(c_digraphs_def.cd), w), c_digraphs_def.adjs_v)))), more_list_props[[c_digraphs_def.T, c_digraphs_def.T]].no_repetitions?(l))}"))) (edges_list_vert_adjs_TCC5 0 (edges_list_vert_adjs_TCC7-2 "" 3744347311 ("" (skeep) (("" (typepred "adjs_v") (("" (hide -1) (("" (typepred "cd") (("" (expand "cdigraph") (("" (flatten) (("" (inst -2 "idx(data(cd),v)") (("" (hide-all-but (-2 -5 -6 1)) (("" (expand "list_of_idxs") (("" (replace -3 :hide? t) (("" (use "suffix_member[nat]") (("" (assert) (("" (inst -1 "a") (("" (expand "member" -1 1) (("" (use "member_nth[nat]") (("" (assert) (("" (skeep -1) (("" (inst -3 "i") (("" (assert) (("" (expand "size") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((vert const-decl "bool" c_digraphs_def nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (member def-decl "bool" list_props nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraphs_def nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (suffix? def-decl "bool" more_list_props structures) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (size const-decl "nat" c_digraphs_def nil) (member_nth formula-decl nil more_list_props structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (suffix_member formula-decl nil more_list_props structures) (list_of_idxs const-decl "bool" c_digraphs_def nil)) shostak (edges_list_vert_adjs subtype "c_digraphs_def.a" "below[length[T](data(cd))]")) (edges_list_vert_adjs_TCC7-1 nil 3658569750 ("" (skeep) (("" (typepred "adjs_v") (("" (hide -1) (("" (replace -2 :hide? t) (("" (use "suffix_end[nat]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (member_nth formula-decl nil more_list_props structures) (suffix_member formula-decl nil more_list_props structures)) nil (edges_list_vert_adjs subtype "c_digraphs_def.a" "below[length[T](data(cd))]"))) (edges_list_vert_adjs_TCC6 0 (edges_list_vert_adjs_TCC8-1 nil 3658569750 ("" (skeep) (("" (expand "edges") (("" (split 1) (("1" (expand "vert") (("1" (use "nth_member[T]") nil nil)) nil) ("2" (case "idx(data(cd), nth[T](data(cd), a)) = a") (("1" (replace -1 :hide? t) (("1" (typepred "adjs_v") (("1" (hide -1) (("1" (replace -2 :hide? t) (("1" (use "suffix_member[nat]") (("1" (assert) (("1" (inst -1 "a") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "idx_nth_no_rep[T]") (("2" (typepred "cd") (("2" (expand "cdigraph") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((edges const-decl "bool" c_digraphs_def nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (member def-decl "bool" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (suffix? def-decl "bool" more_list_props structures) (NOT const-decl "[bool -> bool]" booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (suffix_member formula-decl nil more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (cd skolem-const-decl "c_digraph" c_digraphs_def nil) (idx_nth_no_rep formula-decl nil more_list_props structures) (vert const-decl "bool" c_digraphs_def nil) (T formal-type-decl nil c_digraphs_def nil) (nth_member formula-decl nil more_list_props structures) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil)) nil (edges_list_vert_adjs subtype "(c_digraphs_def.v, list_props[c_digraphs_def.T].nth(data(c_digraphs_def.cd), c_digraphs_def.a))" "(c_digraphs_def.edges(c_digraphs_def.cd))"))) (edges_list_vert_adjs_TCC7 0 (edges_list_vert_adjs_TCC9-2 "" 3744347392 ("" (skeep) (("" (typepred "adjs_v") (("" (hide -1) (("" (replace -2 :hide? t) (("" (use "suffix_end[nat]") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((vert const-decl "bool" c_digraphs_def nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (member def-decl "bool" list_props nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraphs_def nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (suffix? def-decl "bool" more_list_props structures) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (suffix_end formula-decl nil more_list_props structures)) shostak (edges_list_vert_adjs subtype "c_digraphs_def.adjs" "{adjs_v: list_adt[nat].list | more_list_props[nat].suffix?(adjs_v, list_props[list[nat]].nth(adjs(c_digraphs_def.cd), more_list_props[c_digraphs_def.T].idx(data(c_digraphs_def.cd), c_digraphs_def.v)))}")) (edges_list_vert_adjs_TCC9-1 nil 3658570630 ("" (skeep) (("" (split 1) (("1" (skeep) (("1" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (case "v_ = v AND w = nth[T](data(cd), a)") (("1" (hide -2) (("1" (flatten) (("1" (assert) (("1" (split 1) (("1" (expand "vert") (("1" (replace -2) (("1" (use "nth_member[T]") nil nil)) nil)) nil) ("2" (replace -3 :hide? t) (("2" (expand "member" 1) (("2" (flatten) (("2" (replace -2 :hide? t) (("2" (use "idx_nth_no_rep[T]") (("2" (typepred "cd") (("2" (expand "cdigraph") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -1) (("1" (propax) nil nil) ("2" (typepred "v1(cd,v)(adjs)") (("2" (inst? -2 :where -4) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (replace -7 :hide? t) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (hide-all-but (1 -3)) (("3" (typepred "adjs_v") (("3" (hide -1) (("3" (typepred "cd") (("3" (expand "cdigraph") (("3" (flatten) (("3" (hide-all-but (-2 -5 -6 1)) (("3" (inst? -1 :where -2) (("3" (expand "list_of_idxs") (("3" (replace -3 :hide? t) (("3" (use "suffix_member[nat]") (("3" (assert) (("3" (inst -1 "a") (("3" (expand "member" -1 1) (("3" (use "member_nth[nat]") (("3" (assert) (("3" (skeep -1) (("3" (inst? -3 :where -1) (("3" (replace -1 :hide? t) (("3" (expand "size") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" 1) (("2" (flatten) (("2" (assert) (("2" (replace -4 :hide? t) (("2" (expand "member" -3) (("2" (typepred "v1(cd,v)(adjs)") (("2" (hide -1) (("2" (inst? -1 :where 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "no_repetitions_append[[T,T]]") (("2" (inst -1 "(: (v, nth[T](data(cd), a)) :)" "v1(cd, v)(adjs)") (("2" (expand "append" -1) (("2" (expand "append" -1) (("2" (assert) (("2" (hide 2) (("2" (split 1) (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "member" -1) (("2" (expand "member" -1) (("2" (replace -1 :hide? t) (("2" (typepred "v1(cd,v)(adjs)") (("2" (hide -1) (("2" (inst? -1 :where -2) (("2" (inst? -1 :where -3) (("2" (assert) (("2" (flatten) (("2" (case "idx(data(cd), nth[T](data(cd), a)) = a") (("1" (replace -1 :hide? t) (("1" (hide-all-but (-5 -2)) (("1" (use "no_rep_cdr[nat]") (("1" (assert) (("1" (typepred "adjs_v") (("1" (hide -1) (("1" (replace -3 :hide? t) (("1" (hide -2) (("1" (use "no_rep_suffix[nat]") (("1" (assert) (("1" (hide 2) (("1" (typepred "cd") (("1" (expand "cdigraph") (("1" (flatten) (("1" (inst? -4 :where 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "idx_nth_no_rep[T]") (("2" (typepred "cd") (("2" (expand "cdigraph") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (suffix_end formula-decl nil more_list_props structures)) nil (edges_list_vert_adjs subtype "c_digraphs_def.adjs" "{adjs_v: list_adt[nat].list | more_list_props[nat].suffix?(adjs_v, list_props[list[nat]].nth(adjs(c_digraphs_def.cd), more_list_props[c_digraphs_def.T].idx(data(c_digraphs_def.cd), c_digraphs_def.v)))}"))) (edges_list_vert_adjs_TCC8 0 (edges_list_vert_adjs_TCC10-1 nil 3744308774 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (vert const-decl "bool" c_digraphs_def nil) (suffix? def-decl "bool" more_list_props structures) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (member def-decl "bool" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil)) nil (edges_list_vert_adjs termination "c_digraphs_def.edges_list_vert_adjs(c_digraphs_def.cd, c_digraphs_def.v)(c_digraphs_def.adjs)" "nil"))) (edges_list_vert_adjs_TCC9 0 (edges_list_vert_adjs_TCC11-1 nil 3744308774 ("" (skeep) (("" (split 1) (("1" (skeep) (("1" (split 1) (("1" (flatten) (("1" (expand "member" -1) (("1" (case "v_ = v AND w = nth[T](data(cd), a)") (("1" (hide -2) (("1" (flatten) (("1" (assert) (("1" (split 1) (("1" (expand "vert") (("1" (replace -2) (("1" (use "nth_member[T]") nil nil)) nil)) nil) ("2" (replace -3 :hide? t) (("2" (expand "member" 1) (("2" (flatten) (("2" (replace -2 :hide? t) (("2" (use "idx_nth_no_rep[T]") (("2" (typepred "cd") (("2" (expand "cdigraph") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -1) (("1" (propax) nil nil) ("2" (typepred "v1(cd,v)(adjs)") (("2" (inst? -2 :where -4) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (replace -7 :hide? t) (("2" (expand "member" 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (flatten) (("3" (hide-all-but (1 -3)) (("3" (typepred "adjs_v") (("3" (hide -1) (("3" (typepred "cd") (("3" (expand "cdigraph") (("3" (flatten) (("3" (hide-all-but (-2 -5 -6 1)) (("3" (inst? -1 :where -2) (("3" (expand "list_of_idxs") (("3" (replace -3 :hide? t) (("3" (use "suffix_member[nat]") (("3" (assert) (("3" (inst -1 "a") (("3" (expand "member" -1 1) (("3" (use "member_nth[nat]") (("3" (assert) (("3" (skeep -1) (("3" (inst? -3 :where -1) (("3" (replace -1 :hide? t) (("3" (expand "size") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "member" 1) (("2" (flatten) (("2" (assert) (("2" (replace -4 :hide? t) (("2" (expand "member" -3) (("2" (typepred "v1(cd,v)(adjs)") (("2" (hide -1) (("2" (inst? -1 :where 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "no_repetitions_append[[T,T]]") (("2" (inst -1 "(: (v, nth[T](data(cd), a)) :)" "v1(cd, v)(adjs)") (("2" (expand "append" -1) (("2" (expand "append" -1) (("2" (assert) (("2" (hide 2) (("2" (split 1) (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "member" -1) (("2" (expand "member" -1) (("2" (replace -1 :hide? t) (("2" (typepred "v1(cd,v)(adjs)") (("2" (hide -1) (("2" (inst? -1 :where -2) (("2" (inst? -1 :where -3) (("2" (assert) (("2" (flatten) (("2" (case "idx(data(cd), nth[T](data(cd), a)) = a") (("1" (replace -1 :hide? t) (("1" (hide-all-but (-5 -2)) (("1" (use "no_rep_cdr[nat]") (("1" (assert) (("1" (typepred "adjs_v") (("1" (hide -1) (("1" (replace -3 :hide? t) (("1" (hide -2) (("1" (use "no_rep_suffix[nat]") (("1" (assert) (("1" (hide 2) (("1" (typepred "cd") (("1" (expand "cdigraph") (("1" (flatten) (("1" (inst? -4 :where 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "idx_nth_no_rep[T]") (("2" (typepred "cd") (("2" (expand "cdigraph") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil) (size const-decl "nat" c_digraphs_def nil) (member_nth formula-decl nil more_list_props structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (suffix_member formula-decl nil more_list_props structures) (list_of_idxs const-decl "bool" c_digraphs_def nil) (edges const-decl "bool" c_digraphs_def nil) (suffix? def-decl "bool" more_list_props structures) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (IFF const-decl "[bool, bool -> bool]" booleans nil) (idx_nth_no_rep formula-decl nil more_list_props structures) (cd skolem-const-decl "c_digraph" c_digraphs_def nil) (no_repetitions? const-decl "bool" more_list_props structures) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (nth_member formula-decl nil more_list_props structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil c_digraphs_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (vert const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (no_rep_suffix formula-decl nil more_list_props structures) (no_rep_cdr formula-decl nil more_list_props structures) (/= const-decl "boolean" notequal nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (append def-decl "list[T]" list_props nil) (no_repetitions_append formula-decl nil more_list_props structures)) nil (edges_list_vert_adjs subtype "list_adt[(c_digraphs_def.edges(c_digraphs_def.cd))].cons((c_digraphs_def.v, list_props[c_digraphs_def.T].nth(data(c_digraphs_def.cd), c_digraphs_def.a)), c_digraphs_def.edges_list_vert_adjs(c_digraphs_def.cd, c_digraphs_def.v)(c_digraphs_def.adjs))" "{l: list_adt[(c_digraphs_def.edges(c_digraphs_def.cd))].list | booleans.AND(FORALL (v_, w: c_digraphs_def.T): booleans.IFF(list_props[[c_digraphs_def.T, c_digraphs_def.T]].member((v_, w), l), booleans.AND(c_digraphs_def.v = v_, booleans.AND(c_digraphs_def.vert(c_digraphs_def.cd)(w), list_props[nat].member(more_list_props[c_digraphs_def.T].idx(data(c_digraphs_def.cd), w), c_digraphs_def.adjs_v)))), more_list_props[[c_digraphs_def.T, c_digraphs_def.T]].no_repetitions?(l))}"))) (edges_list_vert_TCC1 0 (edges_list_vert_TCC1-1 nil 3658515036 ("" (skeep) (("" (use "suffix_reflexive[nat]") nil nil)) nil) ((vert const-decl "bool" c_digraphs_def nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (member def-decl "bool" list_props nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (T formal-type-decl nil c_digraphs_def nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (suffix_reflexive formula-decl nil more_list_props structures) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) nil (edges_list_vert subtype "list_props[list[nat]].nth(adjs(c_digraphs_def.cd), more_list_props[c_digraphs_def.T].idx(data(c_digraphs_def.cd), c_digraphs_def.v))" "{adjs_v: list_adt[nat].list | more_list_props[nat].suffix?(adjs_v, list_props[list[nat]].nth(adjs(c_digraphs_def.cd), more_list_props[c_digraphs_def.T].idx(data(c_digraphs_def.cd), c_digraphs_def.v)))}"))) (edges_list_vert_TCC2 0 (edges_list_vert_TCC2-2 "" 3790101775 ("" (skeep) (("" (typepred "edges_list_vert_adjs(cd, v)
                                (nth[list[nat]]
                                     (adjs(cd), idx[T](data(cd), v)))") (("1" (assert) nil nil) ("2" (use "suffix_reflexive[nat]") nil nil) ("3" (typepred "idx(data(cd),v)") (("3" (typepred "cd") (("3" (expand "cdigraph") (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (typepred "v") (("4" (assert) (("4" (expand "vert") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((edges_list_vert_adjs def-decl "{l: list[(edges(cd))] |
   (FORALL (v_, w: T):
      member((v_, w), l) IFF
       v = v_ AND vert(cd)(w) AND member(idx(data(cd), w), adjs_v))
    AND no_repetitions?[[T, T]](l)}" c_digraphs_def nil) (no_repetitions? const-decl "bool" more_list_props structures) (IFF const-decl "[bool, bool -> bool]" booleans nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (member def-decl "bool" list_props nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (suffix? def-decl "bool" more_list_props structures) (vert const-decl "bool" c_digraphs_def nil) (edges const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (T formal-type-decl nil c_digraphs_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (suffix_reflexive formula-decl nil more_list_props structures)) shostak (edges_list_vert subtype "c_digraphs_def.edges_list_vert_adjs(c_digraphs_def.cd, c_digraphs_def.v)(list_props[list[nat]].nth(adjs(c_digraphs_def.cd), more_list_props[c_digraphs_def.T].idx(data(c_digraphs_def.cd), c_digraphs_def.v)))" "{l: list_adt[(c_digraphs_def.edges(c_digraphs_def.cd))].list | booleans.AND(FORALL (v_, w: c_digraphs_def.T): booleans.IFF(list_props[[c_digraphs_def.T, c_digraphs_def.T]].member((v_, w), l), booleans.AND(c_digraphs_def.v = v_, c_digraphs_def.edges(c_digraphs_def.cd)(c_digraphs_def.v, w))), more_list_props[[c_digraphs_def.T, c_digraphs_def.T]].no_repetitions?(l))}")) (edges_list_vert_TCC2-1 nil 3658517076 ("" (skeep) (("" (typepred "edges_list_vert_adjs(cd, v)
                                (nth[list[nat]]
                                     (adjs(cd), idx[T](data(cd), v)))") (("1" (assert) (("1" (skeep) (("1" (inst -2 "v_" "w") (("1" (split 1) (("1" (flatten 1) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (use "member_nth[[T,T]]") (("1" (assert) (("1" (skeep) (("1" (hide -2) (("1" (use "every_nth[[T,T]]") (("1" (assert) (("1" (inst -1 "i") (("1" (flatten) (("1" (replace -4 :hide? t) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "suffix_reflexive[nat]") nil nil) ("3" (typepred "idx(data(cd),v)") (("3" (typepred "cd") (("3" (expand "cdigraph") (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (typepred "v") (("4" (assert) (("4" (expand "vert") (("4" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((no_repetitions? const-decl "bool" more_list_props structures) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (suffix_reflexive formula-decl nil more_list_props structures)) nil (edges_list_vert subtype "c_digraphs_def.edges_list_vert_adjs(c_digraphs_def.cd, c_digraphs_def.v)(list_props[list[nat]].nth(adjs(c_digraphs_def.cd), more_list_props[c_digraphs_def.T].idx(data(c_digraphs_def.cd), c_digraphs_def.v)))" "{l: list_adt[(c_digraphs_def.edges(c_digraphs_def.cd))].list | booleans.AND(FORALL (v_, w: c_digraphs_def.T): booleans.IFF(list_props[[c_digraphs_def.T, c_digraphs_def.T]].member((v_, w), l), booleans.AND(c_digraphs_def.v = v_, c_digraphs_def.edges(c_digraphs_def.cd)(c_digraphs_def.v, w))), more_list_props[[c_digraphs_def.T, c_digraphs_def.T]].no_repetitions?(l))}"))) (edges_list_verts_TCC1 0 (edges_list_verts_TCC1-1 nil 3658511063 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (below type-eq-decl nil naturalnumbers nil) (cd!1 skolem-const-decl "c_digraph" c_digraphs_def nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (member def-decl "bool" list_props nil) (vert const-decl "bool" c_digraphs_def nil) (edges const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures)) nil (edges_list_verts subtype "list_adt[(c_digraphs_def.edges(c_digraphs_def.cd))].null" "{l: list_adt[(c_digraphs_def.edges(c_digraphs_def.cd))].list | booleans.AND(FORALL (v, w: c_digraphs_def.T): booleans.IFF(list_props[[c_digraphs_def.T, c_digraphs_def.T]].member((v, w), l), booleans.AND(list_props[c_digraphs_def.T].member(v, c_digraphs_def.vs), c_digraphs_def.edges(c_digraphs_def.cd)(v, w))), more_list_props[[c_digraphs_def.T, c_digraphs_def.T]].no_repetitions?(l))}"))) (edges_list_verts_TCC2 0 (edges_list_verts_TCC2-1 nil 3658515036 ("" (skeep) (("" (use "no_rep_cdr[T]") (("" (assert) nil nil)) nil)) nil) ((no_rep_cdr formula-decl nil more_list_props structures) (T formal-type-decl nil c_digraphs_def nil) (vert const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil)) nil (edges_list_verts subtype "c_digraphs_def.ws" "{vs: list_adt[(c_digraphs_def.vert(c_digraphs_def.cd))].list | more_list_props[c_digraphs_def.T].no_repetitions?(vs)}"))) (edges_list_verts_TCC3 0 (edges_list_verts_TCC3-1 nil 3658515123 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (vert const-decl "bool" c_digraphs_def nil) (no_repetitions? const-decl "bool" more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (/= const-decl "boolean" notequal nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil)) nil (edges_list_verts termination "c_digraphs_def.edges_list_verts(c_digraphs_def.cd)(c_digraphs_def.ws)" "nil"))) (edges_list_verts_TCC4 0 (edges_list_verts_TCC4-1 nil 3658515123 ("" (skeep) (("" (split 1) (("1" (use "every_append[[T,T]]") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (typepred "edges_list_vert(cd)(w)") (("1" (propax) nil nil)) nil) ("2" (typepred "v1(cd)(ws)") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (split 1) (("1" (flatten) (("1" (lemma "member_append_fi[[T,T]]") (("1" (inst -1 "(v,w_1)" "edges_list_vert(cd)(w)" "v1(cd)(ws)") (("1" (split -1) (("1" (hide -2) (("1" (typepred "edges_list_vert(cd)(w)") (("1" (inst? -2 :where -4) (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (replace -2) (("1" (replace -7) (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (typepred "v1(cd)(ws)") (("2" (inst? -2 :where -4) (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (replace -8 :hide? t) (("2" (expand "member" 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (replace -3 :hide? t) (("2" (expand "member" -1) (("2" (case "v=w") (("1" (hide -2) (("1" (replace -1 :hide? t) (("1" (typepred "edges_list_vert(cd)(w)") (("1" (inst -2 "w" "w_1") (("1" (flatten) (("1" (hide -2) (("1" (split -2) (("1" (use "member_append_l[[T,T]]") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split -1) (("1" (propax) nil nil) ("2" (typepred "v1(cd)(ws)") (("2" (inst -2 "v" "w_1") (("2" (flatten) (("2" (hide -2) (("2" (split -2) (("1" (use "member_append_r[[T,T]]") (("1" (assert) nil nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "no_repetitions_append[[T,T]]") (("3" (assert) (("3" (hide 2) (("3" (skeep) (("3" (typepred "edges_list_vert(cd)(w)") (("3" (case "n=(n`1,n`2)") (("1" (replace -1 :hide? t) (("1" (inst? -2 :where -4) (("1" (flatten) (("1" (hide -3) (("1" (split -2) (("1" (flatten) (("1" (typepred "v1(cd)(ws)") (("1" (inst? -2 :where -9) (("1" (flatten) (("1" (hide -3) (("1" (split -2) (("1" (flatten) (("1" (typepred "vs") (("1" (hide-all-but (-2 -3 -13 -7)) (("1" (replace -4 :hide? t) (("1" (replace -3 :hide? t :dir rl) (("1" (use "no_rep_cdr[T]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (edges const-decl "bool" c_digraphs_def nil) (vert const-decl "bool" c_digraphs_def nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (no_repetitions? const-decl "bool" more_list_props structures) (edges_list_vert const-decl "{l: list[(edges(cd))] |
   (FORALL (v_, w: T): member((v_, w), l) IFF v = v_ AND edges(cd)(v, w))
    AND no_repetitions?[[T, T]](l)}" c_digraphs_def nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (T formal-type-decl nil c_digraphs_def nil) (every_append formula-decl nil list_props nil) (member_append_fi formula-decl nil more_list_props structures) (member_append_l formula-decl nil more_list_props structures) (member_append_r formula-decl nil more_list_props structures) (no_rep_cdr formula-decl nil more_list_props structures) (no_repetitions_append formula-decl nil more_list_props structures)) nil (edges_list_verts subtype "list_props[[c_digraphs_def.T, c_digraphs_def.T]].append(c_digraphs_def.edges_list_vert(c_digraphs_def.cd)(c_digraphs_def.w), c_digraphs_def.edges_list_verts(c_digraphs_def.cd)(c_digraphs_def.ws))" "{l: list_adt[(c_digraphs_def.edges(c_digraphs_def.cd))].list | booleans.AND(FORALL (v, w: c_digraphs_def.T): booleans.IFF(list_props[[c_digraphs_def.T, c_digraphs_def.T]].member((v, w), l), booleans.AND(list_props[c_digraphs_def.T].member(v, c_digraphs_def.vs), c_digraphs_def.edges(c_digraphs_def.cd)(v, w))), more_list_props[[c_digraphs_def.T, c_digraphs_def.T]].no_repetitions?(l))}"))) (edges_list_TCC1 0 (edges_list_TCC1-1 nil 3658511063 ("" (assert) nil nil) ((edges_finite formula-decl nil c_digraphs_def nil)) nil (edges_list subtype "c_digraphs_def.edges(c_digraphs_def.cd)" "finite_set[[T, T]]"))) (edges_list_TCC2 0 (edges_list_TCC2-1 nil 3658511063 ("" (skeep) (("" (split 1) (("1" (expand "vert") (("1" (use "every_nth[T]") (("1" (assert) (("1" (hide 2) (("1" (skeep) (("1" (use "nth_member[T]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "cd") (("2" (expand "cdigraph") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil) ((every_nth formula-decl nil list_props nil) (T formal-type-decl nil c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (number nonempty-type-decl nil numbers nil) (member def-decl "bool" list_props nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (nth_member formula-decl nil more_list_props structures) (vert const-decl "bool" c_digraphs_def nil) (NOT const-decl "[bool -> bool]" booleans nil)) nil (edges_list subtype "data(c_digraphs_def.cd)" "{vs: list_adt[(c_digraphs_def.vert(c_digraphs_def.cd))].list | more_list_props[c_digraphs_def.T].no_repetitions?(vs)}"))) (edges_list_TCC3 0 (edges_list_TCC3-2 "" 3790101780 ("" (skeep) (("" (case "card[[T, T]](edges(cd)) =
       length[[T, T]](edges_list_verts(cd)(data(cd)))
       AND
       (FORALL (e: (edges(cd))):
          member[[T, T]](e, edges_list_verts(cd)(data(cd))))") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (split 1) (("1" (typepred "edges_list_verts(cd)(data(cd))") (("1" (use "eq_no_rep_same_size[[T,T]]") (("1" (split -1) (("1" (assert) nil nil) ("2" (propax) nil nil) ("3" (expand "set_list_eq") (("3" (skeep) (("3" (inst -2 "a`1" "a`2") (("3" (case "a=(a`1,a`2)") (("1" (replace -1) (("1" (ground) (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "e") (("2" (typepred "edges_list_verts(cd)(data(cd))") (("2" (inst -2 "e`1" "e`2") (("2" (case "e=(e`1,e`2)") (("1" (replace -1 :dir rl) (("1" (flatten) (("1" (hide -3) (("1" (split -3) (("1" (propax) nil nil) ("2" (expand "edges") (("2" (flatten) (("2" (expand "vert") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (flatten) (("3" (hide-all-but 1) (("3" (skeep) (("3" (split 1) (("1" (use "every_nth[T]") (("1" (assert) (("1" (hide 2) (("1" (expand "vert") (("1" (skeep) (("1" (use "nth_member[T]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "cd") (("2" (expand "cdigraph") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (typepred "cd") (("4" (expand "cdigraph") (("4" (flatten) (("4" (assert) (("4" (use "every_nth[T]") (("4" (assert) (("4" (hide 2) (("4" (skeep) (("4" (expand "vert") (("4" (use "nth_member[T]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((edges_list_verts def-decl "{l: list[(edges(cd))] |
   (FORALL (v, w: T):
      member((v, w), l) IFF member(v, vs) AND edges(cd)(v, w))
    AND no_repetitions?[[T, T]](l)}" c_digraphs_def nil) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (no_repetitions? const-decl "bool" more_list_props structures) (vert const-decl "bool" c_digraphs_def nil) (length def-decl "nat" list_props nil) (edges const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil c_digraphs_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (eq_no_rep_same_size formula-decl nil set_as_list_props structures) (set_list_eq const-decl "bool" set_as_list structures) (NOT const-decl "[bool -> bool]" booleans nil) (every_nth formula-decl nil list_props nil) (nth_member formula-decl nil more_list_props structures) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil)) shostak (edges_list subtype "c_digraphs_def.edges_list_verts(c_digraphs_def.cd)(data(c_digraphs_def.cd))" "{l: list_adt[(c_digraphs_def.edges(c_digraphs_def.cd))].list | booleans.AND(finite_sets[[c_digraphs_def.T, c_digraphs_def.T]].card(c_digraphs_def.edges(c_digraphs_def.cd)) = list_props[[c_digraphs_def.T, c_digraphs_def.T]].length(l), booleans.AND(FORALL (e: (c_digraphs_def.edges(c_digraphs_def.cd))): list_props[[c_digraphs_def.T, c_digraphs_def.T]].member(e, l), more_list_props[[c_digraphs_def.T, c_digraphs_def.T]].no_repetitions?(l)))}")) (edges_list_TCC3-1 nil 3658511063 ("" (skeep) (("" (case "card[[T, T]](edges(cd)) =
       length[[T, T]](edges_list_verts(cd)(data(cd)))
       AND
       (FORALL (e: (edges(cd))):
          member[[T, T]](e, edges_list_verts(cd)(data(cd))))") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (split 1) (("1" (typepred "edges_list_verts(cd)(data(cd))") (("1" (use "eq_no_rep_same_size[[T,T]]") (("1" (split -1) (("1" (assert) nil nil) ("2" (propax) nil nil) ("3" (expand "set_list_eq") (("3" (inst 1 "edges(cd)") (("3" (skeep) (("3" (inst -2 "a`1" "a`2") (("3" (case "a=(a`1,a`2)") (("1" (replace -1) (("1" (ground) (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "e") (("2" (typepred "edges_list_verts(cd)(data(cd))") (("2" (inst -2 "e`1" "e`2") (("2" (case "e=(e`1,e`2)") (("1" (replace -1 :dir rl) (("1" (flatten) (("1" (hide -3) (("1" (split -3) (("1" (propax) nil nil) ("2" (expand "edges") (("2" (flatten) (("2" (expand "vert") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (flatten) (("3" (hide-all-but 1) (("3" (skeep) (("3" (split 1) (("1" (use "every_nth[T]") (("1" (assert) (("1" (hide 2) (("1" (expand "vert") (("1" (skeep) (("1" (use "nth_member[T]") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "cd") (("2" (expand "cdigraph") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (typepred "cd") (("4" (expand "cdigraph") (("4" (flatten) (("4" (assert) (("4" (use "every_nth[T]") (("4" (assert) (("4" (hide 2) (("4" (skeep) (("4" (expand "vert") (("4" (use "nth_member[T]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((no_repetitions? const-decl "bool" more_list_props structures) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (eq_no_rep_same_size formula-decl nil set_as_list_props structures) (set_list_eq const-decl "bool" set_as_list structures) (nth_member formula-decl nil more_list_props structures)) nil (edges_list subtype "c_digraphs_def.edges_list_verts(c_digraphs_def.cd)(data(c_digraphs_def.cd))" "{l: list_adt[(c_digraphs_def.edges(c_digraphs_def.cd))].list | booleans.AND(finite_sets[[c_digraphs_def.T, c_digraphs_def.T]].card(c_digraphs_def.edges(c_digraphs_def.cd)) = list_props[[c_digraphs_def.T, c_digraphs_def.T]].length(l), booleans.AND(FORALL (e: (c_digraphs_def.edges(c_digraphs_def.cd))): list_props[[c_digraphs_def.T, c_digraphs_def.T]].member(e, l), more_list_props[[c_digraphs_def.T, c_digraphs_def.T]].no_repetitions?(l)))}"))) (edges_set_to_list_for_TCC1 0 (edges_set_to_list_for_TCC1-1 nil 3657038253 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil c_digraphs_def nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (list type-decl nil list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (subset? const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (injective? const-decl "bool" functions nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (vertsl!1 skolem-const-decl "{vertsl: (no_repetitions?[T]) |
   FORALL (x, y: T):
     edges_G!1(x, y) IMPLIES member(x, vertsl) AND member(y, vertsl)}" c_digraphs_def nil) (edges_G!1 skolem-const-decl "finite_set[[T, T]]" c_digraphs_def nil) (N!2 skolem-const-decl "nat" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (length def-decl "nat" list_props nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (below type-eq-decl nil naturalnumbers nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (member def-decl "bool" list_props nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures)) nil (edges_set_to_list_for subtype "list_adt[nat].null" "{adj_v: list_adt[nat].list | booleans.AND(FORALL (w: c_digraphs_def.T): booleans.IMPLIES(list_props[c_digraphs_def.T].member(w, c_digraphs_def.vertsl), (booleans.IFF(list_props[nat].member(more_list_props[c_digraphs_def.T].idx(c_digraphs_def.vertsl, w), adj_v), sets[[c_digraphs_def.T, c_digraphs_def.T]].member((c_digraphs_def.v, w), c_digraphs_def.E)))), booleans.AND(FORALL (i: naturalnumbers.below(list_props[nat].length(adj_v))): reals.<(list_props[nat].nth(adj_v, i), list_props[c_digraphs_def.T].length(c_digraphs_def.vertsl)), more_list_props[nat].no_repetitions?(adj_v)))}"))) (edges_set_to_list_for_TCC2 0 (edges_set_to_list_for_TCC2-2 "" 3804539486 ("" (skeep*) (("" (typepred "E") (("" (typepred "vertsl") (("" (inst -2 "v1" "v2") (("" (assert) (("" (expand "subset?") (("" (inst -3 "(v1,v2)") (("" (expand "member" -3) (("" (assert) (("" (hide-all-but (-4 -3 2)) (("" (typepred "choose(E)") (("" (replace -2 :hide? t) (("" (replace -2 :hide? t) (("" (case "choose(E) = (choose(E)`1,choose(E)`2)") (("1" (replace -1 -2 :hide? t) (("1" (propax) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (edges_set_to_list_for subtype "c_digraphs_def.v2" "{a: c_digraphs_def.T | list_props[c_digraphs_def.T].member(a, c_digraphs_def.vertsl)}")) (edges_set_to_list_for_TCC2-1 nil 3657038253 ("" (skeep*) (("" (typepred "E") (("" (typepred "vertsl") (("" (inst -2 "v1" "v2") (("" (assert) (("" (expand "subset?") (("" (inst -3 "(v1,v2)") (("" (expand "member" -3) (("" (assert) (("" (hide-all-but (-4 -5 2)) (("" (typepred "choose(E)") (("" (replace -2 :hide? t) (("" (replace -2 :hide? t) (("" (case "choose(E) = (choose(E)`1,choose(E)`2)") (("1" (replace -1 -2 :hide? t) (("1" (propax) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil c_digraphs_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (list type-decl nil list_adt nil) (no_repetitions? const-decl "bool" more_list_props structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (edges_set_to_list_for subtype "c_digraphs_def.v2" "{a: c_digraphs_def.T | list_props[c_digraphs_def.T].member(a, c_digraphs_def.vertsl)}"))) (edges_set_to_list_for_TCC3 0 (edges_set_to_list_for_TCC3-1 nil 3657038253 ("" (grind) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil c_digraphs_def nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (list type-decl nil list_adt nil) (no_repetitions? const-decl "bool" more_list_props structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (N!2 skolem-const-decl "nat" c_digraphs_def nil) (length def-decl "nat" list_props nil) (vertsl!1 skolem-const-decl "{vertsl: (no_repetitions?[T]) |
   FORALL (x, y: T):
     edges_G!1(x, y) IMPLIES member(x, vertsl) AND member(y, vertsl)}" c_digraphs_def nil) (below type-eq-decl nil naturalnumbers nil) (x!1 skolem-const-decl "[T, T]" c_digraphs_def nil) (edges_G!1 skolem-const-decl "finite_set[[T, T]]" c_digraphs_def nil) (N!2 skolem-const-decl "nat" c_digraphs_def nil) (nonempty? const-decl "bool" sets nil) (choose const-decl "(p)" sets nil) (injective? const-decl "bool" functions nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (rest const-decl "set" sets nil) (/= const-decl "boolean" notequal nil) (remove const-decl "set" sets nil) (subset? const-decl "bool" sets nil)) nil (edges_set_to_list_for subtype "sets[[c_digraphs_def.T, c_digraphs_def.T]].rest(c_digraphs_def.E)" "{E: finite_sets[[c_digraphs_def.T, c_digraphs_def.T]].finite_set | sets[[c_digraphs_def.T, c_digraphs_def.T]].subset?(E, c_digraphs_def.edges_G)}"))) (edges_set_to_list_for_TCC4 0 (edges_set_to_list_for_TCC4-1 nil 3657038253 ("" (skeep*) (("" (use "card_rest[[T,T]]") (("" (assert) nil nil)) nil)) nil) ((T formal-type-decl nil c_digraphs_def nil) (card_rest formula-decl nil finite_sets nil) (subset? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (finite_rest application-judgement "finite_set[T]" set_as_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (edges_set_to_list_for termination "c_digraphs_def.edges_set_to_list_for(c_digraphs_def.edges_G, c_digraphs_def.vertsl, c_digraphs_def.v, sets[[c_digraphs_def.T, c_digraphs_def.T]].rest(c_digraphs_def.E))" "nil"))) (edges_set_to_list_for_TCC5 0 (edges_set_to_list_for_TCC5-2 "" 3804539937 ("" (skeep*) (("" (split 2) (("1" (skeep*) (("1" (expand "member" 1 1) (("1" (ground) (("1" (case "w = v2") (("1" (replace -1 :dir rl :hide? t) (("1" (replace -4 :hide? t) (("1" (replace -3 :hide? t) (("1" (replace -2 :hide? t) (("1" (hide-all-but 1) (("1" (case "choose(E) = (choose(E)`1,choose(E)`2)") (("1" (replace -1 :dir rl :hide? t) (("1" (typepred "choose(E)") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (typepred "vertsl") (("2" (use "idx_inj[T]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "v3(edges_G, vertsl, v, rest(E))") (("1" (hide -1) (("1" (inst -1 "w") (("1" (assert) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "E") (("2" (hide-all-but (-2 1)) (("2" (lemma "subset_transitive[[T,T]]") (("2" (inst? -1 :where 1) (("2" (inst? -1 :where -2) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "choose_rest_or[[T,T]]") (("3" (assert) (("3" (hide -2) (("3" (typepred "v3(edges_G, vertsl, v, rest[[T,T]](E))") (("1" (hide -1) (("1" (inst -1 "w") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "E") (("2" (hide -1) (("2" (lemma "subset_transitive[[T,T]]") (("2" (inst? -1 :where 1) (("2" (inst? -1 :where -2) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1) (("1" (typepred "idx[T](vertsl, v2)") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (typepred "v3(edges_G, vertsl, v, rest[[T,T]](E))") (("1" (inst -3 "i-1") nil nil) ("2" (use "rest_subset[[T,T]]") (("2" (typepred "E") (("2" (lemma "subset_transitive[[T,T]]") (("2" (inst -1 "rest(E)" "E" "edges_G") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "no_repetitions_append[nat]") (("3" (inst -1 "(: idx[T](vertsl, v2) :)" "v3(edges_G, vertsl, v, rest[[T,T]](E))") (("1" (expand "append" -1) (("1" (expand "append" -1) (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "member" -1) (("2" (expand "member" -1) (("2" (replace -1 :hide? t) (("2" (typepred "v3(edges_G, vertsl, v, rest[[T,T]](E))") (("1" (inst -2 "v2") (("1" (assert) (("1" (split -2) (("1" (expand "member" -1) (("1" (replace -8 :hide? t) (("1" (hide-all-but (-1 -6 -7 1)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "vertsl") (("2" (inst -2 "v1" "v2") (("2" (assert) (("2" (typepred "E") (("2" (expand "subset?") (("2" (inst -2 "(v1,v2)") (("2" (expand "member" -2) (("2" (assert) (("2" (hide-all-but (-8 -7 1)) (("2" (replace -1 :hide? t) (("2" (replace -1 :hide? t) (("2" (case "choose(E) = (choose(E)`1,choose(E)`2)") (("1" (replace -1 :dir rl :hide? t) (("1" (typepred "choose(E)") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "E") (("2" (hide-all-but (-2 1)) (("2" (lemma "subset_transitive[[T,T]]") (("2" (inst? -1 :where 1) (("2" (inst? -1 :where -2) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "E") (("2" (hide-all-but (-2 1)) (("2" (lemma "subset_transitive[[T,T]]") (("2" (inst? -1 :where 1) (("2" (inst? -1 :where -2) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (edges_set_to_list_for subtype "list_adt[nat].cons(more_list_props[c_digraphs_def.T].idx(c_digraphs_def.vertsl, c_digraphs_def.v2), c_digraphs_def.edges_set_to_list_for(c_digraphs_def.edges_G, c_digraphs_def.vertsl, c_digraphs_def.v, sets[[c_digraphs_def.T, c_digraphs_def.T]].rest(c_digraphs_def.E)))" "{adj_v: list_adt[nat].list | booleans.AND(FORALL (w: c_digraphs_def.T): booleans.IMPLIES(list_props[c_digraphs_def.T].member(w, c_digraphs_def.vertsl), (booleans.IFF(list_props[nat].member(more_list_props[c_digraphs_def.T].idx(c_digraphs_def.vertsl, w), adj_v), sets[[c_digraphs_def.T, c_digraphs_def.T]].member((c_digraphs_def.v, w), c_digraphs_def.E)))), booleans.AND(FORALL (i: naturalnumbers.below(list_props[nat].length(adj_v))): reals.<(list_props[nat].nth(adj_v, i), list_props[c_digraphs_def.T].length(c_digraphs_def.vertsl)), more_list_props[nat].no_repetitions?(adj_v)))}")) (edges_set_to_list_for_TCC5-1 nil 3657038253 ("" (skeep*) (("" (split 2) (("1" (skeep*) (("1" (expand "member" 1 1) (("1" (ground) (("1" (case "w = v2") (("1" (replace -1 :dir rl :hide? t) (("1" (replace -2 :hide? t) (("1" (replace -2 :hide? t) (("1" (replace -2 :hide? t) (("1" (hide-all-but 1) (("1" (case "choose(E) = (choose(E)`1,choose(E)`2)") (("1" (replace -1 :dir rl :hide? t) (("1" (typepred "choose(E)") (("1" (expand "member") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (typepred "vertsl") (("2" (use "idx_inj[T]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "v3(edges_G, vertsl, v, rest(E))") (("1" (hide -1) (("1" (inst -1 "w") (("1" (assert) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "E") (("2" (hide-all-but (-2 1)) (("2" (lemma "subset_transitive[[T,T]]") (("2" (inst? -1 :where 1) (("2" (inst? -1 :where -2) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (use "choose_rest_or[[T,T]]") (("3" (assert) (("3" (hide -2) (("3" (typepred "v3(edges_G, vertsl, v, rest[[T,T]](E))") (("1" (hide -1) (("1" (inst -1 "w") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "E") (("2" (hide -1) (("2" (lemma "subset_transitive[[T,T]]") (("2" (inst? -1 :where 1) (("2" (inst? -1 :where -2) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1) (("1" (typepred "idx[T](vertsl, v2)") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (typepred "v3(edges_G, vertsl, v, rest[[T,T]](E))") (("1" (inst -3 "i-1") nil nil) ("2" (use "rest_subset[[T,T]]") (("2" (typepred "E") (("2" (lemma "subset_transitive[[T,T]]") (("2" (inst -1 "rest(E)" "E" "edges_G") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "no_repetitions_append[nat]") (("3" (inst -1 "(: idx[T](vertsl, v2) :)" "v3(edges_G, vertsl, v, rest[[T,T]](E))") (("1" (expand "append" -1) (("1" (expand "append" -1) (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (grind) nil nil) ("2" (skeep) (("2" (expand "member" -1) (("2" (expand "member" -1) (("2" (replace -1 :hide? t) (("2" (typepred "v3(edges_G, vertsl, v, rest[[T,T]](E))") (("1" (inst -2 "v2") (("1" (assert) (("1" (split -2) (("1" (expand "member" -1) (("1" (replace -6 :hide? t) (("1" (hide-all-but (-1 -6 -7 1)) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "vertsl") (("2" (inst -2 "v1" "v2") (("2" (assert) (("2" (typepred "E") (("2" (expand "subset?") (("2" (inst -2 "(v1,v2)") (("2" (expand "member" -2) (("2" (assert) (("2" (hide-all-but (-8 -9 1)) (("2" (replace -1 :hide? t) (("2" (replace -1 :hide? t) (("2" (case "choose(E) = (choose(E)`1,choose(E)`2)") (("1" (replace -1 :dir rl :hide? t) (("1" (typepred "choose(E)") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "E") (("2" (hide-all-but (-2 1)) (("2" (lemma "subset_transitive[[T,T]]") (("2" (inst? -1 :where 1) (("2" (inst? -1 :where -2) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "E") (("2" (hide-all-but (-2 1)) (("2" (lemma "subset_transitive[[T,T]]") (("2" (inst? -1 :where 1) (("2" (inst? -1 :where -2) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil) (choose_rest_or formula-decl nil sets_lemmas nil) (rest const-decl "set" sets nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (finite_remove application-judgement "finite_set" set_as_list_props structures) (remove const-decl "set" sets nil) (/= const-decl "boolean" notequal nil) (subset_transitive formula-decl nil sets_lemmas nil) (T formal-type-decl nil c_digraphs_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (subset? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (choose const-decl "(p)" sets nil) (nonempty? const-decl "bool" sets nil) (set type-eq-decl nil sets nil) (NOT const-decl "[bool -> bool]" booleans nil) (member const-decl "bool" sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (no_repetitions? const-decl "bool" more_list_props structures) (list type-decl nil list_adt nil) (idx_inj formula-decl nil more_list_props structures) (finite_rest application-judgement "finite_set[T]" set_as_list_props structures) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rest_subset formula-decl nil sets_lemmas nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (edges_G skolem-const-decl "finite_set[[T, T]]" c_digraphs_def nil) (E skolem-const-decl "{E: finite_set[[T, T]] | subset?(E, edges_G)}" c_digraphs_def nil) (empty? const-decl "bool" sets nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (append def-decl "list[T]" list_props nil) (no_repetitions_append formula-decl nil more_list_props structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (edges_set_to_list_for subtype "list_adt[nat].cons(more_list_props[c_digraphs_def.T].idx(c_digraphs_def.vertsl, c_digraphs_def.v2), c_digraphs_def.edges_set_to_list_for(c_digraphs_def.edges_G, c_digraphs_def.vertsl, c_digraphs_def.v, sets[[c_digraphs_def.T, c_digraphs_def.T]].rest(c_digraphs_def.E)))" "{adj_v: list_adt[nat].list | booleans.AND(FORALL (w: c_digraphs_def.T): booleans.IMPLIES(list_props[c_digraphs_def.T].member(w, c_digraphs_def.vertsl), (booleans.IFF(list_props[nat].member(more_list_props[c_digraphs_def.T].idx(c_digraphs_def.vertsl, w), adj_v), sets[[c_digraphs_def.T, c_digraphs_def.T]].member((c_digraphs_def.v, w), c_digraphs_def.E)))), booleans.AND(FORALL (i: naturalnumbers.below(list_props[nat].length(adj_v))): reals.<(list_props[nat].nth(adj_v, i), list_props[c_digraphs_def.T].length(c_digraphs_def.vertsl)), more_list_props[nat].no_repetitions?(adj_v)))}"))) (edges_set_to_list_for_TCC6 0 (edges_set_to_list_for_TCC6-1 nil 3657038253 ("" (skeep*) (("" (typepred "E") (("" (hide-all-but (3 -2)) (("" (lemma "subset_transitive[[T,T]]") (("" (inst? -1 :where 1) (("" (inst? -1 :where -2) (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((subset? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (T formal-type-decl nil c_digraphs_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (subset_transitive formula-decl nil sets_lemmas nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil) (finite_remove application-judgement "finite_set" set_as_list_props structures) (/= const-decl "boolean" notequal nil) (remove const-decl "set" sets nil) (choose const-decl "(p)" sets nil) (E skolem-const-decl "{E: finite_set[[T, T]] | subset?(E, edges_G)}" c_digraphs_def nil) (edges_G skolem-const-decl "finite_set[[T, T]]" c_digraphs_def nil) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (finite_rest application-judgement "finite_set[T]" set_as_list_props structures) (rest const-decl "set" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (edges_set_to_list_for subtype "sets[[c_digraphs_def.T, c_digraphs_def.T]].rest(c_digraphs_def.E)" "{E: finite_sets[[c_digraphs_def.T, c_digraphs_def.T]].finite_set | sets[[c_digraphs_def.T, c_digraphs_def.T]].subset?(E, c_digraphs_def.edges_G)}"))) (edges_set_to_list_for_TCC7 0 (edges_set_to_list_for_TCC7-1 nil 3657038253 ("" (skeep*) (("" (use "card_rest[[T,T]]") (("" (grind) nil nil)) nil)) nil) ((T formal-type-decl nil c_digraphs_def nil) (card_rest formula-decl nil finite_sets nil) (subset? const-decl "bool" sets nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (finite_rest application-judgement "finite_set[T]" set_as_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (finite_remove application-judgement "finite_set" set_as_list_props structures) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (rest const-decl "set" sets nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (edges_set_to_list_for termination "c_digraphs_def.edges_set_to_list_for(c_digraphs_def.edges_G, c_digraphs_def.vertsl, c_digraphs_def.v, sets[[c_digraphs_def.T, c_digraphs_def.T]].rest(c_digraphs_def.E))" "nil"))) (edges_set_to_list_for_TCC8 0 (edges_set_to_list_for_TCC8-1 nil 3657038253 ("" (skeep*) (("" (split 3) (("1" (skeep*) (("1" (typepred "v3(edges_G, vertsl, v, rest[[T,T]](E))") (("1" (hide -1) (("1" (inst -1 "w") (("1" (assert) (("1" (replace -1 :hide? t) (("1" (ground) (("1" (grind) nil nil) ("2" (use "choose_rest_or[[T,T]]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "E") (("2" (hide-all-but (1 -2)) (("2" (lemma "subset_transitive[[T,T]]") (("2" (inst? -1 :where 1) (("2" (inst? -1 :where -2) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (typepred "v3(edges_G, vertsl, v, rest[[T,T]](E))") (("1" (inst -3 "i") nil nil) ("2" (typepred "E") (("2" (hide-all-but (1 -2)) (("2" (lemma "subset_transitive[[T,T]]") (("2" (inst? -1 :where 1) (("2" (inst? -1 :where -2) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "v3(edges_G, vertsl, v, rest[[T,T]](E))") (("1" (propax) nil nil) ("2" (typepred "E") (("2" (hide-all-but (-2 1)) (("2" (lemma "subset_transitive[[T,T]]") (("2" (inst? -1 :where 1) (("2" (inst? -1 :where -2) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rest const-decl "set" sets nil) (member const-decl "bool" sets nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (subset? const-decl "bool" sets nil) (member def-decl "bool" list_props nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (no_repetitions? const-decl "bool" more_list_props structures) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil c_digraphs_def nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (finite_rest application-judgement "finite_set[T]" set_as_list_props structures) (subset_is_partial_order name-judgement "(partial_order?[set[T]])" sets_lemmas nil) (choose_rest_or formula-decl nil sets_lemmas nil) (remove const-decl "set" sets nil) (finite_remove application-judgement "finite_set" set_as_list_props structures) (edges_G skolem-const-decl "finite_set[[T, T]]" c_digraphs_def nil) (E skolem-const-decl "{E: finite_set[[T, T]] | subset?(E, edges_G)}" c_digraphs_def nil) (choose const-decl "(p)" sets nil) (/= const-decl "boolean" notequal nil) (nonempty? const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (subset_transitive formula-decl nil sets_lemmas nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (edges_set_to_list_for subtype "c_digraphs_def.edges_set_to_list_for(c_digraphs_def.edges_G, c_digraphs_def.vertsl, c_digraphs_def.v, sets[[c_digraphs_def.T, c_digraphs_def.T]].rest(c_digraphs_def.E))" "{adj_v: list_adt[nat].list | booleans.AND(FORALL (w: c_digraphs_def.T): booleans.IMPLIES(list_props[c_digraphs_def.T].member(w, c_digraphs_def.vertsl), (booleans.IFF(list_props[nat].member(more_list_props[c_digraphs_def.T].idx(c_digraphs_def.vertsl, w), adj_v), sets[[c_digraphs_def.T, c_digraphs_def.T]].member((c_digraphs_def.v, w), c_digraphs_def.E)))), booleans.AND(FORALL (i: naturalnumbers.below(list_props[nat].length(adj_v))): reals.<(list_props[nat].nth(adj_v, i), list_props[c_digraphs_def.T].length(c_digraphs_def.vertsl)), more_list_props[nat].no_repetitions?(adj_v)))}"))) (edges_set_to_list_for_TCC9 0 (edges_set_to_list_for_TCC9-1 nil 3657038253 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil c_digraphs_def nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (list type-decl nil list_adt nil) (no_repetitions? const-decl "bool" more_list_props structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (subset? const-decl "bool" sets nil) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (nonempty? const-decl "bool" sets nil)) nil (edges_set_to_list_for subtype "c_digraphs_def.E" "(sets[[c_digraphs_def.T, c_digraphs_def.T]].nonempty?)"))) (edges_set_to_list_rec_TCC1 0 (edges_set_to_list_rec_TCC1-1 nil 3657040733 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil c_digraphs_def nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (list type-decl nil list_adt nil) (no_repetitions? const-decl "bool" more_list_props structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (suffix? def-decl "bool" more_list_props structures) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil)) nil (edges_set_to_list_rec subtype "c_digraphs_def.i" "below[length[list[nat]](adjs)]"))) (edges_set_to_list_rec_TCC2 0 (edges_set_to_list_rec_TCC2-1 nil 3657040733 ("" (skeep*) (("" (typepred "vs") (("" (use "suffix_length[T]") (("" (assert) nil nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (no_repetitions? const-decl "bool" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (list type-decl nil list_adt nil) (T formal-type-decl nil c_digraphs_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (suffix_length formula-decl nil more_list_props structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (edges_set_to_list_rec subtype "(number_fields.-)((number_fields.+)(c_digraphs_def.i, list_props[c_digraphs_def.T].length(c_digraphs_def.vertsl)), list_props[c_digraphs_def.T].length(c_digraphs_def.vs))" "below[length[T](vertsl)]"))) (edges_set_to_list_rec_TCC3 0 (edges_set_to_list_rec_TCC3-1 nil 3657040733 ("" (skeep :preds? t) (("" (split 1) (("1" (grind) nil nil) ("2" (skeep :preds? t) (("2" (grind) nil nil)) nil) ("3" (skeep :preds? t) (("3" (grind) nil nil)) nil) ("4" (grind) nil nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (is_finite const-decl "bool" finite_sets nil) (injective? const-decl "bool" functions nil) (length def-decl "nat" list_props nil) (member const-decl "bool" sets nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null adt-constructor-decl "(null?)" list_adt nil) (below type-eq-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (suffix? def-decl "bool" more_list_props structures) (reverse def-decl "list[T]" list_props nil)) nil (edges_set_to_list_rec subtype "list_adt[list[nat]].null" "{adjs: list_adt[list[nat]].list | booleans.AND(list_props[c_digraphs_def.T].length(c_digraphs_def.vs) = list_props[list[nat]].length(adjs), booleans.AND(FORALL (i: naturalnumbers.below(list_props[c_digraphs_def.T].length(c_digraphs_def.vs)), j: naturalnumbers.below(list_props[c_digraphs_def.T].length(c_digraphs_def.vertsl))): booleans.IFF(list_props[nat].member(j, list_props[list[nat]].nth(adjs, i)), sets[[c_digraphs_def.T, c_digraphs_def.T]].member((list_props[c_digraphs_def.T].nth(c_digraphs_def.vertsl, (number_fields.-)((number_fields.+)(i, list_props[c_digraphs_def.T].length(c_digraphs_def.vertsl)), list_props[c_digraphs_def.T].length(c_digraphs_def.vs))), list_props[c_digraphs_def.T].nth(c_digraphs_def.vertsl, j)), c_digraphs_def.edges_G)), booleans.AND(FORALL (i: naturalnumbers.below(list_props[list[nat]].length(adjs)), j: naturalnumbers.below(list_props[nat].length(list_props[list[nat]].nth(adjs, i)))): reals.<(list_props[nat].nth(list_props[list[nat]].nth(adjs, i), j), list_props[c_digraphs_def.T].length(c_digraphs_def.vertsl)), FORALL (i: naturalnumbers.below(list_props[list[nat]].length(adjs))): more_list_props[nat].no_repetitions?(list_props[list[nat]].nth(adjs, i)))))}"))) (edges_set_to_list_rec_TCC4 0 (edges_set_to_list_rec_TCC4-1 nil 3657040733 ("" (skeep*) (("" (typepred "vs") (("" (replace -2 :hide? t) (("" (use "suffix_member[T]") (("" (assert) (("" (hide -2) (("" (inst -1 "v") (("" (assert) (("" (hide 2) (("" (expand "member") (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (no_repetitions? const-decl "bool" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (list type-decl nil list_adt nil) (T formal-type-decl nil c_digraphs_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (suffix_member formula-decl nil more_list_props structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (edges_set_to_list_rec subtype "c_digraphs_def.v" "{v: c_digraphs_def.T | list_props[c_digraphs_def.T].member(v, c_digraphs_def.vertsl)}"))) (edges_set_to_list_rec_TCC5 0 (edges_set_to_list_rec_TCC5-1 nil 3657040733 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil c_digraphs_def nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (list type-decl nil list_adt nil) (no_repetitions? const-decl "bool" more_list_props structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (suffix? def-decl "bool" more_list_props structures) (member const-decl "bool" sets nil) (subset? const-decl "bool" sets nil)) nil (edges_set_to_list_rec subtype "c_digraphs_def.edges_G" "{E: finite_sets[[c_digraphs_def.T, c_digraphs_def.T]].finite_set | sets[[c_digraphs_def.T, c_digraphs_def.T]].subset?(E, c_digraphs_def.edges_G)}"))) (edges_set_to_list_rec_TCC6 0 (edges_set_to_list_rec_TCC6-1 nil 3657040733 ("" (skeep*) (("" (typepred "vs") (("" (replace -2 :hide? t) (("" (use "suffix_end[T]") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (no_repetitions? const-decl "bool" more_list_props structures) (suffix? def-decl "bool" more_list_props structures) (list type-decl nil list_adt nil) (T formal-type-decl nil c_digraphs_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (suffix_end formula-decl nil more_list_props structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (edges_set_to_list_rec subtype "c_digraphs_def.vs_" "{vs: list_adt[c_digraphs_def.T].list | more_list_props[c_digraphs_def.T].suffix?(vs, c_digraphs_def.vertsl)}"))) (edges_set_to_list_rec_TCC7 0 (edges_set_to_list_rec_TCC7-1 nil 3657040733 ("" (termination-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil c_digraphs_def nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (list type-decl nil list_adt nil) (no_repetitions? const-decl "bool" more_list_props structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (suffix? def-decl "bool" more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (/= const-decl "boolean" notequal nil) (injective? const-decl "bool" functions nil)) nil (edges_set_to_list_rec termination "c_digraphs_def.edges_set_to_list_rec(c_digraphs_def.edges_G, c_digraphs_def.vertsl)(c_digraphs_def.vs_)" "nil"))) (edges_set_to_list_rec_TCC8 0 (edges_set_to_list_rec_TCC8-1 nil 3657040733 ("" (skeep*) (("" (typepred "v1(edges_G, vertsl)(vs_)") (("1" (hide -1) (("1" (split 1) (("1" (expand "length" 1 2) (("1" (replace -5 :hide? t) (("1" (expand "length" 1 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (skeep :preds? t) (("2" (case "i=0") (("1" (hide -6) (("1" (replace -1 :hide? t) (("1" (expand "nth" 1 1) (("1" (typepred "edges_set_to_list_for(edges_G, vertsl, v, edges_G)") (("1" (hide -1) (("1" (inst -1 "nth(vertsl,j)") (("1" (split -1) (("1" (case "idx(vertsl, nth(vertsl, j)) = j") (("1" (replace -1 :hide? t) (("1" (replace -1 :hide? t) (("1" (case "nth[T](vertsl, length[T](vertsl) - length[T](vs))=v") (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (-8 1)) (("2" (use "suffix_first_elem[T]") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (typepred "vs") (("3" (use "suffix_length[T]") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (typepred "vertsl") (("2" (use "idx_nth_no_rep[T]") nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (use "nth_member[T]") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 2 1) (("2" (assert) (("2" (inst -4 "i-1" "j") (("1" (assert) (("1" (replace -4 :hide? t) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (case "i=0") (("1" (replace -1) (("1" (expand "nth" 1 2) (("1" (typepred "edges_set_to_list_for(edges_G, vertsl, v, edges_G)") (("1" (inst -3 "j") nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2 2) (("2" (assert) (("2" (inst -3 "i-1" "j") nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (case "i=0") (("1" (replace -1 :hide? t) (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst -4 "i-1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (split 1) (("1" (typepred "vs") (("1" (replace -2 :hide? t) (("1" (use "suffix_end[T]") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "vs") (("2" (replace -2 :hide? t) (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (member const-decl "bool" sets nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (suffix? def-decl "bool" more_list_props structures) (member def-decl "bool" list_props nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (no_repetitions? const-decl "bool" more_list_props structures) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil c_digraphs_def nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (subset? const-decl "bool" sets nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (edges_set_to_list_for def-decl "{adj_v: list[nat] |
   (FORALL (w: T):
      member(w, vertsl) IMPLIES
       (member(idx(vertsl, w), adj_v) IFF member((v, w), E)))
    AND
    (FORALL (i: below(length(adj_v))): nth(adj_v, i) < length(vertsl)) AND
     no_repetitions?(adj_v)}" c_digraphs_def nil) (nth_member formula-decl nil more_list_props structures) (suffix_length formula-decl nil more_list_props structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (edges_G skolem-const-decl "finite_set[[T, T]]" c_digraphs_def nil) (vertsl skolem-const-decl "{vertsl: (no_repetitions?[T]) |
   FORALL (x, y: T):
     edges_G(x, y) IMPLIES member(x, vertsl) AND member(y, vertsl)}" c_digraphs_def nil) (vs skolem-const-decl "{vs: list[T] | suffix?(vs, vertsl)}" c_digraphs_def nil) (suffix_first_elem formula-decl nil more_list_props structures) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (idx_nth_no_rep formula-decl nil more_list_props structures) (int_plus_int_is_int application-judgement "int" integers nil) (/= const-decl "boolean" notequal nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (vs_ skolem-const-decl "list[T]" c_digraphs_def nil) (i skolem-const-decl "below(length(vs))" c_digraphs_def nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (suffix_end formula-decl nil more_list_props structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (edges_set_to_list_rec subtype "list_adt[list[nat]].cons(c_digraphs_def.edges_set_to_list_for(c_digraphs_def.edges_G, c_digraphs_def.vertsl, c_digraphs_def.v, c_digraphs_def.edges_G), c_digraphs_def.edges_set_to_list_rec(c_digraphs_def.edges_G, c_digraphs_def.vertsl)(c_digraphs_def.vs_))" "{adjs: list_adt[list[nat]].list | booleans.AND(list_props[c_digraphs_def.T].length(c_digraphs_def.vs) = list_props[list[nat]].length(adjs), booleans.AND(FORALL (i: naturalnumbers.below(list_props[c_digraphs_def.T].length(c_digraphs_def.vs)), j: naturalnumbers.below(list_props[c_digraphs_def.T].length(c_digraphs_def.vertsl))): booleans.IFF(list_props[nat].member(j, list_props[list[nat]].nth(adjs, i)), sets[[c_digraphs_def.T, c_digraphs_def.T]].member((list_props[c_digraphs_def.T].nth(c_digraphs_def.vertsl, (number_fields.-)((number_fields.+)(i, list_props[c_digraphs_def.T].length(c_digraphs_def.vertsl)), list_props[c_digraphs_def.T].length(c_digraphs_def.vs))), list_props[c_digraphs_def.T].nth(c_digraphs_def.vertsl, j)), c_digraphs_def.edges_G)), booleans.AND(FORALL (i: naturalnumbers.below(list_props[list[nat]].length(adjs)), j: naturalnumbers.below(list_props[nat].length(list_props[list[nat]].nth(adjs, i)))): reals.<(list_props[nat].nth(list_props[list[nat]].nth(adjs, i), j), list_props[c_digraphs_def.T].length(c_digraphs_def.vertsl)), FORALL (i: naturalnumbers.below(list_props[list[nat]].length(adjs))): more_list_props[nat].no_repetitions?(list_props[list[nat]].nth(adjs, i)))))}"))) (edges_set_to_list_TCC1 0 (edges_set_to_list_TCC1-1 nil 3657041388 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil c_digraphs_def nil) (set type-eq-decl nil sets nil) (is_finite const-decl "bool" finite_sets nil) (finite_set type-eq-decl nil finite_sets nil) (list type-decl nil list_adt nil) (no_repetitions? const-decl "bool" more_list_props structures) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (number nonempty-type-decl nil numbers nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil)) nil (edges_set_to_list subtype "c_digraphs_def.i" "below[length[list[nat]](adjs)]"))) (edges_set_to_list_TCC2 0 (edges_set_to_list_TCC2-1 nil 3657041388 ("" (skeep) (("" (use "suffix_reflexive[T]") nil nil)) nil) ((member def-decl "bool" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (no_repetitions? const-decl "bool" more_list_props structures) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (suffix_reflexive formula-decl nil more_list_props structures) (T formal-type-decl nil c_digraphs_def nil)) nil (edges_set_to_list subtype "c_digraphs_def.vertsl" "{vs: list_adt[c_digraphs_def.T].list | more_list_props[c_digraphs_def.T].suffix?(vs, c_digraphs_def.vertsl)}"))) (edges_set_to_list_TCC3 0 (edges_set_to_list_TCC3-1 nil 3657041388 ("" (skeep*) (("" (typepred "edges_set_to_list_rec(edges_G, vertsl)(vertsl)") (("1" (hide -1) (("1" (assert) (("1" (split 1) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("2" (use "suffix_reflexive[T]") nil nil)) nil)) nil) ((edges_set_to_list_rec def-decl "{adjs: list[list[nat]] |
   length(vs) = length(adjs) AND
    (FORALL (i: below(length(vs)), j: below(length(vertsl))):
       member(j, nth(adjs, i)) IFF
        LET vi = nth(vertsl, i + length(vertsl) - length(vs)),
            vj = nth(vertsl, j)
          IN member((vi, vj), edges_G))
     AND
     (FORALL (i: below(length(adjs)), j: below(length(nth(adjs, i)))):
        nth(nth(adjs, i), j) < length(vertsl))
      AND (FORALL (i: below(length(adjs))): no_repetitions?(nth(adjs, i)))}" c_digraphs_def nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (member const-decl "bool" sets nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (suffix? def-decl "bool" more_list_props structures) (member def-decl "bool" list_props nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (no_repetitions? const-decl "bool" more_list_props structures) (finite_set type-eq-decl nil finite_sets nil) (T formal-type-decl nil c_digraphs_def nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (suffix_reflexive formula-decl nil more_list_props structures) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) nil (edges_set_to_list subtype "c_digraphs_def.edges_set_to_list_rec(c_digraphs_def.edges_G, c_digraphs_def.vertsl)(c_digraphs_def.vertsl)" "{adjs: list_adt[list[nat]].list | booleans.AND(list_props[list[nat]].length(adjs) = list_props[c_digraphs_def.T].length(c_digraphs_def.vertsl), booleans.AND(FORALL (i, j: naturalnumbers.below(list_props[c_digraphs_def.T].length(c_digraphs_def.vertsl))): booleans.IFF(list_props[nat].member(j, list_props[list[nat]].nth(adjs, i)), sets[[c_digraphs_def.T, c_digraphs_def.T]].member((list_props[c_digraphs_def.T].nth(c_digraphs_def.vertsl, i), list_props[c_digraphs_def.T].nth(c_digraphs_def.vertsl, j)), c_digraphs_def.edges_G)), booleans.AND(FORALL (i: naturalnumbers.below(list_props[list[nat]].length(adjs)), j: naturalnumbers.below(list_props[nat].length(list_props[list[nat]].nth(adjs, i)))): reals.<(list_props[nat].nth(list_props[list[nat]].nth(adjs, i), j), list_props[c_digraphs_def.T].length(c_digraphs_def.vertsl)), FORALL (i: naturalnumbers.below(list_props[list[nat]].length(adjs))): more_list_props[nat].no_repetitions?(list_props[list[nat]].nth(adjs, i)))))}"))) (make_TCC1 0 (make_TCC1-1 nil 3657042143 ("" (skeep) (("" (typepred "set2list(v)") (("" (split 1) (("1" (use "same_size_eq_no_rep[T]") (("1" (assert) (("1" (inst?) (("1" (assert) (("1" (expand "set_list_eq") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "e") (("2" (skeep) (("2" (inst -2 "x" "y") (("2" (assert) (("2" (flatten) (("2" (inst-cp -6 "x") (("2" (assert) (("2" (assert) (("2" (inst -6 "y") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((set2list def-decl "{l: list[T] | length(l) = card(s) AND FORALL (x: T): s(x) IFF member(x, l)}" set_as_list structures) (member def-decl "bool" list_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (list type-decl nil list_adt nil) (T formal-type-decl nil c_digraphs_def nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (same_size_eq_no_rep formula-decl nil set_as_list_props structures) (set_list_eq const-decl "bool" set_as_list structures) (member const-decl "bool" sets nil) (empty? const-decl "bool" sets nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (below type-eq-decl nil naturalnumbers nil)) nil (make subtype "set_as_list[c_digraphs_def.T].set2list(c_digraphs_def.v)" "{vertsl: (more_list_props[c_digraphs_def.T].no_repetitions?) | FORALL (x, y: c_digraphs_def.T): booleans.IMPLIES(c_digraphs_def.e(x, y), booleans.AND(list_props[c_digraphs_def.T].member(x, vertsl), list_props[c_digraphs_def.T].member(y, vertsl)))}"))) (make_TCC2 0 (make_TCC2-1 nil 3657042143 ("" (skeep) (("" (with-labels (case "FORALL (x, y: T):
          e(x, y) IMPLIES
           member[T](x, set2list[T](v)) AND member[T](y, set2list[T](v))") "e in v,v") (("1" (hide "e in v,v") (("1" (with-labels (case "cdigraph((# data := set2list[T](v),
                  adjs := edges_set_to_list(e, set2list[T](v)) #))") "c_digraphs_def") (("1" (hide "c_digraphs_def") (("1" (split 1) (("1" (reveal "c_digraphs_def") (("1" (propax) nil nil)) nil) ("2" (expand "vert") (("2" (typepred "set2list(v)") (("2" (apply-extensionality 1) (("2" (hide 2) (("2" (inst?) (("2" (replace -2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "edges") (("3" (apply-extensionality 1) (("1" (hide 2) (("1" (expand "vert" 1) (("1" (iff) (("1" (split 1) (("1" (flatten) (("1" (typepred "edges_set_to_list(e, set2list[T](v))") (("1" (inst? -3) (("1" (expand "member" -3 2) (("1" (hide-all-but (-8 -3 1)) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "e") (("2" (inst -2 "x!1" "x!2") (("2" (assert) (("2" (flatten) (("2" (typepred "set2list(v)") (("2" (inst-cp -2 "x!1") (("2" (inst -2 "x!2") (("2" (assert) (("2" (typepred "edges_set_to_list(e, set2list[T](v))") (("2" (inst? -3) (("2" (assert) (("2" (hide-all-but (1 -11)) (("2" (expand "member") (("2" (typepred "idx(set2list[T](v), x!2)") (("2" (typepred "idx(set2list[T](v), x!1)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (typepred "edges_set_to_list(e, set2list[T](v))") (("2" (replace -2 :hide? t) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (grind) nil nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (reveal "e in v,v") (("4" (use "no_rep_s2l[T]") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (grind) nil nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (reveal "c_digraphs_def") (("6" (propax) nil nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (use "no_rep_s2l[T]") (("7" (reveal "e in v,v") (("7" (assert) nil nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (reveal "c_digraphs_def") (("8" (propax) nil nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (use "no_rep_s2l[T]") (("9" (reveal "e in v,v") (("9" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "cdigraph") (("2" (typepred "edges_set_to_list(e, set2list[T](v))") (("1" (assert) (("1" (hide -1) (("1" (split 1) (("1" (expand "list_of_idxs") (("1" (expand "size" 1) (("1" (assert) (("1" (skeep 1) (("1" (skeep 1) (("1" (inst -3 "i" "i_1") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (use "no_rep_s2l[T]") nil nil) ("3" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (use "no_rep_s2l[T]") (("2" (assert) (("2" (reveal "e in v,v") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (use "no_rep_s2l[T]") (("3" (assert) (("3" (reveal "e in v,v") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "e") (("2" (skeep) (("2" (inst -2 "x" "y") (("2" (assert) (("2" (flatten) (("2" (typepred "set2list(v)") (("2" (inst-cp -2 "x") (("2" (inst-cp -2 "y") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((set2list def-decl "{l: list[T] | length(l) = card(s) AND FORALL (x: T): s(x) IFF member(x, l)}" set_as_list structures) (IFF const-decl "[bool, bool -> bool]" booleans nil) (card const-decl "{n: nat | n = Card(S)}" finite_sets nil) (Card const-decl "nat" finite_sets nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (member def-decl "bool" list_props nil) (list type-decl nil list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finite_set type-eq-decl nil finite_sets nil) (is_finite const-decl "bool" finite_sets nil) (set type-eq-decl nil sets nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil c_digraphs_def nil) (edges_set_to_list const-decl "{adjs: list[list[nat]] |
   length(adjs) = length(vertsl) AND
    (FORALL (i, j: below(length(vertsl))):
       member(j, nth(adjs, i)) IFF
        LET vi = nth(vertsl, i), vj = nth(vertsl, j) IN
          member((vi, vj), edges_G))
     AND
     (FORALL (i: below(length(adjs)), j: below(length(nth(adjs, i)))):
        nth(nth(adjs, i), j) < length(vertsl))
      AND (FORALL (i: below(length(adjs))): no_repetitions?(nth(adjs, i)))}" c_digraphs_def nil) (member const-decl "bool" sets nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (below type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (no_repetitions? const-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (vert const-decl "bool" c_digraphs_def nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (c_digraph type-eq-decl nil c_digraphs_def nil) (e skolem-const-decl "{e: finite_set[[T, T]] | FORALL (x, y: T): e(x, y) IMPLIES v(x) AND v(y)}" c_digraphs_def nil) (v skolem-const-decl "finite_set[T]" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (empty? const-decl "bool" sets nil) (no_rep_s2l formula-decl nil set_as_list_props structures) (edges const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil)) nil (make subtype "(# data := set_as_list[c_digraphs_def.T].set2list(c_digraphs_def.v), adjs := c_digraphs_def.edges_set_to_list(c_digraphs_def.e, set_as_list[c_digraphs_def.T].set2list(c_digraphs_def.v)) #)" "{cd: (c_digraphs_def.cdigraph) | booleans.AND(c_digraphs_def.vert(cd) = c_digraphs_def.v, c_digraphs_def.edges(cd) = c_digraphs_def.e)}"))) (empty_cd_TCC1 0 (empty_cd_TCC1-2 "" 3744347842 ("" (grind) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil naturalnumbers nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (every adt-def-decl "boolean" list_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil c_digraphs_def nil) (length def-decl "nat" list_props nil) (size const-decl "nat" c_digraphs_def nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (cdigraph const-decl "bool" c_digraphs_def nil)) shostak (empty_cd subtype "(# data := list_adt[c_digraphs_def.T].null, adjs := list_adt[list[nat]].null #)" "(c_digraphs_def.cdigraph)")) (empty_cd_TCC1-1 nil 3657624901 ("" (subtype-tcc) nil nil) ((no_repetitions? const-decl "bool" more_list_props structures)) nil (empty_cd subtype "(# data := list_adt[c_digraphs_def.T].null, adjs := list_adt[list[nat]].null #)" "(c_digraphs_def.cdigraph)"))) (add_vert_TCC1 0 (add_vert_TCC1-1 nil 3657625026 ("" (skeep*) (("" (expand "cdigraph") (("" (typepred "cd") (("" (split 1) (("1" (expand "cdigraph") (("1" (flatten) (("1" (use "length_append[T]") (("1" (replace -1 :hide? t) (("1" (use "length_append[list[nat]]") (("1" (replace -1 :hide? t) (("1" (expand "length" 1 2) (("1" (expand "length" 1 2) (("1" (expand "length" 1 3) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "cdigraph") (("2" (flatten) (("2" (hide-all-but (-2 1)) (("2" (skeep) (("2" (use "nth_append[list[nat]]") (("2" (split -1) (("1" (assert) (("1" (replace -1 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (inst?) (("1" (expand "list_of_idxs") (("1" (expand "size" 1) (("1" (expand "size" -2) (("1" (skeep) (("1" (inst?) (("1" (assert) (("1" (use "length_append[T]") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "i") (("2" (use "length_append[list[nat]]") (("2" (replace -1 :hide? t) (("2" (expand "length" -1 2) (("2" (expand "length" -1 2) (("2" (case "i - length[list[nat]](cd`adjs) = 0") (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (assert) (("2" (use "length_append[list[nat]]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "cdigraph") (("3" (flatten) (("3" (hide-all-but (1 -3)) (("3" (typepred "v") (("3" (expand "vert") (("3" (use "no_repetitions_append[T]") (("3" (assert) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "cdigraph") (("4" (flatten) (("4" (hide-all-but (1 -4)) (("4" (skeep) (("4" (use "nth_append[list[nat]]") (("4" (assert) (("4" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (inst?) nil nil)) nil) ("2" (flatten) (("2" (case "i - length[list[nat]](cd`adjs) = 0") (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil) ("2" (typepred "i") (("2" (assert) (("2" (use "length_append[list[nat]]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (use "length_append[list[nat]]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdigraph const-decl "bool" c_digraphs_def nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length def-decl "nat" list_props nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (vert const-decl "bool" c_digraphs_def nil) (length_append formula-decl nil list_props nil) (size const-decl "nat" c_digraphs_def nil) (length_singleton formula-decl nil more_list_props structures) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (append def-decl "list[T]" list_props nil) (below type-eq-decl nil naturalnumbers nil) (nth_append formula-decl nil more_list_props structures) (no_repetitions_append formula-decl nil more_list_props structures) (member def-decl "bool" list_props nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (add_vert subtype "(# data := list_props[c_digraphs_def.T].append(c_digraphs_def.cd`data, (: c_digraphs_def.v :)), adjs := list_props[list[nat]].append(c_digraphs_def.cd`adjs, (: list_adt[nat].null :)) #)" "(c_digraphs_def.cdigraph)"))) (add_edge_TCC1 0 (add_edge_TCC1-1 nil 3657625026 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (vert const-decl "bool" c_digraphs_def nil) (edges const-decl "bool" c_digraphs_def nil) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil)) nil (add_edge subtype "c_digraphs_def.u" "{a: c_digraphs_def.T | list_props[c_digraphs_def.T].member(a, c_digraphs_def.cd`data)}"))) (add_edge_TCC2 0 (add_edge_TCC2-1 nil 3657625026 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (cdigraph const-decl "bool" c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (vert const-decl "bool" c_digraphs_def nil) (edges const-decl "bool" c_digraphs_def nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (member def-decl "bool" list_props nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (no_repetitions? const-decl "bool" more_list_props structures) (/= const-decl "boolean" notequal nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (size const-decl "nat" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (add_edge subtype "c_digraphs_def.u_idx" "naturalnumbers.below(list_props[list[nat]].length(c_digraphs_def.cd`adjs))"))) (add_edge_TCC3 0 (add_edge_TCC3-2 nil 3658519873 ("" (skeep*) (("" (expand "cdigraph") (("" (typepred "cd") (("" (expand "cdigraph") (("" (flatten) (("" (split 1) (("1" (hide-all-but (-1 1)) (("1" (typepred "update_list(cd`adjs, u_idx,
                        append[nat](nth[list[nat]](cd`adjs, u_idx), (: v_idx :)))") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1 -5 -6)) (("2" (skeep) (("2" (typepred "update_list(cd`adjs, u_idx,
                        append[nat](nth[list[nat]](cd`adjs, u_idx), (: v_idx :)))") (("2" (hide -1) (("2" (inst -2 "i") (("1" (replace -2 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (expand "list_of_idxs") (("1" (expand "size") (("1" (skeep) (("1" (use "nth_append[nat]") (("1" (split -1) (("1" (replace -1 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (inst? -4) nil nil)) nil) ("2" (flatten) (("2" (case "i!1 - length(nth[list[nat]](cd`adjs, u_idx)) = 0 ") (("1" (replace -1 :hide? t) (("1" (grind) nil nil)) nil) ("2" (typepred "i!1") (("2" (use "length_append[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (use "length_append[nat]") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "list_of_idxs") (("2" (expand "size") (("2" (skeep) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (typepred "update_list(cd`adjs, u_idx,
                          append[nat](nth[list[nat]](cd`adjs, u_idx), (: v_idx :)))") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (hide-all-but (1 -4 -5 -6)) (("4" (skeep) (("4" (typepred "update_list(cd`adjs, u_idx,
                        append[nat](nth[list[nat]](cd`adjs, u_idx), (: v_idx :)))") (("4" (hide -1) (("4" (inst?) (("1" (replace -2 :hide? t) (("1" (lift-if 1) (("1" (split 1) (("1" (flatten) (("1" (use "no_repetitions_append[nat]") (("1" (assert) (("1" (hide 2) (("1" (split 1) (("1" (inst? -3) nil nil) ("2" (grind) nil nil) ("3" (skeep) (("3" (expand "member" -2) (("3" (expand "member" -2) (("3" (replace -2 :hide? t) (("3" (typepred "v") (("3" (expand "edges") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdigraph const-decl "bool" c_digraphs_def nil) (edges const-decl "bool" c_digraphs_def nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (append def-decl "list[T]" list_props nil) (vert const-decl "bool" c_digraphs_def nil) (update_list def-decl "{r: list[T] |
   length(l) = length(r) AND
    FORALL (j: below(length(l))):
      nth(r, j) = IF i = j THEN x ELSE nth(l, j) ENDIF}" more_list_props structures) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (list_of_idxs const-decl "bool" c_digraphs_def nil) (length_singleton formula-decl nil more_list_props structures) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (length_append formula-decl nil list_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (nth_append formula-decl nil more_list_props structures) (size const-decl "nat" c_digraphs_def nil) (cd skolem-const-decl "c_digraph" c_digraphs_def nil) (u skolem-const-decl "(vert(cd))" c_digraphs_def nil) (u_idx skolem-const-decl "{i: below(length[T](cd`data)) | nth[T](cd`data, i) = u}" c_digraphs_def nil) (v skolem-const-decl "{v: (vert(cd)) | NOT edges(cd)(u, v)}" c_digraphs_def nil) (v_idx skolem-const-decl "{i: below(length[T](cd`data)) | nth[T](cd`data, i) = v}" c_digraphs_def nil) (i skolem-const-decl "below(length(update_list[list[nat]]
                 (cd`adjs, u_idx,
                  append[nat]
                      (nth[list[nat]](cd`adjs, u_idx), (: v_idx :)))))" c_digraphs_def nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (no_repetitions_append formula-decl nil more_list_props structures) (/= const-decl "boolean" notequal nil) (no_repetitions? const-decl "bool" more_list_props structures) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (member def-decl "bool" list_props nil) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures) (i skolem-const-decl "below(length(update_list[list[nat]]
                 (cd`adjs, u_idx,
                  append[nat]
                      (nth[list[nat]](cd`adjs, u_idx), (: v_idx :)))))" c_digraphs_def nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (every adt-def-decl "boolean" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil c_digraphs_def nil) (ComputableDigraph type-eq-decl nil c_digraphs_def nil) (c_digraph type-eq-decl nil c_digraphs_def nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (add_edge subtype "c_digraphs_def.cd WITH [adjs := more_list_props[list[nat]].update_list(c_digraphs_def.cd`adjs, c_digraphs_def.u_idx, list_props[nat].append(list_props[list[nat]].nth(c_digraphs_def.cd`adjs, c_digraphs_def.u_idx), (: c_digraphs_def.v_idx :)))]" "(c_digraphs_def.cdigraph)")) (add_edge_TCC3-1 nil 3657625026 ("" (subtype-tcc) nil nil) ((no_repetitions? const-decl "bool" more_list_props structures) (idx def-decl "{i: below(length(l)) | nth(l, i) = a}" more_list_props structures)) nil (add_edge subtype "c_digraphs_def.cd WITH [adjs := more_list_props[list[nat]].update_list(c_digraphs_def.cd`adjs, c_digraphs_def.u_idx, list_props[nat].append(list_props[list[nat]].nth(c_digraphs_def.cd`adjs, c_digraphs_def.u_idx), (: c_digraphs_def.v_idx :)))]" "(c_digraphs_def.cdigraph)"))))
