(eval_properties
 (eval_monom_const_TCC1 0
  (eval_monom_const_TCC1-1 nil 3813336925 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil
   (eval_monom_const subtype "eval_properties.vals"
    "{vals: list_adt[real].list | list_props[real].length(vals) = list_props[nat].length(eval_properties.ind)}")))
 (eval_monom_const 0
  (eval_monom_const-1 nil 3813336958
   ("" (induct "vals")
    (("1" (skeep)
      (("1" (expand "eval")
        (("1" (expand "length" -1)
          (("1" (assert)
            (("1" (lift-if -1)
              (("1" (split -1)
                (("1" (assert) nil nil)
                 ("2" (flatten) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand "eval" 1)
          (("2" (expand "length" -2)
            (("2" (assert)
              (("2" (lift-if -2)
                (("2" (split -2)
                  (("1" (flatten) (("1" (assert) nil nil)) nil)
                   ("2" (flatten)
                    (("2" (assert)
                      (("2" (lift-if 2)
                        (("2" (split 2)
                          (("1" (flatten)
                            (("1" (inst?) (("1" (assert) nil nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (copy -2)
                              (("2"
                                (inst?)
                                (("1"
                                  (assert)
                                  (("1"
                                    (replaces -1)
                                    (("1"
                                      (swap-rel 2)
                                      (("1"
                                        (inst?)
                                        (("1" (assert) nil nil)
                                         ("2"
                                          (typepred "ind")
                                          (("2"
                                            (expand "every")
                                            (("2"
                                              (flatten)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (replace -3)
                                                  (("2"
                                                    (replace -4)
                                                    (("2"
                                                      (propax)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (typepred "ind")
                                        (("2"
                                          (expand "every")
                                          (("2"
                                            (flatten)
                                            (("2"
                                              (replace -3)
                                              (("2"
                                                (replace -4)
                                                (("2"
                                                  (propax)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (typepred "ind")
                                  (("2"
                                    (expand "every")
                                    (("2"
                                      (flatten)
                                      (("2"
                                        (replace -3)
                                        (("2"
                                          (replace -4)
                                          (("2" (propax) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (assert) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (TRUE const-decl "bool" booleans nil)
    (replace def-decl "list[nat]" eval_MultPoly nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (eval def-decl "monomial" eval_MultPoly nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil))
   nil))
 (bov?_TCC1 0
  (bov?_TCC1-1 nil 3813936404 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil (bov? subtype "eval_properties.alpha" "(list_adt[nat].cons?)")))
 (bov?_TCC2 0
  (bov?_TCC2-1 nil 3813936404 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (bov? termination
    "eval_properties.bov?(eval_properties.i)(list_adt[nat].cdr(eval_properties.alpha))"
    "nil")))
 (bov_nth 0
  (bov_nth-1 nil 3813941082
   ("" (induct "alpha")
    (("1" (skeep)
      (("1" (typepred "i") (("1" (assert) (("1" (grind) nil nil)) nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (split 1)
          (("1" (flatten)
            (("1" (expand "bov?" -1)
              (("1" (flatten)
                (("1" (skeep)
                  (("1" (case "k=0")
                    (("1" (assert)
                      (("1" (expand "nth" 1 1) (("1" (propax) nil nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (inst -3 "i")
                        (("2" (assert)
                          (("2" (inst -3 "k-1")
                            (("1" (expand "nth" 2 1)
                              (("1" (propax) nil nil)) nil)
                             ("2" (assert)
                              (("2"
                                (typepred "k")
                                (("2"
                                  (expand "length" -1)
                                  (("2" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (flatten)
            (("2" (expand "bov?" 1)
              (("2" (inst -1 "0")
                (("1" (expand "nth" -1)
                  (("1" (assert)
                    (("1" (reveal -)
                      (("1" (hide -2)
                        (("1" (inst -3 "i")
                          (("1" (assert)
                            (("1" (skeep)
                              (("1"
                                (inst -1 "k+1")
                                (("1"
                                  (expand "nth" -1)
                                  (("1" (propax) nil nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (expand "length" 1)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (expand "length" 1) (("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (> const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (bov? def-decl "bool" eval_properties nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   nil))
 (sub1_TCC1 0
  (sub1_TCC1-1 nil 3813936404 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bov? def-decl "bool" eval_properties nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil))
   nil (sub1 subtype "eval_properties.i" "below[length[nat](l)]")))
 (sub1_TCC2 0
  (sub1_TCC2-1 nil 3813936404 ("" (subtype-tcc) nil nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (bov? def-decl "bool" eval_properties nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (length_null formula-decl nil more_list_props structures))
   nil
   (sub1 subtype "list_adt[real].null"
    "{ll: list_adt[nat].list | booleans.AND(list_props[nat].length(ll) = list_props[nat].length(eval_properties.l), FORALL (i: naturalnumbers.below(list_props[nat].length(ll))): list_props[nat].nth(ll, i) = (number_fields.-)(list_props[nat].nth(eval_properties.l, i), 1))}")))
 (sub1_TCC3 0
  (sub1_TCC3-1 nil 3813936404 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bov? def-decl "bool" eval_properties nil))
   nil (sub1 subtype "eval_properties.l" "(list_adt[nat].cons?)")))
 (sub1_TCC4 0
  (sub1_TCC4-2 nil 3813941060
   ("" (skeep)
    (("" (assert)
      (("" (typepred "l")
        (("" (lemma "bov_nth")
          (("" (inst -1 "0" "l")
            (("" (assert)
              (("" (inst -1 "0")
                (("1" (expand "nth" -1) (("1" (assert) nil nil)) nil)
                 ("2" (expand "length" 1) (("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (bov_nth formula-decl nil eval_properties nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nth def-decl "T" list_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bov? def-decl "bool" eval_properties nil))
   nil
   (sub1 subtype
    "(number_fields.-)(list_adt[nat].car(eval_properties.l), 1)"
    "nat"))
  (sub1_TCC4-1 nil 3813936404 ("" (subtype-tcc) nil nil) nil nil
   (sub1 subtype
    "(number_fields.-)(list_adt[nat].car(eval_properties.l), 1)"
    "nat")))
 (sub1_TCC5 0
  (sub1_TCC5-2 nil 3813941042
   ("" (skeep)
    (("" (typepred "l")
      (("" (expand "bov?" -2) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((bov? def-decl "bool" eval_properties nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (sub1 subtype "list_adt[nat].cdr(eval_properties.l)"
    "{ll: list_adt[nat].list | eval_properties.bov?(0)(ll)}"))
  (sub1_TCC5-1 nil 3813936404 ("" (subtype-tcc) nil nil) nil nil
   (sub1 subtype "list_adt[nat].cdr(eval_properties.l)"
    "{ll: list_adt[nat].list | eval_properties.bov?(0)(ll)}")))
 (sub1_TCC6 0
  (sub1_TCC6-1 nil 3813936404 ("" (termination-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bov? def-decl "bool" eval_properties nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (sub1 termination
    "eval_properties.sub1(list_adt[nat].cdr(eval_properties.l))"
    "nil")))
 (sub1_TCC7 0
  (sub1_TCC7-2 nil 3813941021
   ("" (skeep)
    (("" (assert)
      (("" (expand "length" 2 1)
        (("" (assert)
          (("" (expand "length" 2 2)
            (("" (assert)
              (("" (skeep)
                (("" (case "i=0")
                  (("1" (expand "nth") (("1" (assert) nil nil)) nil)
                   ("2" (expand "nth" 3)
                    (("2" (assert)
                      (("2" (typepred "v(cdr(l))")
                        (("2" (inst -3 "i-1") nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (bov? def-decl "bool" eval_properties nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil))
   nil
   (sub1 subtype
    "list_adt[nat].cons((number_fields.-)(list_adt[nat].car(eval_properties.l), 1), eval_properties.sub1(list_adt[nat].cdr(eval_properties.l)))"
    "{ll: list_adt[nat].list | booleans.AND(list_props[nat].length(ll) = list_props[nat].length(eval_properties.l), FORALL (i: naturalnumbers.below(list_props[nat].length(ll))): list_props[nat].nth(ll, i) = (number_fields.-)(list_props[nat].nth(eval_properties.l, i), 1))}"))
  (sub1_TCC7-1 nil 3813936404 ("" (subtype-tcc) nil nil) nil nil
   (sub1 subtype
    "list_adt[nat].cons((number_fields.-)(list_adt[nat].car(eval_properties.l), 1), eval_properties.sub1(list_adt[nat].cdr(eval_properties.l)))"
    "{ll: list_adt[nat].list | booleans.AND(list_props[nat].length(ll) = list_props[nat].length(eval_properties.l), FORALL (i: naturalnumbers.below(list_props[nat].length(ll))): list_props[nat].nth(ll, i) = (number_fields.-)(list_props[nat].nth(eval_properties.l, i), 1))}")))
 (one_nth_TCC1 0
  (one_nth_TCC1-1 nil 3813938870
   ("" (skeep)
    (("" (lemma "length_appendn[nat]")
      (("" (inst?) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (length_appendn formula-decl nil more_list_props structures)
    (length_singleton formula-decl nil more_list_props structures)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   nil
   (one_nth subtype "eval_properties.k"
    "below[length[nat]((^[nat]((: 1 :), (n))))]")))
 (one_nth 0
  (one_nth-1 nil 3813939268
   ("" (induct "n")
    (("1" (skeep) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (case "k=0")
          (("1" (grind) nil nil)
           ("2" (inst -1 "k-1")
            (("1" (expand "nth" 2 1)
              (("1" (assert) (("1" (grind) nil nil)) nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skeep)
        (("3" (lemma " length_appendn[real]")
          (("3" (inst?) (("3" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((length_appendn formula-decl nil more_list_props structures)
    (length_singleton formula-decl nil more_list_props structures)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (append def-decl "list[T]" list_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil))
   nil))
 (alpha_null_eval_TCC1 0
  (alpha_null_eval_TCC1-1 nil 3814171954 ("" (subtype-tcc) nil nil) nil
   nil
   (alpha_null_eval subtype "eval_properties.vals"
    "{vals: list_adt[real].list | list_props[real].length(vals) = list_props[nat].length(eval_properties.index)}")))
 (alpha_null_eval 0
  (alpha_null_eval-1 nil 3814172304
   (""
    (case " FORALL (n:nat, m: monomial, vals: list[real],
                     index: {l: list[nat] | length(l) = length(vals)}):
               length(vals)=n IMPLIES (m`alpha = null IMPLIES eval(m, index)(vals)`C = m`C)")
    (("1" (skeep)
      (("1" (inst -1 "length(vals)" "m" "vals" "index")
        (("1" (assert) nil nil)) nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "n")
        (("1" (skeep)
          (("1" (grind)
            (("1" (expand "eval" 1 1)
              (("1" (typepred "vals")
                (("1" (typepred "index")
                  (("1" (hide -1 -3)
                    (("1" (case "index=null")
                      (("1" (assert) nil nil) ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (case "j=0")
              (("1" (case "cdr(vals)=null")
                (("1" (case "cdr(index)=null")
                  (("1" (expand "eval" 1)
                    (("1" (lift-if 1)
                      (("1" (split 1)
                        (("1" (propax) nil nil)
                         ("2" (flatten)
                          (("2" (assert)
                            (("2" (split 2)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (replace -2)
                                    (("1"
                                      (replace -3)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (assert)
                                  (("2"
                                    (replace -1)
                                    (("2"
                                      (replace -2)
                                      (("2"
                                        (expand "eval" 2 1)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (expand "length" 1)
                                            (("2"
                                              (typepred "index")
                                              (("2"
                                                (expand "every" -1)
                                                (("2"
                                                  (flatten)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert)
                    (("2" (hide -4)
                      (("2" (hide -3)
                        (("2" (typepred "index")
                          (("2" (hide -1) (("2" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("3" (typepred "vals")
                    (("3" (hide -1)
                      (("3" (typepred "vals")
                        (("3" (hide -1)
                          (("3" (typepred "index")
                            (("3" (grind) nil nil)) nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) (("2" (grind) nil nil)) nil)
                 ("3" (typepred "vals") (("3" (grind) nil nil)) nil))
                nil)
               ("2" (assert)
                (("2" (expand " eval" 2 1)
                  (("2" (case "cons?(index)")
                    (("1" (case "cons?(vals)")
                      (("1" (assert)
                        (("1" (lift-if 2)
                          (("1" (split 2)
                            (("1" (flatten)
                              (("1"
                                (inst -4 "m" "cdr(vals)" "cdr(index)")
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "length" -4)
                                    (("1" (propax) nil nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (typepred "index")
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (expand "length" 1)
                                (("2"
                                  (assert)
                                  (("2"
                                    (typepred "index")
                                    (("2"
                                      (expand "every" -1)
                                      (("2" (flatten) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (eval def-decl "monomial" eval_MultPoly nil))
   nil))
 (add_lists_length 0
  (add_lists_length-1 nil 3813939248
   ("" (induct "l1")
    (("1" (skeep) (("1" (grind) nil nil)) nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand "add_lists" 1 1)
          (("2" (lift-if 1)
            (("2" (split 1)
              (("1" (flatten) (("1" (grind) nil nil)) nil)
               ("2" (flatten)
                (("2" (inst -1 "cdr(l2)")
                  (("2" (assert)
                    (("2" (expand "length" 2 1)
                      (("2" (assert)
                        (("2" (replace -1 2) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (add_lists def-decl "list[nat]" list_lemmas nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   nil))
 (add_lists_nth_TCC1 0
  (add_lists_nth_TCC1-2 nil 3813939224
   ("" (skeep)
    (("" (lemma "add_lists_length")
      (("" (inst -1 "l1" "l2")
        (("" (assert) (("" (typepred "i") (("" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((add_lists_length formula-decl nil eval_properties nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (add_lists_nth subtype "eval_properties.i"
    "below[length[nat](add_lists[nat](l1, l2))]"))
  (add_lists_nth_TCC1-1 nil 3813938678 ("" (subtype-tcc) nil nil) nil
   nil
   (add_lists_nth subtype "eval_properties.i"
    "below[length[nat](add_lists[nat](l1, l2))]")))
 (add_lists_nth_TCC2 0
  (add_lists_nth_TCC2-1 nil 3813938678 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (add_lists_nth subtype "eval_properties.i"
    "below[length[nat](l1)]")))
 (add_lists_nth_TCC3 0
  (add_lists_nth_TCC3-1 nil 3813938678 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (add_lists_nth subtype "eval_properties.i"
    "below[length[nat](l2)]")))
 (add_lists_nth 0
  (add_lists_nth-1 nil 3813939197
   ("" (induct "l1")
    (("1" (skeep) (("1" (typepred "i") (("1" (grind) nil nil)) nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (case "i=0")
          (("1" (replace -1)
            (("1" (expand "nth" 1)
              (("1" (expand "add_lists" 1 1)
                (("1" (assert)
                  (("1" (case "l2=null")
                    (("1" (typepred "i") (("1" (grind) nil nil)) nil)
                     ("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand "nth" 2)
            (("2" (assert)
              (("2" (expand "add_lists" 2 1)
                (("2" (case "l2=null")
                  (("1" (typepred "i") (("1" (assert) nil nil)) nil)
                   ("2" (assert)
                    (("2" (assert)
                      (("2" (inst -1 "cdr(l2)" "i-1")
                        (("2" (assert)
                          (("2" (typepred "i")
                            (("2" (hide 4) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skeep) (("3" (typepred "i") (("3" (grind) nil nil)) nil))
        nil))
      nil)
     ("4" (hide 2)
      (("4" (skeep) (("4" (typepred "i") (("4" (grind) nil nil)) nil))
        nil))
      nil)
     ("5" (assert)
      (("5" (hide 2)
        (("5" (skeep)
          (("5" (typepred "i")
            (("5" (lemma "add_lists_length")
              (("5" (inst?) (("5" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((add_lists_length formula-decl nil eval_properties nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (add_lists def-decl "list[nat]" list_lemmas nil))
   nil))
 (member_0_bov 0
  (member_0_bov-1 nil 3813939168
   ("" (induct "index")
    (("1" (assert) (("1" (grind) nil nil)) nil)
     ("2" (skeep)
      (("2" (expand "bov?" 2 1)
        (("2" (expand "member" 1 1)
          (("2" (flatten) (("2" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (bov? def-decl "bool" eval_properties nil)
    (member def-decl "bool" list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   nil))
 (bov_0_lln_TCC1 0
  (bov_0_lln_TCC1-1 nil 3813936404
   ("" (skeep) (("" (grind) nil nil)) nil)
   ((list_length_n def-decl "list[nat]" list_lemmas nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (bov_0_lln subtype
    "list_lemmas[nat].list_length_n(eval_properties.n)"
    "(list_adt[nat].cons?)")))
 (bov_0_lln 0
  (bov_0_lln-1 nil 3813939099
   ("" (skeep)
    (("" (lemma "bov_nth")
      (("" (inst -1 "0" "cdr(list_length_n[nat](n))")
        (("" (assert)
          (("" (hide 2)
            (("" (skeep)
              (("" (expand "list_length_n" 1 1)
                (("" (lemma "add_lists_nth")
                  ((""
                    (inst -1 "(: 1 :) ^ (n - 1)"
                     "list_length_n[nat](n-1)" "k")
                    (("1" (assert)
                      (("1" (replace -1 1)
                        (("1" (lemma "every_nth[number]")
                          (("1" (typepred "list_length_n[nat](n-1)")
                            (("1"
                              (inst -2 "LAMBDA (x: number):
                                 number_field_pred(x) AND real_pred(x)
                             AND rational_pred(x) AND integer_pred(x) AND (x >= 0)"
                               "list_length_n[nat](n-1)")
                              (("1"
                                (assert)
                                (("1"
                                  (inst -2 "k")
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (lemma "one_nth")
                                        (("1"
                                          (inst -1 "n-1" "k")
                                          (("1" (assert) nil nil)
                                           ("2"
                                            (assert)
                                            (("2"
                                              (typepred "k")
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (lemma
                                                   "list_length_n[nat]")
                                                  (("2"
                                                    (inst -1 "n")
                                                    (("2"
                                                      (expand
                                                       "length"
                                                       -1)
                                                      (("2"
                                                        (grind)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (assert)
                      (("2" (typepred "k")
                        (("2" (lemma "list_length_n[nat]")
                          (("2" (inst -1 "n")
                            (("2" (lemma "one_nth_TCC1")
                              (("2"
                                (inst -1 "n-1" "k")
                                (("1"
                                  (assert)
                                  (("1"
                                    (lemma "list_length_n[nat]")
                                    (("1"
                                      (inst-cp -1 "n-1")
                                      (("1"
                                        (expand "length" -4 1)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (case
                                             "k <  length[nat](list_length_n[nat](n - 1))")
                                            (("1"
                                              (expand "min" 1 1)
                                              (("1"
                                                (lift-if 1)
                                                (("1"
                                                  (split 1)
                                                  (("1"
                                                    (flatten)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (assert)
                                  (("2"
                                    (expand "length" -1)
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bov_nth formula-decl nil eval_properties nil)
    (add_lists_nth formula-decl nil eval_properties nil)
    (one_nth_TCC1 subtype-tcc nil eval_properties nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (every_nth formula-decl nil list_props nil)
    (list_length_n formula-decl nil list_lemmas nil)
    (append def-decl "list[T]" list_props nil)
    (add_lists def-decl "list[nat]" list_lemmas nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (one_nth formula-decl nil eval_properties nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (list_length_n def-decl "list[nat]" list_lemmas nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil))
 (sub1_add0_TCC1 0
  (sub1_add0_TCC1-2 nil 3813939075
   ("" (skeep) (("" (grind) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (sub1_add0 subtype "(: 1 :)" "list[nat]"))
  (sub1_add0_TCC1-1 nil 3813938303 ("" (subtype-tcc) nil nil) nil nil
   (sub1_add0 subtype "(: 1 :)" "list[nat]")))
 (sub1_add0_TCC2 0
  (sub1_add0_TCC2-3 nil 3813938779
   ("" (skeep)
    (("" (typepred "l")
      (("" (lemma "every_nth[number]")
        ((""
          (inst -1 "LAMBDA (x: number):
                       number_field_pred(x) AND real_pred(x)
                   AND rational_pred(x) AND integer_pred(x) AND (x >= 0)"
           "l")
          (("" (flatten)
            (("" (assert)
              (("" (hide -2)
                (("" (lemma "bov_nth")
                  ((""
                    (inst -1 "0"
                     "(add_lists[nat](^[nat]((: 1 :), n), l))")
                    (("" (assert)
                      (("" (skeep)
                        (("" (typepred "k")
                          (("" (lemma "add_lists_nth")
                            ((""
                              (inst -1 "(^[nat]((: 1 :), n))" "l" "k")
                              (("1"
                                (replace -1)
                                (("1"
                                  (assert)
                                  (("1"
                                    (inst -3 "k")
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (lemma "one_nth")
                                          (("1"
                                            (inst -1 "n" "k")
                                            (("1" (assert) nil)
                                             ("2"
                                              (assert)
                                              (("2"
                                                (lemma
                                                 "add_lists_length")
                                                (("2"
                                                  (inst?)
                                                  (("2"
                                                    (replace -1 -3)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (replace -10)
                                                        (("2"
                                                          (lemma
                                                           "length_appendn[nat]")
                                                          (("2"
                                                            (inst
                                                             -1
                                                             "(: 1 :)"
                                                             "n")
                                                            (("2"
                                                              (assert)
                                                              (("2"
                                                                (grind)
                                                                nil)))))))))))))))))))))))))))))))))
                               ("2"
                                (assert)
                                (("2"
                                  (lemma "add_lists_length")
                                  (("2"
                                    (inst?)
                                    (("2"
                                      (replace -1)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (lemma "length_appendn[nat]")
                                          (("2"
                                            (inst?)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (grind)
                                                nil))))))))))))))))))))))))))))))))))))))))))))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bov_nth formula-decl nil eval_properties nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (<= const-decl "bool" reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (one_nth formula-decl nil eval_properties nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (length_appendn formula-decl nil more_list_props structures)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_singleton formula-decl nil more_list_props structures)
    (bov? def-decl "bool" eval_properties nil)
    (nth def-decl "T" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (add_lists_length formula-decl nil eval_properties nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (add_lists_nth formula-decl nil eval_properties nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (add_lists def-decl "list[nat]" list_lemmas nil)
    (every_nth formula-decl nil list_props nil))
   nil
   (sub1_add0 subtype
    "list_lemmas[nat].add_lists(more_list_props[nat].^((: 1 :), (eval_properties.n)), eval_properties.l)"
    "{ll: list_adt[nat].list | eval_properties.bov?(0)(ll)}"))
  (sub1_add0_TCC2-2 nil 3813938628
   ("" (skeep)
    (("" (typepred "l")
      (("" (lemma "every_nth[number]")
        ((""
          (inst -1 "LAMBDA (x: number):
                     number_field_pred(x) AND real_pred(x)
                 AND rational_pred(x) AND integer_pred(x) AND (x >= 0)"
           "l")
          (("" (flatten)
            (("" (assert)
              (("" (hide -2)
                (("" (lemma "bov_nth")
                  ((""
                    (inst -1 "0"
                     "(add_lists[nat](^[nat]((: 1 :), n), l))")
                    (("" (assert)
                      (("" (skeep)
                        (("" (typepred "k")
                          (("" (lemma "add_lists_nth")
                            ((""
                              (inst -1 "(^[nat]((: 1 :), n))" "l" "k")
                              (("1"
                                (replace -1)
                                (("1"
                                  (assert)
                                  (("1"
                                    (inst -3 "k")
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (assert)
                                        (("1"
                                          (lemma "one_nth")
                                          (("1"
                                            (inst -1 "n" "k")
                                            (("1" (assert) nil)
                                             ("2"
                                              (assert)
                                              (("2"
                                                (lemma
                                                 "add_lists_length")
                                                (("2"
                                                  (inst?)
                                                  (("2"
                                                    (replace -1 -3)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (replace -10)
                                                        (("2"
                                                          (lemma
                                                           "length_appendn[nat]")
                                                          (("2"
                                                            (inst
                                                             -1
                                                             "(: 1 :)"
                                                             "n")
                                                            (("2"
                                                              (assert)
                                                              (("2"
                                                                (grind)
                                                                nil)))))))))))))))))))))))))))))))))
                               ("2"
                                (assert)
                                (("2"
                                  (lemma "add_lists_length")
                                  (("2"
                                    (inst?)
                                    (("2"
                                      (replace -1)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (lemma "length_appendn[nat]")
                                          (("2"
                                            (inst?)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (grind)
                                                nil))))))))))))))))))))))))))))))))))))))))))))
    nil)
   nil nil
   (sub1_add0 subtype
    "list_lemmas[nat].add_lists(more_list_props[nat].^((: 1 :), (eval_properties.n)), eval_properties.l)"
    "{ll: list_adt[nat].list | eval_properties.bov?(0)(ll)}"))
  (sub1_add0_TCC2-1 nil 3813938303 ("" (subtype-tcc) nil nil) nil nil
   (sub1_add0 subtype
    "list_lemmas[nat].add_lists(more_list_props[nat].^((: 1 :), (eval_properties.n)), eval_properties.l)"
    "{ll: list_adt[nat].list | eval_properties.bov?(0)(ll)}")))
 (sub1_add0 0
  (sub1_add0-1 nil 3813938603
   ("" (induct "n")
    (("1" (skeep)
      (("1" (grind)
        (("1" (expand "sub1" 1 1)
          (("1" (expand "length" -1)
            (("1" (lift-if -1)
              (("1" (split -1)
                (("1" (assert) nil nil)
                 ("2" (flatten) (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand "add_lists" 1 1)
          (("2" (lift-if 1)
            (("2" (split 1)
              (("1" (flatten) (("1" (grind) nil nil)) nil)
               ("2" (flatten)
                (("2" (assert)
                  (("2" (inst -1 "cdr(l)")
                    (("2" (assert)
                      (("2" (expand "length" -2)
                        (("2" (assert)
                          (("2" (expand "^" 2 2)
                            (("2" (expand "append" 2 1)
                              (("2"
                                (expand "append" 2 1)
                                (("2"
                                  (assert)
                                  (("2"
                                    (expand "sub1" 2 1)
                                    (("2"
                                      (decompose-equality 2)
                                      (("1"
                                        (expand "^" 1)
                                        (("1"
                                          (expand "append" 1)
                                          (("1" (propax) nil nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skeep)
        (("3" (lemma "sub1_add0_TCC2")
          (("3" (inst?) (("3" (assert) nil nil)) nil)) nil))
        nil))
      nil)
     ("4" (hide 2) (("4" (skeep) (("4" (grind) nil nil)) nil)) nil))
    nil)
   ((sub1_add0_TCC2 subtype-tcc nil eval_properties nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (append def-decl "list[T]" list_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (list_cons_extensionality formula-decl nil list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (sub1 def-decl "{ll: list[nat] |
   length(ll) = length(l) AND
    FORALL (i: below(length(ll))): nth(ll, i) = nth(l, i) - 1}"
     eval_properties nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (pred type-eq-decl nil defined_types nil)
    (bov? def-decl "bool" eval_properties nil)
    (add_lists def-decl "list[nat]" list_lemmas nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil))
   nil))
 (list_length_n_cdr_TCC1 0
  (list_length_n_cdr_TCC1-2 nil 3813938577
   ("" (lemma "bov_0_lln") (("" (propax) nil nil)) nil)
   ((bov_0_lln formula-decl nil eval_properties nil)) nil
   (list_length_n_cdr subtype
    "list_adt[nat].cdr(list_lemmas[nat].list_length_n(eval_properties.n))"
    "{ll: list_adt[nat].list | eval_properties.bov?(0)(ll)}"))
  (list_length_n_cdr_TCC1-1 nil 3813936404 ("" (subtype-tcc) nil nil)
   nil nil
   (list_length_n_cdr subtype
    "list_adt[nat].cdr(list_lemmas[nat].list_length_n(eval_properties.n))"
    "{ll: list_adt[nat].list | eval_properties.bov?(0)(ll)}")))
 (list_length_n_cdr_TCC2 0
  (list_length_n_cdr_TCC2-1 nil 3813936404 ("" (subtype-tcc) nil nil)
   nil nil
   (list_length_n_cdr subtype "(number_fields.-)(eval_properties.n, 1)"
    "nat")))
 (list_length_n_cdr 0
  (list_length_n_cdr-1 nil 3813938298
   ("" (lemma "sub1_add0")
    (("" (expand "list_length_n[nat]" 1 1)
      (("" (skeep)
        (("" (inst -1 "n-1" "list_length_n[nat](n-1)")
          (("" (assert)
            (("" (lemma "list_length_n[nat]")
              (("" (inst -1 "n-1") (("" (assert) nil))))))))))))))
    nil)
   ((list_length_n def-decl "list[nat]" list_lemmas nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list_length_n formula-decl nil list_lemmas nil)
    (sub1_add0 formula-decl nil eval_properties nil))
   nil))
 (eval_replace_TCC1 0
  (eval_replace_TCC1-1 nil 3813937496 ("" (subtype-tcc) nil nil) nil
   nil
   (eval_replace subtype "eval_properties.vals"
    "{vals: list_adt[real].list | list_props[real].length(vals) = list_props[nat].length(eval_properties.index)}")))
 (eval_replace_TCC2 0
  (eval_replace_TCC2-1 nil 3813937496 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil))
   nil
   (eval_replace subtype "eval_properties.vals"
    "{vals: list_adt[real].list | list_props[real].length(vals) = list_props[nat].length(eval_properties.sub1(eval_properties.index))}")))
 (eval_replace_TCC3 0
  (eval_replace_TCC3-1 nil 3813937496 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil))
   nil
   (eval_replace subtype "eval_properties.m`alpha"
    "(list_adt[nat].cons?)")))
 (eval_replace_TCC4 0
  (eval_replace_TCC4-2 nil 3813938253
   ("" (skeep)
    (("" (lemma "bov_nth")
      (("" (lemma "nth_member[nat]")
        (("" (inst -2 "0" "index")
          (("" (assert)
            (("" (skeep)
              (("" (assert)
                (("" (case "NOT nth(index,k)=0")
                  (("1" (assert) nil nil)
                   ("2" (inst -2 "index" "0" "k")
                    (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((bov_nth formula-decl nil eval_properties nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth_member formula-decl nil more_list_props structures)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil
   (eval_replace subtype "eval_properties.index"
    "{ll: list_adt[nat].list | eval_properties.bov?(0)(ll)}"))
  (eval_replace_TCC4-1 nil 3813937496 ("" (subtype-tcc) nil nil) nil
   nil
   (eval_replace subtype "eval_properties.index"
    "{ll: list_adt[nat].list | eval_properties.bov?(0)(ll)}")))
 (eval_replace 0
  (eval_replace-1 nil 3813937899
   (""
    (case "FORALL (n:nat, m: monomial, vals: list[real],
                                                        index: {l: list[nat] | length(l) = length(vals)}):
                                                  length(index)=n IMPLIES (NOT member[nat](0, index) IMPLIES
                                                   (m`alpha = null OR
                                                     eval(m, index)(vals)`C =
                                                      eval((# C := m`C, alpha := cdr[nat](m`alpha) #), sub1(index))
                                                          (vals)`C))")
    (("1" (skeep)
      (("1" (inst -1 "length(index)" "m" "vals" "index")
        (("1" (assert) nil)))))
     ("2" (hide 2)
      (("2" (induct "n")
        (("1" (skeep)
          (("1" (grind)
            (("1" (typepred "vals")
              (("1" (hide -1)
                (("1" (typepred "index")
                  (("1" (hide -1)
                    (("1" (grind)
                      (("1" (expand "length" -2)
                        (("1" (expand "length" -1)
                          (("1" (lift-if -2)
                            (("1" (split -2)
                              (("1"
                                (lift-if -2)
                                (("1"
                                  (split -2)
                                  (("1" (grind) nil)
                                   ("2"
                                    (flatten)
                                    (("2" (assert) nil)))))))
                               ("2"
                                (flatten)
                                (("2"
                                  (assert)
                                  nil)))))))))))))))))))))))))
         ("2" (skeep)
          (("2" (skeep)
            (("2" (case "j=0")
              (("1" (case "cdr(vals)=null")
                (("1" (case "cdr(index)=null")
                  (("1" (expand "eval" 3 1)
                    (("1" (lift-if 3)
                      (("1" (split 3)
                        (("1" (flatten) (("1" (grind) nil)))
                         ("2" (flatten)
                          (("2" (assert)
                            (("2" (split 2)
                              (("1"
                                (flatten)
                                (("1"
                                  (replace -2)
                                  (("1"
                                    (replace -3)
                                    (("1"
                                      (expand "eval" 1 2)
                                      (("1"
                                        (lift-if 1)
                                        (("1"
                                          (split 1)
                                          (("1"
                                            (flatten)
                                            (("1" (grind) nil)))
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (split 2)
                                              (("1"
                                                (flatten)
                                                (("1"
                                                  (replace -4)
                                                  (("1"
                                                    (grind)
                                                    nil)))))
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (expand "sub1" 1 1)
                                                  (("2"
                                                    (expand
                                                     "length"
                                                     -1
                                                     1)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (case
                                                         "car[real](index) = car[nat](index)")
                                                        (("1"
                                                          (assert)
                                                          nil)
                                                         ("2"
                                                          (propax)
                                                          nil)))))))))))))))))))))))))))
                               ("2"
                                (hide 2)
                                (("2"
                                  (hide -5)
                                  (("2"
                                    (flatten)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (expand "eval" 2 2)
                                        (("2"
                                          (lift-if 2)
                                          (("2"
                                            (split 2)
                                            (("1"
                                              (flatten)
                                              (("1"
                                                (expand "sub1" -1 1)
                                                (("1"
                                                  (expand "length" 2 1)
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (case
                                                       "car[real](index) = car[nat](index)")
                                                      (("1"
                                                        (assert)
                                                        nil)
                                                       ("2"
                                                        (propax)
                                                        nil)))))))))))
                                             ("2"
                                              (hide 1 -4)
                                              (("2"
                                                (reveal +)
                                                (("2"
                                                  (flatten)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (hide 4)
                                                      (("2"
                                                        (replace -1)
                                                        (("2"
                                                          (replace -2)
                                                          (("2"
                                                            (grind)
                                                            (("2"
                                                              (case
                                                               "car[real](index) = car[nat](index)")
                                                              (("1"
                                                                (assert)
                                                                nil)
                                                               ("2"
                                                                (propax)
                                                                nil)))))))))))))))))))))))))))))))))))))))))))))
                   ("2" (hide -3) (("2" (grind) nil)))
                   ("3" (grind) nil)))
                 ("2" (typepred "vals")
                  (("2" (hide -3)
                    (("2" (typepred "index") (("2" (grind) nil)))))))
                 ("3" (typepred "vals")
                  (("3" (hide -1)
                    (("3" (typepred "vals")
                      (("3" (hide -1)
                        (("3" (typepred "index")
                          (("3" (grind) nil)))))))))))))
               ("2" (assert)
                (("2" (expand "eval" 4 1)
                  (("2" (lift-if 4)
                    (("2" (split 4)
                      (("1" (flatten)
                        (("1" (expand "eval" 1 2)
                          (("1" (lift-if 1)
                            (("1" (split 1)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1"
                                    (inst
                                     -3
                                     "m"
                                     "cdr(vals)"
                                     "cdr[nat](index)")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (split -3)
                                        (("1"
                                          (replace -1 1)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (expand "sub1" 1 2)
                                              (("1" (propax) nil)))))))
                                         ("2"
                                          (assert)
                                          (("2"
                                            (expand "member" 3 1)
                                            (("2" (propax) nil)))))
                                         ("3"
                                          (expand "length" -3)
                                          (("3" (propax) nil)))))))
                                     ("2"
                                      (assert)
                                      (("2"
                                        (expand "length" -3)
                                        (("2"
                                          (typepred "index")
                                          (("2"
                                            (expand "length" -2)
                                            (("2"
                                              (propax)
                                              nil)))))))))))))))
                               ("2"
                                (flatten)
                                (("2"
                                  (assert)
                                  (("2"
                                    (expand "sub1" 1 1)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (expand "length" -1 1)
                                        (("2"
                                          (assert)
                                          (("2"
                                            (case
                                             "car[real](index) = car[nat](index)")
                                            (("1" (assert) nil)
                                             ("2"
                                              (propax)
                                              nil)))))))))))))))))))))))
                       ("2" (flatten)
                        (("2" (assert)
                          (("2"
                            (inst -1
                             "(# C := m`C * (car(vals) ^ nth(m`alpha, car[nat](index))),
                                                                alpha := replace(m`alpha, car[nat](index))(0) #)"
                             "cdr(vals)" "cdr[nat](index)")
                            (("1" (assert)
                              (("1"
                                (expand "length" -2)
                                (("1"
                                  (assert)
                                  (("1"
                                    (split -1)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "replace" -1 1)
                                        (("1"
                                          (lift-if -1)
                                          (("1"
                                            (split -1)
                                            (("1" (assert) nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (assert)
                                                nil)))))))))))
                                     ("2"
                                      (expand "eval" 2 2)
                                      (("2"
                                        (lift-if 2)
                                        (("2"
                                          (split 2)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (expand "sub1" -1)
                                              (("1"
                                                (expand "length" 2)
                                                (("1"
                                                  (assert)
                                                  (("1"
                                                    (case
                                                     "car[real](index) = car[nat](index)")
                                                    (("1" (assert) nil)
                                                     ("2"
                                                      (propax)
                                                      nil)))))))))))
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (expand "sub1" 2 1)
                                                (("2"
                                                  (expand "nth" -1 2)
                                                  (("2"
                                                    (lift-if -1)
                                                    (("2"
                                                      (expand
                                                       "member"
                                                       5)
                                                      (("2"
                                                        (flatten)
                                                        (("2"
                                                          (assert)
                                                          (("2"
                                                            (case
                                                             "cdr[nat](replace(m`alpha, car[nat](index))(0)) = replace(cdr[nat](m`alpha), car[nat](sub1(index)))(0)")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (expand
                                                                 "sub1"
                                                                 2
                                                                 2)
                                                                (("1"
                                                                  (assert)
                                                                  (("1"
                                                                    (replace
                                                                     -1
                                                                     2
                                                                     rl)
                                                                    (("1"
                                                                      (propax)
                                                                      nil)))))))))
                                                             ("2"
                                                              (assert)
                                                              (("2"
                                                                (case
                                                                 "car[real](index) = car[nat](index)")
                                                                (("1"
                                                                  (assert)
                                                                  (("1"
                                                                    (expand
                                                                     "^"
                                                                     -2)
                                                                    (("1"
                                                                      (assert)
                                                                      (("1"
                                                                        (lemma
                                                                         "nth_member[nat]")
                                                                        (("1"
                                                                          (inst
                                                                           -1
                                                                           "cdr(index)"
                                                                           "0"
                                                                           "car[nat](index)-1")
                                                                          (("1"
                                                                            (grind)
                                                                            nil)
                                                                           ("2"
                                                                            (grind)
                                                                            nil)))))))))))
                                                                 ("2"
                                                                  (propax)
                                                                  nil)))))))))))))))))))))))))))))
                                     ("3"
                                      (case
                                       "car[real](index) = car[nat](index)")
                                      (("1"
                                        (assert)
                                        (("1" (grind) nil)))
                                       ("2" (propax) nil)))))))))))
                             ("2" (assert)
                              (("2"
                                (typepred "index")
                                (("2"
                                  (expand "length" -2)
                                  (("2"
                                    (propax)
                                    nil)))))))))))))))))))))))))))
         ("3" (assert)
          (("3" (hide 2)
            (("3" (skeep) (("3" (rewrite "member_0_bov") nil)))))))
         ("4" (hide 2) (("4" (skeep) (("4" (assert) nil)))))
         ("5" (hide 2) (("5" (skeep) (("5" (assert) nil)))))))))
     ("3" (hide 2)
      (("3" (skeep)
        (("3" (lemma "member_0_bov")
          (("3" (inst -1 "index") (("3" (assert) nil)))))))))
     ("4" (hide 2) (("4" (skeep) (("4" (assert) nil)))))
     ("5" (hide 2) (("5" (skeep) (("5" (assert) nil))))))
    nil)
   ((member_0_bov formula-decl nil eval_properties nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (^ const-decl "real" exponentiation nil)
    (replace def-decl "list[nat]" eval_MultPoly nil)
    (expt def-decl "real" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth_member formula-decl nil more_list_props structures)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/= const-decl "boolean" notequal nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (member def-decl "bool" list_props nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (eval def-decl "monomial" eval_MultPoly nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (bov? def-decl "bool" eval_properties nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (sub1 def-decl "{ll: list[nat] |
   length(ll) = length(l) AND
    FORALL (i: below(length(ll))): nth(ll, i) = nth(l, i) - 1}"
     eval_properties nil))
   nil))
 (eval_cdr_TCC1 0
  (eval_cdr_TCC1-2 nil 3813937875
   ("" (skeep)
    (("" (assert)
      (("" (lemma "list_length_n[nat]") (("" (inst?) nil nil)) nil))
      nil))
    nil)
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (list_length_n formula-decl nil list_lemmas nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   nil
   (eval_cdr subtype "eval_properties.vals"
    "{vals_1: list_adt[real].list | list_props[real].length(vals_1) = list_props[nat].length(list_lemmas[nat].list_length_n(list_props[real].length(eval_properties.vals)))}"))
  (eval_cdr_TCC1-1 nil 3813935248 ("" (subtype-tcc) nil nil) nil nil
   (eval_cdr subtype "eval_properties.vals"
    "{vals_1: list_adt[real].list | list_props[real].length(vals_1) = list_props[nat].length(list_lemmas[nat].list_length_n(list_props[real].length(eval_properties.vals)))}")))
 (eval_cdr_TCC2 0
  (eval_cdr_TCC2-1 nil 3813935248
   ("" (skeep)
    (("" (lemma "list_length_n[nat]")
      (("" (inst -1 "(length[real](cdr[real](vals)))") nil nil)) nil))
    nil)
   ((nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list_length_n formula-decl nil list_lemmas nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   nil
   (eval_cdr subtype "list_adt[real].cdr(eval_properties.vals)"
    "{vals_1: list_adt[real].list | list_props[real].length(vals_1) = list_props[nat].length(list_lemmas[nat].list_length_n(list_props[real].length(list_adt[real].cdr(eval_properties.vals))))}")))
 (eval_cdr_TCC3 0
  (eval_cdr_TCC3-1 nil 3813935248 ("" (subtype-tcc) nil nil) nil nil
   (eval_cdr subtype "eval_properties.m`alpha"
    "(list_adt[nat].cons?)")))
 (eval_cdr_TCC4 0
  (eval_cdr_TCC4-1 nil 3813935248
   ("" (skeep) (("" (typepred "m") (("" (grind) nil nil)) nil)) nil)
   ((monomial type-eq-decl nil standard_form_mult_poly nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil (eval_cdr subtype "0" "below[length[nat](m`alpha)]")))
 (eval_cdr_TCC5 0
  (eval_cdr_TCC5-1 nil 3813935248 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (/= const-decl "boolean" notequal nil))
   nil
   (eval_cdr subtype "list_props[nat].nth(eval_properties.m`alpha, 0)"
    "{i: integers.int | booleans.OR(list_adt[real].car(eval_properties.vals) /= 0, reals.>=(i, 0))}")))
 (eval_cdr 0
  (eval_cdr-1 nil 3813935253
   ("" (skeep)
    (("" (lemma "eval_replace")
      (("" (expand "eval" 1 1)
        (("" (lift-if 1)
          (("" (split 1)
            (("1" (flatten) (("1" (grind) nil)))
             ("2" (flatten)
              (("2" (assert)
                (("2" (split 2)
                  (("1" (flatten)
                    (("1" (expand "list_length_n[nat]" -1)
                      (("1" (assert) (("1" (grind) nil)))))))
                   ("2" (flatten)
                    (("2" (assert)
                      (("2" (expand "replace" 2 1)
                        (("2" (lift-if 2)
                          (("2" (split 2)
                            (("1" (flatten)
                              (("1"
                                (expand "list_length_n[nat]" 1 1)
                                (("1"
                                  (lift-if 1)
                                  (("1"
                                    (split 1)
                                    (("1"
                                      (flatten)
                                      (("1"
                                        (assert)
                                        (("1" (grind) nil)))))
                                     ("2"
                                      (flatten)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (inst
                                           -2
                                           "((# C := m`C * (car(vals) ^ nth(m`alpha, 0)),
                                            alpha := cons(0, cdr(m`alpha)) #))"
                                           "cdr(vals)"
                                           " cdr[nat](list_length_n[nat](length(vals)))")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (split -2)
                                              (("1"
                                                (replace -1 2)
                                                (("1"
                                                  (lemma
                                                   "list_length_n_cdr")
                                                  (("1"
                                                    (inst? -1)
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (replace -1)
                                                        (("1"
                                                          (expand
                                                           "length"
                                                           2
                                                           1)
                                                          (("1"
                                                            (propax)
                                                            nil)))))))))))))
                                               ("2"
                                                (assert)
                                                (("2"
                                                  (lemma
                                                   "member_nth[nat]")
                                                  (("2"
                                                    (inst?)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (skeep)
                                                        (("2"
                                                          (lemma
                                                           "bov_0_lln")
                                                          (("2"
                                                            (inst
                                                             -1
                                                             "length(vals)")
                                                            (("2"
                                                              (assert)
                                                              (("2"
                                                                (lemma
                                                                 "bov_nth")
                                                                (("2"
                                                                  (inst?)
                                                                  (("2"
                                                                    (assert)
                                                                    (("2"
                                                                      (inst
                                                                       -1
                                                                       "i")
                                                                      (("2"
                                                                        (assert)
                                                                        nil)))))))))))))))))))))))))))))
                                           ("2"
                                            (hide 3)
                                            (("2"
                                              (lemma
                                               "list_length_n[nat]")
                                              (("2"
                                                (inst
                                                 -1
                                                 "length(vals)")
                                                (("2"
                                                  (expand "length" -1)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (lift-if -1)
                                                      (("2"
                                                        (split -1)
                                                        (("1"
                                                          (grind)
                                                          nil)
                                                         ("2"
                                                          (flatten)
                                                          (("2"
                                                            (assert)
                                                            (("2"
                                                              (expand
                                                               "length"
                                                               2
                                                               2)
                                                              (("2"
                                                                (assert)
                                                                nil)))))))))))))))))))))))))))))))))))
                             ("2" (flatten)
                              (("2"
                                (assert)
                                (("2"
                                  (expand "list_length_n[nat]" 1 1)
                                  (("2"
                                    (lift-if 1)
                                    (("2"
                                      (split 1)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (assert)
                                          (("1" (grind) nil)))))
                                       ("2"
                                        (propax)
                                        nil))))))))))))))))))))))))))))))))))))
    nil)
   ((eval_replace formula-decl nil eval_properties nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_length_n_cdr formula-decl nil eval_properties nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (member_nth formula-decl nil more_list_props structures)
    (bov_0_lln formula-decl nil eval_properties nil)
    (below type-eq-decl nil naturalnumbers nil)
    (bov_nth formula-decl nil eval_properties nil)
    (list_length_n formula-decl nil list_lemmas nil)
    (replace def-decl "list[nat]" eval_MultPoly nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil)
    (nth def-decl "T" list_props nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (list_length_n def-decl "list[nat]" list_lemmas nil)
    (eval def-decl "monomial" eval_MultPoly nil))
   nil))
 (hat_TCC1 0
  (hat_TCC1-1 nil 3813935192 ("" (subtype-tcc) nil nil) nil nil
   (hat subtype "eval_properties.m`alpha" "(list_adt[nat].cons?)")))
 (hat_TCC2 0
  (hat_TCC2-1 nil 3813935192
   ("" (skeep) (("" (expand "length" 1 2) (("" (propax) nil nil)) nil))
    nil)
   ((length def-decl "nat" list_props nil)) nil
   (hat subtype
    "(# C := 1, alpha := list_adt[nat].cdr(eval_properties.m`alpha) #)"
    "{mm: standard_form_mult_poly.monomial | list_props[nat].length(mm`alpha) = (number_fields.-)(list_props[nat].length(eval_properties.m`alpha), 1)}")))
 (hat_TCC3 0
  (hat_TCC4-1 nil 3813935192 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (hat subtype "eval_properties.f(eval_properties.x)"
    "(list_adt[real].cons?)")))
 (hat_TCC4 0
  (hat_TCC5-1 nil 3813935192
   ("" (skeep)
    (("" (typepred "f(x)")
      (("" (expand "length" -2) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((VectorN type-eq-decl nil matrices matrices)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (hat subtype
    "list_adt[real].cdr(eval_properties.f(eval_properties.x))"
    "matrices.VectorN((number_fields.-)(eval_properties.n, 1))")))
 (first_TCC1 0
  (first_TCC1-1 nil 3813935192 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (/= const-decl "boolean" notequal nil))
   nil
   (first subtype "list_adt[nat].car(eval_properties.m`alpha)"
          "{i: integers.int | booleans.OR(eval_properties.x /= 0, reals.>=(i, 0))}")))
 (eval_vals_TCC1 0
  (eval_vals_TCC1-1 nil 3813935192 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (eval_vals subtype "eval_properties.vals"
    "(list_adt[real].cons?)")))
 (eval_vals_TCC2 0
  (eval_vals_TCC2-1 nil 3813935192 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (eval_vals subtype "eval_properties.m`alpha"
    "(list_adt[nat].cons?)")))
 (eval_vals_TCC3 0
  (eval_vals_TCC3-1 nil 3813935192 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (> const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (/= const-decl "boolean" notequal nil))
   nil
   (eval_vals subtype "list_adt[nat].car(eval_properties.m`alpha)"
    "{i: integers.int | booleans.OR(list_adt[real].car(eval_properties.vals) /= 0, reals.>=(i, 0))}")))
 (eval_vals_TCC4 0
  (eval_vals_TCC4-1 nil 3813935192
   ("" (skeep)
    (("" (expand "hat" 1)
      (("" (assert)
        (("" (typepred "vals")
          (("" (expand "length" -2) (("" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((hat const-decl
     "{mm: monomial | length(mm`alpha) = length(m`alpha) - 1}"
     eval_properties nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (eval_vals subtype "list_adt[real].cdr(eval_properties.vals)"
    "{l: list_adt[real].list | reals.>=(list_props[real].length(l), list_props[nat].length(eval_properties.hat(eval_properties.m)`alpha))}")))
 (eval_vals 0
  (eval_vals-1 nil 3813935202
   ("" (skeep)
    (("" (expand "full_eval" 1)
      (("" (expand "hat" 1)
        (("" (lemma "eval_cdr")
          (("" (inst -1 "m" "vals")
            (("" (replace -1 1)
              (("" (assert)
                (("" (lemma "eval_monom_const")
                  ((""
                    (inst -1 " m`C
            * car(vals) ^ car[nat](m`alpha)" "cdr(m`alpha)"
                     "list_length_n[nat](length(cdr(vals)))"
                     "cdr(vals)")
                    (("" (assert)
                      (("" (split -1)
                        (("1" (expand "nth" 1 1) (("1" (propax) nil)))
                         ("2" (assert)
                          (("2" (lemma "list_length_n[nat]")
                            (("2" (inst?)
                              (("2"
                                (assert)
                                nil))))))))))))))))))))))))))))
    nil)
   ((full_eval const-decl "real" eval_MultPoly nil)
    (eval_cdr formula-decl nil eval_properties nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (eval_monom_const formula-decl nil eval_properties nil)
    (list_length_n formula-decl nil list_lemmas nil)
    (nth def-decl "T" list_props nil)
    (list_length_n def-decl "list[nat]" list_lemmas nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (hat const-decl
     "{mm: monomial | length(mm`alpha) = length(m`alpha) - 1}"
     eval_properties nil))
   nil))
 (full_eval_recurs_TCC1 0
  (full_eval_recurs_TCC1-1 nil 3813941822
   ("" (skeep)
    (("" (typepred "vals")
      (("" (expand "max_length" -2) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((max_length def-decl "nat" standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (full_eval_recurs subtype "eval_properties.vals"
    "{l: list_adt[real].list | reals.>=(list_props[real].length(l), list_props[nat].length(list_adt[monomial].car(eval_properties.p)`alpha))}")))
 (full_eval_recurs_TCC2 0
  (full_eval_recurs_TCC2-1 nil 3813941822 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (max_length def-decl "nat" standard_form_mult_poly nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (full_eval_recurs subtype "eval_properties.p"
    "(list_adt[monomial].cons?)")))
 (full_eval_recurs_TCC3 0
  (full_eval_recurs_TCC3-1 nil 3813941822
   ("" (skeep)
    (("" (typepred "vals")
      (("" (hide -1)
        (("" (expand "max_length" -1) (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((max_length def-decl "nat" standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil))
   nil
   (full_eval_recurs subtype "eval_properties.vals"
    "{l: list_adt[real].list | reals.>=(list_props[real].length(l), standard_form_mult_poly.max_length(list_adt[monomial].cdr(eval_properties.p)))}")))
 (full_eval_recurs 0
  (full_eval_recurs-1 nil 3813941837
   ("" (induct "p")
    (("1" (skeep) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (assert)
          (("2" (expand "full_eval" 1 1)
            (("2" (expand "sum_C" 1 1)
              (("2" (lift-if 1)
                (("2" (split 1)
                  (("1" (flatten)
                    (("1" (assert) (("1" (grind) nil nil)) nil)) nil)
                   ("2" (flatten)
                    (("2" (assert)
                      (("2" (expand "eval" 2 1)
                        (("2" (inst -1 "vals")
                          (("2" (case "cons2_var=null")
                            (("1" (grind) nil nil)
                             ("2" (assert)
                              (("2"
                                (expand "eval" 3 2)
                                (("2"
                                  (expand "full_eval" -1 1)
                                  (("2"
                                    (replace -1 3)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (expand "full_eval" 3 3)
                                          (("2"
                                            (expand "sum_C" 3)
                                            (("2"
                                              (lift-if 3)
                                              (("2"
                                                (split 3)
                                                (("1"
                                                  (flatten)
                                                  (("1"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (flatten)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skeep)
        (("3" (assert)
          (("3" (typepred "vals") (("3" (grind) nil nil)) nil)) nil))
        nil))
      nil)
     ("4" (hide 2) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil)
     ("5" (hide 2)
      (("5" (skeep)
        (("5" (typepred "vals") (("5" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (sum_C def-decl "real" eval_MultPoly nil)
    (eval def-decl "MultPoly" eval_MultPoly nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (full_eval const-decl "real" eval_MultPoly nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (full_eval def-decl "real" eval_MultPoly nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (max_length def-decl "nat" standard_form_mult_poly nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil))
   nil))
 (eval_canc_car_TCC1 0
  (eval_canc_car_TCC1-1 nil 3814457139 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   nil
   (eval_canc_car subtype "eval_properties.vals"
    "{l: list_adt[real].list | reals.>=(list_props[real].length(l), list_props[nat].length(eval_properties.m1`alpha))}")))
 (eval_canc_car_TCC2 0
  (eval_canc_car_TCC2-1 nil 3814457139 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_plus_real_is_real application-judgement "real" reals nil))
   nil
   (eval_canc_car subtype "eval_properties.vals"
    "{l: list_adt[real].list | reals.>=(list_props[real].length(l), list_props[nat].length(eval_properties.m2`alpha))}")))
 (eval_canc_car 0
  (eval_canc_car-1 nil 3814457185
   (""
    (case "FORALL (A:nat,m1, m2: monomial,
                            vals: list[real]
                                | length(vals) >=
                                   max(length(m1`alpha), length(m2`alpha))):
                      length(m1`alpha) = A IMPLIES ((m1`C + m2`C = 0 AND m1`alpha = m2`alpha) IMPLIES
                       0 = full_eval(m1)(vals) + full_eval(m2)(vals))")
    (("1" (skeep)
      (("1" (inst -1 "length(m1`alpha)" "m1" "m2" "vals")
        (("1" (assert) nil nil)) nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "A")
        (("1" (skeep)
          (("1" (case "m1`alpha=null")
            (("1" (expand "full_eval" 1)
              (("1" (lemma "alpha_null_eval")
                (("1"
                  (inst-cp -1 "m1" "vals"
                   "list_length_n[nat](length(vals))")
                  (("1"
                    (inst-cp -1 "m2" "vals"
                     "list_length_n[nat](length(vals))")
                    (("1" (assert) nil nil)
                     ("2" (assert)
                      (("2" (lemma "list_length_n[nat]")
                        (("2" (inst?) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil)
                   ("2" (lemma "list_length_n[nat]")
                    (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (expand "length" -1) (("2" (assert) nil nil)) nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (lemma "eval_vals")
              (("2" (inst-cp -1 "length(m1`alpha)" "m1" "vals")
                (("1" (replace -2 1)
                  (("1" (inst-cp -1 "length(m2`alpha)" "m2" "vals")
                    (("1" (replace -2)
                      (("1" (assert)
                        (("1" (inst -4 "hat(m1)" "hat(m2)" "cdr(vals)")
                          (("1" (assert)
                            (("1" (expand "hat")
                              (("1" (assert) nil nil)) nil))
                            nil)
                           ("2" (expand "hat" 1)
                            (("2" (assert)
                              (("2"
                                (typepred "vals")
                                (("2"
                                  (expand "length" -2)
                                  (("2"
                                    (assert)
                                    (("2"
                                      (lift-if -2)
                                      (("2"
                                        (split -2)
                                        (("1"
                                          (flatten)
                                          (("1" (assert) nil nil))
                                          nil)
                                         ("2"
                                          (flatten)
                                          (("2"
                                            (assert)
                                            (("2"
                                              (expand "max" -1)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (expand "max" 2)
                                                  (("2"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (expand "length" 1 1)
                      (("2" (lift-if 1)
                        (("2" (split 1)
                          (("1" (flatten)
                            (("1" (replace -6 -4)
                              (("1"
                                (expand "length" -4)
                                (("1" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (hide 2)
          (("3" (skeep)
            (("3" (typepred "vals") (("3" (assert) nil nil)) nil))
            nil))
          nil)
         ("4" (hide 2)
          (("4" (skeep)
            (("4" (assert)
              (("4" (typepred " vals") (("4" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2)
      (("3" (skeep)
        (("3" (typepred "vals") (("3" (assert) nil nil)) nil)) nil))
      nil)
     ("4" (hide 2)
      (("4" (skeep)
        (("4" (typepred "vals") (("4" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((eval_vals formula-decl nil eval_properties nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (hat const-decl
     "{mm: monomial | length(mm`alpha) = length(m`alpha) - 1}"
     eval_properties nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_max application-judgement "{k: posint | i <= k AND j <= k}"
     real_defs nil)
    (posrat_max application-judgement "{s: posrat | s >= q AND s >= r}"
     real_defs nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (list_length_n def-decl "list[nat]" list_lemmas nil)
    (list_length_n formula-decl nil list_lemmas nil)
    (alpha_null_eval formula-decl nil eval_properties nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (full_eval const-decl "real" eval_MultPoly nil))
   shostak))
 (eval_higher_dim_TCC1 0
  (eval_higher_dim_TCC1-1 nil 3859033771 ("" (subtype-tcc) nil nil) nil
   nil
   (eval_higher_dim subtype "eval_properties.i"
    "below[length[real](val1)]")))
 (eval_higher_dim_TCC2 0
  (eval_higher_dim_TCC2-1 nil 3859033771 ("" (subtype-tcc) nil nil) nil
   nil
   (eval_higher_dim subtype "eval_properties.i"
    "below[length[real](val2)]")))
 (eval_higher_dim_TCC3 0
  (eval_higher_dim_TCC3-1 nil 3859450413 ("" (subtype-tcc) nil nil) nil
   nil
   (eval_higher_dim subtype "eval_properties.val1"
    "{l: list_adt[real].list | reals.>=(list_props[real].length(l), list_props[nat].length(eval_properties.m`alpha))}")))
 (eval_higher_dim_TCC4 0
  (eval_higher_dim_TCC3-1 nil 3859033771 ("" (subtype-tcc) nil nil) nil
   nil
   (eval_higher_dim subtype "eval_properties.val2"
    "{l: list_adt[real].list | reals.>=(list_props[real].length(l), list_props[nat].length(eval_properties.m`alpha))}")))
 (eval_higher_dim 0
  (eval_higher_dim-1 nil 3859033771
   (""
    (case "FORALL(a:nat,m: monomial, val1: {v: list[real] | length(v) = length(m`alpha)}, val2:list[real]): length(val1)=a IMPLIES
 full_eval(m)(val1) = full_eval(m)(append(val1,val2))")
    (("1" (skeep)
      (("1"
        (inst -1 "length(val1)" "m" "val1"
         "val2^(length(val1),length(val2)-1)")
        (("1"
          (case "val2 = append(val1, val2 ^ (length(val1), length(val2) - 1))")
          (("1" (assert) nil nil)
           ("2" (lemma "length_append[real]")
            (("2" (inst?)
              (("1" (lemma "caret_length[real]")
                (("1" (inst? -1)
                  (("1" (assert)
                    (("1" (replace -1)
                      (("1" (assert)
                        (("1" (lemma "list_extensionality[real]")
                          (("1" (inst?)
                            (("1" (assert)
                              (("1"
                                (skeep)
                                (("1"
                                  (lemma "nth_append[real]")
                                  (("1"
                                    (inst? -1)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (lift-if -1)
                                        (("1"
                                          (split -1)
                                          (("1"
                                            (flatten)
                                            (("1"
                                              (inst -6 "n")
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (typepred val1)
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (flatten)
                                            (("2"
                                              (lemma "caret_nth[real]")
                                              (("2"
                                                (inst?)
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (typepred val2) (("2" (grind) nil nil)) nil))
                  nil))
                nil)
               ("2" (typepred val2) (("2" (grind) nil nil)) nil))
              nil))
            nil)
           ("3" (typepred val2) (("3" (grind) nil nil)) nil))
          nil)
         ("2" (typepred val2) (("2" (grind) nil nil)) nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (induct a)
        (("1" (skeep)
          (("1" (typepred val1)
            (("1" (case "m`alpha = null")
              (("1" (lemma "alpha_null_eval")
                (("1" (expand full_eval)
                  (("1" (copy -1)
                    (("1" (inst?)
                      (("1" (assert)
                        (("1"
                          (inst -2 "m" "append(val1, val2)"
                           "list_length_n[nat](length(append(val1, val2)))")
                          (("1" (assert) nil nil)
                           ("2" (lemma "list_length_n[nat]")
                            (("2" (inst?) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (lemma "list_length_n[nat]")
                        (("2" (inst?) (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (lemma "eval_vals")
              (("2" (case "m`alpha = null")
                (("1" (lemma "alpha_null_eval")
                  (("1" (copy -1)
                    (("1" (inst?)
                      (("1" (expand full_eval)
                        (("1" (inst? -1)
                          (("1" (assert) nil nil)
                           ("2" (lemma "list_length_n[nat]")
                            (("2" (inst?) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (inst -1 "length(m`alpha)" "m" "_")
                  (("1" (copy -1)
                    (("1" (inst?)
                      (("1" (replace -1)
                        (("1" (inst -2 "append(val1, val2)")
                          (("1" (replace -2)
                            (("1" (lemma "car_append[real]")
                              (("1"
                                (inst?)
                                (("1"
                                  (replace -1)
                                  (("1"
                                    (lemma "cdr_append[real]")
                                    (("1"
                                      (inst?)
                                      (("1"
                                        (replace -1)
                                        (("1"
                                          (expand length -6)
                                          (("1"
                                            (lift-if -6)
                                            (("1"
                                              (split -6)
                                              (("1" (assert) nil nil)
                                               ("2"
                                                (flatten)
                                                (("2"
                                                  (assert)
                                                  (("2"
                                                    (inst
                                                     -6
                                                     "hat(m)"
                                                     "cdr(val1)"
                                                     "val2")
                                                    (("1"
                                                      (assert)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (typepred
                                                       "hat(m)")
                                                      (("2"
                                                        (typepred val1)
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (skeep)
          (("3" (lemma "length_append[real]")
            (("3" (inst?)
              (("3" (typepred val1) (("3" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep)
      (("3" (lemma "length_append[real]")
        (("3" (inst?)
          (("3" (typepred val1) (("3" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((eval_vals formula-decl nil eval_properties nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (car_append formula-decl nil more_list_props structures)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (hat const-decl
     "{mm: monomial | length(mm`alpha) = length(m`alpha) - 1}"
     eval_properties nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (eval def-decl "monomial" eval_MultPoly nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (cdr_append formula-decl nil more_list_props structures)
    (real_times_real_is_real application-judgement "real" reals nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_length_n def-decl "list[nat]" list_lemmas nil)
    (list_length_n formula-decl nil list_lemmas nil)
    (alpha_null_eval formula-decl nil eval_properties nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (list_extensionality formula-decl nil more_list_props structures)
    (nth_append formula-decl nil more_list_props structures)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (caret_nth formula-decl nil more_list_props structures)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (caret_length formula-decl nil more_list_props structures)
    (length_append formula-decl nil list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (> const-decl "bool" reals nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (PRED type-eq-decl nil defined_types nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (full_eval const-decl "real" eval_MultPoly nil)
    (append def-decl "list[T]" list_props nil))
   shostak))
 (eval_higher_dim_poly_TCC1 0
  (eval_higher_dim_poly_TCC1-1 nil 3859461436
   ("" (subtype-tcc) nil nil) nil nil
   (eval_higher_dim_poly subtype "eval_properties.i"
    "below[length[real](val1)]")))
 (eval_higher_dim_poly_TCC2 0
  (eval_higher_dim_poly_TCC2-1 nil 3859464186
   ("" (subtype-tcc) nil nil) nil nil
   (eval_higher_dim_poly subtype "eval_properties.i"
    "below[length[real](val2)]")))
 (eval_higher_dim_poly_TCC3 0
  (eval_higher_dim_poly_TCC3-1 nil 3859461436
   ("" (subtype-tcc) nil nil) nil nil
   (eval_higher_dim_poly subtype "eval_properties.val2"
    "{l: list_adt[real].list | reals.>=(list_props[real].length(l), standard_form_mult_poly.max_length(eval_properties.p))}")))
 (eval_higher_dim_poly 0
  (eval_higher_dim_poly-1 nil 3859461436
   ("" (induct p)
    (("1" (skeep)
      (("1" (expand full_eval) (("1" (propax) nil nil)) nil)) nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (lemma "full_eval_recurs")
          (("2" (inst?)
            (("2" (assert)
              (("2" (lemma "full_eval_recurs")
                (("2" (inst -1 "cons(cons1_var,cons2_var)" "val2")
                  (("2" (assert)
                    (("2" (replace -1)
                      (("2" (replace -2)
                        (("2" (lemma "eval_higher_dim")
                          (("2" (inst -4 "val1" "val2")
                            (("2" (split -4)
                              (("1"
                                (replace -1)
                                (("1"
                                  (both-sides
                                   "-"
                                   "full_eval(cons2_var)(val2)")
                                  (("1"
                                    (assert)
                                    (("1"
                                      (case "cons1_var`alpha = null")
                                      (("1"
                                        (lemma "alpha_null_eval")
                                        (("1"
                                          (expand full_eval 1)
                                          (("1"
                                            (inst?)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (lemma
                                                 "alpha_null_eval")
                                                (("1"
                                                  (inst
                                                   -1
                                                   "cons1_var"
                                                   "val2"
                                                   "list_length_n[nat](length(val2))")
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (lemma
                                                     "list_length_n[nat]")
                                                    (("2"
                                                      (inst?)
                                                      (("2"
                                                        (assert)
                                                        nil
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (lemma
                                               "list_length_n[nat]")
                                              (("2"
                                                (inst?)
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2"
                                        (case
                                         "length(val1) = length(cons1_var`alpha)")
                                        (("1"
                                          (inst
                                           -3
                                           "cons1_var"
                                           "val1"
                                           "val2")
                                          (("1"
                                            (split -3)
                                            (("1" (propax) nil nil)
                                             ("2"
                                              (skeep)
                                              (("2"
                                                (inst -5 "i")
                                                (("2"
                                                  (typepred i)
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil)
                                         ("2"
                                          (typepred val1)
                                          (("2"
                                            (hide -1)
                                            (("2"
                                              (hide -2)
                                              (("2"
                                                (inst
                                                 -2
                                                 "cons1_var"
                                                 "val1^(0,length(cons1_var`alpha)-1)"
                                                 "_")
                                                (("1"
                                                  (copy -2)
                                                  (("1"
                                                    (inst -1 "val1")
                                                    (("1"
                                                      (split -1)
                                                      (("1"
                                                        (inst
                                                         -3
                                                         "val2")
                                                        (("1"
                                                          (split -3)
                                                          (("1"
                                                            (assert)
                                                            nil
                                                            nil)
                                                           ("2"
                                                            (skeep)
                                                            (("2"
                                                              (lemma
                                                               "caret_nth[real]")
                                                              (("2"
                                                                (inst
                                                                 -1
                                                                 "val1"
                                                                 "i"
                                                                 "(0, length(cons1_var`alpha) - 1)")
                                                                (("2"
                                                                  (assert)
                                                                  (("2"
                                                                    (split
                                                                     -1)
                                                                    (("1"
                                                                      (inst
                                                                       -6
                                                                       "i")
                                                                      (("1"
                                                                        (assert)
                                                                        nil
                                                                        nil)
                                                                       ("2"
                                                                        (typepred
                                                                         i)
                                                                        (("2"
                                                                          (grind)
                                                                          nil
                                                                          nil))
                                                                        nil))
                                                                      nil)
                                                                     ("2"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (lemma
                                                           "caret_length[real]")
                                                          (("2"
                                                            (inst
                                                             -1
                                                             "val1"
                                                             "(0, length(cons1_var`alpha) - 1)")
                                                            (("1"
                                                              (assert)
                                                              (("1"
                                                                (split
                                                                 -1)
                                                                (("1"
                                                                  (typepred
                                                                   val2)
                                                                  (("1"
                                                                    (assert)
                                                                    (("1"
                                                                      (grind)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (grind)
                                                                  nil
                                                                  nil)
                                                                 ("3"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil)
                                                             ("2"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil)
                                                       ("2"
                                                        (skeep)
                                                        (("2"
                                                          (lemma
                                                           "caret_nth[real]")
                                                          (("2"
                                                            (inst
                                                             -1
                                                             "val1"
                                                             "i"
                                                             "(0, length(cons1_var`alpha) - 1)")
                                                            (("2"
                                                              (assert)
                                                              (("2"
                                                                (grind)
                                                                nil
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (lemma
                                                       "caret_length[real]")
                                                      (("2"
                                                        (inst?)
                                                        (("1"
                                                          (assert)
                                                          (("1"
                                                            (grind)
                                                            nil
                                                            nil))
                                                          nil)
                                                         ("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("2"
                                                  (lemma
                                                   "caret_length[real]")
                                                  (("2"
                                                    (inst?)
                                                    (("1"
                                                      (grind)
                                                      nil
                                                      nil)
                                                     ("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil)
                                                 ("3" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (skeep)
                                (("2"
                                  (inst -4 "i")
                                  (("2"
                                    (typepred i)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((full_eval_recurs formula-decl nil eval_properties nil)
    (eval_higher_dim formula-decl nil eval_properties nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (full_eval const-decl "real" eval_MultPoly nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_length_n formula-decl nil list_lemmas nil)
    (list_length_n def-decl "list[nat]" list_lemmas nil)
    (alpha_null_eval formula-decl nil eval_properties nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (caret_length formula-decl nil more_list_props structures)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (caret_nth formula-decl nil more_list_props structures)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (IF const-decl "[boolean, T, T -> T]" if_def nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_times_real_is_real application-judgement "real" reals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (eval def-decl "MultPoly" eval_MultPoly nil)
    (sum_C def-decl "real" eval_MultPoly nil)
    (expt def-decl "real" exponentiation nil)
    (^ const-decl "real" exponentiation nil)
    (replace def-decl "list[nat]" eval_MultPoly nil)
    (eval def-decl "monomial" eval_MultPoly nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nzreal_div_nzreal_is_nzreal application-judgement "nzreal"
     real_types nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (full_eval def-decl "real" eval_MultPoly nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (max_length def-decl "nat" standard_form_mult_poly nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil))
   shostak))
 (eval_add_TCC1 0
  (eval_add_TCC1-1 nil 3861703690 ("" (subtype-tcc) nil nil) nil nil
   (eval_add subtype "eval_properties.val"
    "{l: list_adt[real].list | reals.>=(list_props[real].length(l), standard_form_mult_poly.max_length(arithmetic_MultPoly.add(eval_properties.p, eval_properties.q)))}")))
 (eval_add_TCC2 0
  (eval_add_TCC2-1 nil 3861703690 ("" (subtype-tcc) nil nil) nil nil
   (eval_add subtype "eval_properties.val"
    "{l: list_adt[real].list | reals.>=(list_props[real].length(l), standard_form_mult_poly.max_length(eval_properties.p))}")))
 (eval_add_TCC3 0
  (eval_add_TCC3-1 nil 3861703690 ("" (subtype-tcc) nil nil) nil nil
   (eval_add subtype "eval_properties.val"
    "{l: list_adt[real].list | reals.>=(list_props[real].length(l), standard_form_mult_poly.max_length(eval_properties.q))}")))
 (eval_add 0
  (eval_add-1 nil 3861703690
   ("" (induct p)
    (("1" (assert) nil nil)
     ("2" (flatten)
      (("2" (skeep)
        (("2" (expand full_eval 1 2)
          (("2" (expand add)
            (("2" (expand min_add)
              (("2" (lift-if 1)
                (("2" (expand sort_add)
                  (("2" (assert)
                    (("2" (split 1)
                      (("1" (flatten)
                        (("1" (expand sorted_add 1)
                          (("1" (expand max_length 1 1)
                            (("1" (expand lft 1 1)
                              (("1"
                                (assert)
                                (("1"
                                  (expand max_length 1 2)
                                  (("1" (postpone) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (postpone) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (postpone) nil nil) ("4" (postpone) nil nil)
     ("5" (postpone) nil nil) ("6" (postpone) nil nil))
    nil)
   nil shostak)))

