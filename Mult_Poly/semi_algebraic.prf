(semi_algebraic
 (negative_atom_eval_TCC1 0
  (negative_atom_eval_TCC1-1 nil 3810907544
   ("" (skeep)
    (("" (expand negative_atom)
      (("" (typepred "x") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((negative_atom const-decl "atomic_poly" semi_algebraic nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (max_length def-decl "nat" standard_form_mult_poly nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil))
   nil
   (negative_atom_eval subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), standard_form_mult_poly.max_length(semi_algebraic.negative_atom(semi_algebraic.a)`poly))}")))
 (negative_atom_eval 0
  (negative_atom_eval-1 nil 3810907546
   ("" (skeep)
    (("" (skeep)
      (("" (expand negative_atom)
        (("" (lift-if)
          (("" (split)
            (("1" (expand atom_eval)
              (("1" (flatten)
                (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil))
              nil)
             ("2" (flatten)
              (("2" (split)
                (("1" (flatten)
                  (("1" (expand atom_eval)
                    (("1" (replace -1) (("1" (assert) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split)
                    (("1" (flatten)
                      (("1" (expand atom_eval)
                        (("1" (replace -1) (("1" (assert) nil nil))
                          nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (expand atom_eval)
                        (("2" (typepred "a`ineq")
                          (("2" (assert)
                            (("2" (replace -1) (("2" (assert) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (<= const-decl "bool" reals nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (atom_eval const-decl "bool" semi_algebraic nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (negative_atom const-decl "atomic_poly" semi_algebraic nil))
   shostak))
 (atom_max_TCC1 0
  (atom_max_TCC1-1 nil 3810907544 ("" (subtype-tcc) nil nil) nil nil
   (atom_max subtype "semi_algebraic.m"
    "(list_adt[atomic_poly].cons?)")))
 (atom_max_TCC2 0
  (atom_max_TCC2-1 nil 3810907544 ("" (termination-tcc) nil nil)
   ((length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (atom_max termination
    "semi_algebraic.atom_max(list_adt[atomic_poly].cdr(semi_algebraic.m))"
    "nil")))
 (atom_max_max 0
  (atom_max_max-1 nil 3882544064
   ("" (induct "m")
    (("1" (skeep) (("1" (typepred "i") (("1" (grind) nil nil)) nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (case "i=0")
          (("1" (replace -1)
            (("1" (expand "nth" 1)
              (("1" (expand "atom_max" 1 1) (("1" (assert) nil nil))
                nil))
              nil))
            nil)
           ("2" (assert)
            (("2" (expand "nth" 2 1)
              (("2" (expand "atom_max" 2)
                (("2" (inst -1 "i-1") (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (max_length def-decl "nat" standard_form_mult_poly nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (meeting type-eq-decl nil semi_algebraic nil))
   shostak))
 (atom_max_nth 0
  (atom_max_nth-1 nil 3882544111
   ("" (induct "m")
    (("1" (assert) nil nil)
     ("2" (skeep)
      (("2" (split -1)
        (("1" (inst 1 "0")
          (("1" (grind) nil nil)
           ("2" (expand "length" 1) (("2" (assert) nil nil)) nil))
          nil)
         ("2" (skeep)
          (("2" (expand "atom_max" 1 1)
            (("2" (expand "max" 1 1)
              (("2"
                (case " max_length(cons1_var`poly) < atom_max(cons2_var)")
                (("1" (assert)
                  (("1" (inst 1 "i+1")
                    (("1" (expand "nth" 1) (("1" (propax) nil nil))
                      nil)
                     ("2" (typepred "i")
                      (("2" (expand "length" 1)
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (assert)
                  (("2" (inst 2 "0")
                    (("1" (expand "nth" 2) (("1" (propax) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (i skolem-const-decl "below(length(cons2_var))" semi_algebraic nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons1_var skolem-const-decl "atomic_poly" semi_algebraic nil)
    (cons2_var skolem-const-decl "list[atomic_poly]" semi_algebraic
     nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (max_length def-decl "nat" standard_form_mult_poly nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (meeting type-eq-decl nil semi_algebraic nil))
   shostak))
 (max_atom 0
  (max_atom-1 nil 3810907548
   ("" (induct m1)
    (("1" (skeep)
      (("1" (expand append 1)
        (("1" (expand atom_max 1 2)
          (("1" (assert)
            (("1" (expand max)
              (("1" (assert)
                (("1" (lift-if 1)
                  (("1" (split 1)
                    (("1" (propax) nil nil)
                     ("2" (flatten) (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand atom_max 1 1)
          (("2" (lift-if 1)
            (("2" (split)
              (("1" (flatten)
                (("1" (expand append -1) (("1" (propax) nil nil)) nil))
                nil)
               ("2" (flatten)
                (("2" (lemma "car_append[atomic_poly]")
                  (("2" (inst?)
                    (("2" (replace -1)
                      (("2" (hide -1)
                        (("2" (expand atom_max 2 2)
                          (("2" (lemma "cdr_append[atomic_poly]")
                            (("2" (inst?)
                              (("2"
                                (replace -1)
                                (("2"
                                  (assert)
                                  (("2"
                                    (inst?)
                                    (("2"
                                      (replace -2)
                                      (("2"
                                        (assert)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((car_append formula-decl nil more_list_props structures)
    (cdr_append formula-decl nil more_list_props structures)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (append def-decl "list[T]" list_props nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (meeting type-eq-decl nil semi_algebraic nil))
   shostak))
 (meet_TCC1 0
  (meet_TCC1-1 nil 3810907544
   ("" (skeep)
    (("" (typepred "x")
      (("" (expand atom_max) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((atom_max def-decl "nat" semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil))
   nil
   (meet subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), standard_form_mult_poly.max_length(list_adt[atomic_poly].car(semi_algebraic.m)`poly))}")))
 (meet_TCC2 0
  (meet_TCC2-1 nil 3810907544
   ("" (skeep)
    (("" (typepred "x")
      (("" (expand atom_max -2) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((atom_max def-decl "nat" semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil))
   nil
   (meet subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.atom_max(list_adt[atomic_poly].cdr(semi_algebraic.m)))}")))
 (meet_meet_TCC1 0
  (meet_meet_TCC1-1 nil 3810907544
   ("" (skeep)
    (("" (typepred "x")
      (("" (lemma "max_atom")
        (("" (inst?) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((atom_max def-decl "nat" semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max_atom formula-decl nil semi_algebraic nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil))
   nil
   (meet_meet subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.atom_max(list_props[atomic_poly].append(semi_algebraic.m1, semi_algebraic.m2)))}")))
 (meet_meet_TCC2 0
  (meet_meet_TCC2-1 nil 3810907544 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (meet_meet subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.atom_max(semi_algebraic.m1))}")))
 (meet_meet_TCC3 0
  (meet_meet_TCC3-1 nil 3810907544 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (meet_meet subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.atom_max(semi_algebraic.m2))}")))
 (meet_meet 0
  (meet_meet-1 nil 3810907550
   ("" (induct "m1")
    (("1" (skeep)
      (("1" (lemma "append_null_left[atomic_poly]")
        (("1" (inst?)
          (("1" (replace -1)
            (("1" (expand meet 1 2) (("1" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand meet 1 1)
          (("2" (expand append 1 1)
            (("2" (lemma "car_append[atomic_poly]")
              (("2" (inst? -1)
                (("2" (replace -1)
                  (("2" (assert)
                    (("2" (expand meet 1 2)
                      (("2" (lemma "cdr_append[atomic_poly]")
                        (("2" (inst? -1)
                          (("2" (replace -1)
                            (("2" (assert)
                              (("2"
                                (inst -3 "m2" "x")
                                (("1" (grind) nil nil)
                                 ("2"
                                  (typepred "x")
                                  (("2"
                                    (expand atom_max -2 1)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep) (("3" (typepred "x") (("3" (assert) nil nil)) nil))
      nil)
     ("4" (skeep) (("4" (typepred "x") (("4" (assert) nil nil)) nil))
      nil)
     ("5" (skeep)
      (("5" (lemma "max_atom")
        (("5" (inst? -1) (("5" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((max_atom formula-decl nil semi_algebraic nil)
    (car_append formula-decl nil more_list_props structures)
    (atom_eval const-decl "bool" semi_algebraic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (x skolem-const-decl "{x: list[real] |
   length(x) >= max(atom_max(cons(cons1_var, cons2_var)), atom_max(m2))}"
     semi_algebraic nil)
    (m2 skolem-const-decl "meeting" semi_algebraic nil)
    (cons2_var skolem-const-decl "list[atomic_poly]" semi_algebraic
     nil)
    (cons1_var skolem-const-decl "atomic_poly" semi_algebraic nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (cdr_append formula-decl nil more_list_props structures)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (append_null_left formula-decl nil more_list_props structures)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (meet def-decl "bool" semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (append def-decl "list[T]" list_props nil))
   shostak))
 (meet_dim_TCC1 0
  (meet_dim_TCC1-1 nil 3859464403 ("" (subtype-tcc) nil nil) nil nil
   (meet_dim subtype "semi_algebraic.i" "below[length[real](x1)]")))
 (meet_dim_TCC2 0
  (meet_dim_TCC2-1 nil 3859464403 ("" (subtype-tcc) nil nil) nil nil
   (meet_dim subtype "semi_algebraic.i" "below[length[real](x2)]")))
 (meet_dim_TCC3 0
  (meet_dim_TCC1-1 nil 3859463799 ("" (subtype-tcc) nil nil) nil nil
   (meet_dim subtype "semi_algebraic.x2"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.atom_max(semi_algebraic.m))}")))
 (meet_dim 0
  (meet_dim-1 nil 3859463799
   ("" (induct m)
    (("1" (skeep) (("1" (expand "meet") (("1" (propax) nil nil)) nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand meet 1)
          (("2" (inst -1 "x1" "x2")
            (("1" (assert)
              (("1"
                (case "atom_eval(cons1_var)(x1) = atom_eval(cons1_var)(x2)")
                (("1" (assert)
                  (("1" (split -2)
                    (("1" (assert) (("1" (grind) nil nil)) nil)
                     ("2" (skeep)
                      (("2" (inst -2 "i")
                        (("2" (typepred i) (("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide -1)
                  (("2" (hide 2)
                    (("2" (expand "atom_eval")
                      (("2" (lemma "eval_higher_dim_poly")
                        (("2" (inst?)
                          (("2" (split -1)
                            (("1" (assert) nil nil)
                             ("2" (skeep)
                              (("2"
                                (inst -1 "i")
                                (("2"
                                  (typepred i)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("3" (typepred x2)
                  (("3" (typepred x1) (("3" (grind) nil nil)) nil))
                  nil)
                 ("4" (typepred x1) (("4" (grind) nil nil)) nil))
                nil))
              nil)
             ("2" (typepred x1) (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((IF const-decl "[boolean, T, T -> T]" if_def nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (i skolem-const-decl "below(max_length(cons1_var`poly))"
       semi_algebraic nil)
    (eval_higher_dim_poly formula-decl nil eval_properties nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (i skolem-const-decl "below(atom_max(cons2_var))" semi_algebraic
       nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (atom_eval const-decl "bool" semi_algebraic nil)
    (max_length def-decl "nat" standard_form_mult_poly nil)
    (x1 skolem-const-decl
     "{xx: list[real] | length(xx) >= atom_max(cons(cons1_var, cons2_var))}"
     semi_algebraic nil)
    (cons2_var skolem-const-decl "list[atomic_poly]" semi_algebraic
     nil)
    (cons1_var skolem-const-decl "atomic_poly" semi_algebraic nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meet def-decl "bool" semi_algebraic nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (meeting type-eq-decl nil semi_algebraic nil))
   shostak))
 (meet_max_TCC1 0
  (meet_max_TCC1-1 nil 3810907544 ("" (subtype-tcc) nil nil) nil nil
   (meet_max subtype "semi_algebraic.j"
    "(list_adt[semi_algebraic.meeting].cons?)")))
 (meet_max_TCC2 0
  (meet_max_TCC2-1 nil 3810907544 ("" (termination-tcc) nil nil)
   ((length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (meet_max termination
    "semi_algebraic.meet_max(list_adt[semi_algebraic.meeting].cdr(semi_algebraic.j))"
    "nil")))
 (meet_max_nth 0
  (meet_max_nth-1 nil 3882533161
   ("" (induct "j")
    (("1" (skeep) (("1" (typepred "i") (("1" (grind) nil nil)) nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (case "i=0")
          (("1" (expand "nth" 1)
            (("1" (assert)
              (("1" (expand "meet_max" 1 1) (("1" (assert) nil nil))
                nil))
              nil))
            nil)
           ("2" (inst -1 "i-1")
            (("1" (expand "nth" 2)
              (("1" (assert)
                (("1" (expand "meet_max" 2) (("1" (assert) nil nil))
                  nil))
                nil))
              nil)
             ("2" (typepred "i") (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (i skolem-const-decl "below(length(cons(cons1_var, cons2_var)))"
       semi_algebraic nil)
    (cons2_var skolem-const-decl "list[meeting]" semi_algebraic nil)
    (cons1_var skolem-const-decl "meeting" semi_algebraic nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (joining type-eq-decl nil semi_algebraic nil))
   shostak))
 (meet_max_nth_e 0
  (meet_max_nth_e-1 nil 3882533267
   ("" (induct "j")
    (("1" (assert) nil nil)
     ("2" (skeep)
      (("2" (split -1)
        (("1" (inst 1 "0")
          (("1" (grind) nil nil)
           ("2" (expand "length" 1) (("2" (assert) nil nil)) nil))
          nil)
         ("2" (skeep)
          (("2" (expand "meet_max" 1 1)
            (("2" (expand "max" 1 1)
              (("2" (case " atom_max(cons1_var) < meet_max(cons2_var)")
                (("1" (assert)
                  (("1" (inst 1 "i+1")
                    (("1" (expand "nth" 1 1) (("1" (propax) nil nil))
                      nil)
                     ("2" (typepred "i") (("2" (grind) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (assert)
                  (("2" (inst 2 "0")
                    (("1" (expand "nth" 2) (("1" (propax) nil nil))
                      nil)
                     ("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (i skolem-const-decl "below(length(cons2_var))" semi_algebraic nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons1_var skolem-const-decl "meeting" semi_algebraic nil)
    (cons2_var skolem-const-decl "list[meeting]" semi_algebraic nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (joining type-eq-decl nil semi_algebraic nil))
   shostak))
 (max_meet 0
  (max_meet-1 nil 3810907553
   ("" (induct "j1")
    (("1" (expand append)
      (("1" (expand meet_max 1 2) (("1" (grind) nil nil)) nil)) nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand meet_max 1 2)
          (("2" (expand meet_max 1 1)
            (("2" (lift-if 1)
              (("2" (typepred "cons(cons1_var,cons2_var)")
                (("2" (assert)
                  (("2" (expand append 1)
                    (("2" (inst?) (("2" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (append def-decl "list[T]" list_props nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (joining type-eq-decl nil semi_algebraic nil))
   shostak))
 (meet_max_zero 0
  (meet_max_zero-1 nil 3860230264
   ("" (induct "j")
    (("" (skeep)
      (("" (assert)
        (("" (skeep)
          (("" (case "meet_max(cons2_var)=0")
            (("1" (assert)
              (("1" (assert)
                (("1" (split -2)
                  (("1" (skeep)
                    (("1" (typepred "i")
                      (("1" (expand "length" -1)
                        (("1" (expand "length" -1)
                          (("1" (expand "length" -1)
                            (("1" (assert)
                              (("1"
                                (expand "nth" 2)
                                (("1"
                                  (assert)
                                  (("1"
                                    (expand "nth" 3 2)
                                    (("1"
                                      (assert)
                                      (("1"
                                        (expand "meet_max" -4 1)
                                        (("1"
                                          (lemma "atom_max_max")
                                          (("1"
                                            (assert)
                                            (("1"
                                              (inst -1 "cons1_var" "n")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skeep)
                    (("2" (case "i=0")
                      (("1" (expand "nth" 3 2)
                        (("1" (assert)
                          (("1" (expand "nth" 2)
                            (("1" (assert)
                              (("1"
                                (expand "meet_max" -4)
                                (("1"
                                  (lemma "atom_max_max")
                                  (("1"
                                    (inst -1 "cons1_var" "n")
                                    (("1" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (expand "nth" 4 2)
                        (("2" (assert)
                          (("2" (inst -1 "i-1")
                            (("2" (assert)
                              (("2"
                                (expand "nth" 3)
                                (("2"
                                  (assert)
                                  (("2" (inst -1 "n") nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert)
              (("2" (expand "meet_max" -2 1) (("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (atom_max_max formula-decl nil semi_algebraic nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (max_length def-decl "nat" standard_form_mult_poly nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (joining type-eq-decl nil semi_algebraic nil))
   shostak))
 (join_TCC1 0
  (join_TCC1-1 nil 3810907544
   ("" (skeep)
    (("" (typepred "x")
      (("" (expand meet_max -2) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((meet_max def-decl "nat" semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil))
   nil
   (join subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.atom_max(list_adt[semi_algebraic.meeting].car(semi_algebraic.j)))}")))
 (join_TCC2 0
  (join_TCC2-1 nil 3810907544
   ("" (skeep)
    (("" (typepred "x")
      (("" (expand meet_max -2) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((meet_max def-decl "nat" semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil))
   nil
   (join subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.meet_max(list_adt[semi_algebraic.meeting].cdr(semi_algebraic.j)))}")))
 (join_composed_null 0
  (join_composed_null-1 nil 3866896390
   ("" (induct j)
    (("1" (grind) nil nil)
     ("2" (skeep)
      (("2" (split)
        (("1" (inst -2 "0")
          (("1" (expand nth -2 (1 3))
            (("1" (split)
              (("1" (expand join (1 2))
                (("1" (expand meet (1 2)) (("1" (assert) nil nil))
                  nil))
                nil)
               ("2" (skeep 1)
                (("2" (expand join 1)
                  (("2" (inst -2 "x") (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil)
         ("2" (inst -2 "0")
          (("1" (expand nth -2 (1 3))
            (("1" (split)
              (("1" (expand join (1 2))
                (("1" (expand meet (1 2)) (("1" (assert) nil nil))
                  nil))
                nil)
               ("2"
                (case "FORALL(m:meeting): (FORALL(n:below(length(m))): max_length(nth(m,n)`poly)=0) IMPLIES (FORALL(x:list[real]|length(x )>=atom_max(m)): meet(m)(x) = FALSE) OR (FORALL(x:list[real]|length(x)>=atom_max(m)): meet(m)(x) = TRUE)")
                (("1" (inst -1 "cons1_var")
                  (("1" (split)
                    (("1" (expand join 2)
                      (("1" (skeep 2)
                        (("1" (inst -1 "x")
                          (("1" (inst -3 "x")
                            (("1" (assert) nil nil)
                             ("2" (typepred x)
                              (("2"
                                (expand meet_max -2)
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred x)
                            (("2" (expand meet_max -2)
                              (("2" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (skeep 1)
                      (("2" (expand join 1)
                        (("2" (inst -1 "x")
                          (("2" (inst -3 "x") (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("3" (skeep)
                      (("3" (inst -1 "n") (("3" (grind) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (hide 2 3 -1 -2)
                  (("2" (induct m)
                    (("1" (flatten) (("1" (grind) nil nil)) nil)
                     ("2" (skeep)
                      (("2" (copy -2)
                        (("2" (inst -3 "0")
                          (("1" (expand nth -3)
                            (("1" (expand meet (1 2))
                              (("1"
                                (expand atom_eval (1 2))
                                (("1"
                                  (case
                                   "FORALL(p:MultPoly): max_length(p) =0 IMPLIES EXISTS(a:real): FORALL(x:list[real]|length(x)>=max_length(p)): full_eval(p)(x) = a")
                                  (("1"
                                    (inst -1 "cons1_var!1`poly")
                                    (("1"
                                      (assert)
                                      (("1"
                                        (skeep -1)
                                        (("1"
                                          (copy -1)
                                          (("1"
                                            (split -4)
                                            (("1"
                                              (skeep 1)
                                              (("1"
                                                (inst -1 "x")
                                                nil
                                                nil))
                                              nil)
                                             ("2"
                                              (skeep*)
                                              (("2"
                                                (copy -1)
                                                (("2"
                                                  (inst? -1)
                                                  (("2"
                                                    (inst -2 "x!1")
                                                    (("1"
                                                      (assert)
                                                      (("1"
                                                        (inst -3 "x")
                                                        (("1"
                                                          (replace -3)
                                                          (("1"
                                                            (inst
                                                             -4
                                                             "x!1")
                                                            (("1"
                                                              (assert)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil)
                                                     ("2"
                                                      (typepred "x!1")
                                                      (("2"
                                                        (expand
                                                         atom_max
                                                         -2)
                                                        (("2"
                                                          (assert)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("3"
                                              (skeep)
                                              (("3"
                                                (inst -3 "n+1")
                                                (("1"
                                                  (expand nth -3)
                                                  (("1"
                                                    (propax)
                                                    nil
                                                    nil))
                                                  nil)
                                                 ("2" (grind) nil nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (hide 2 3 -1 -2 -3)
                                    (("2"
                                      (induct p)
                                      (("1" (grind) nil nil)
                                       ("2"
                                        (skeep)
                                        (("2"
                                          (expand max_length -2)
                                          (("2"
                                            (split)
                                            (("1"
                                              (skeep)
                                              (("1"
                                                (lemma
                                                 "full_eval_recurs")
                                                (("1"
                                                  (inst
                                                   -1
                                                   "cons(cons1_var!2, cons2_var!2)"
                                                   "_")
                                                  (("1"
                                                    (assert)
                                                    (("1"
                                                      (expand
                                                       full_eval
                                                       -1
                                                       2)
                                                      (("1"
                                                        (lemma
                                                         "alpha_null_eval")
                                                        (("1"
                                                          (inst
                                                           -1
                                                           "cons1_var!2"
                                                           "_"
                                                           "_")
                                                          (("1"
                                                            (inst
                                                             1
                                                             "cons1_var!2`C + a")
                                                            (("1"
                                                              (skeep)
                                                              (("1"
                                                                (inst
                                                                 -3
                                                                 "x")
                                                                (("1"
                                                                  (inst
                                                                   -2
                                                                   "x")
                                                                  (("1"
                                                                    (inst?
                                                                     -1)
                                                                    (("1"
                                                                      (assert)
                                                                      (("1"
                                                                        (grind)
                                                                        (("1"
                                                                          (lemma
                                                                           "list_length_n[nat]")
                                                                          (("1"
                                                                            (inst?)
                                                                            (("1"
                                                                              (assert)
                                                                              nil
                                                                              nil))
                                                                            nil))
                                                                          nil)
                                                                         ("2"
                                                                          (rewrite
                                                                           "list_length_n")
                                                                          (("2"
                                                                            (hide
                                                                             2
                                                                             3)
                                                                            (("2"
                                                                              (lemma
                                                                               "list_length_n[nat]")
                                                                              (("2"
                                                                                (inst
                                                                                 -1
                                                                                 "length(x)")
                                                                                (("2"
                                                                                  (expand
                                                                                   "list_length_n"
                                                                                   -1)
                                                                                  (("2"
                                                                                    (assert)
                                                                                    (("2"
                                                                                      (replace
                                                                                       -1
                                                                                       1
                                                                                       rl)
                                                                                      (("2"
                                                                                        (propax)
                                                                                        nil
                                                                                        nil))
                                                                                      nil))
                                                                                    nil))
                                                                                  nil))
                                                                                nil))
                                                                              nil))
                                                                            nil))
                                                                          nil))
                                                                        nil))
                                                                      nil))
                                                                    nil))
                                                                  nil)
                                                                 ("2"
                                                                  (typepred
                                                                   x)
                                                                  (("2"
                                                                    (expand
                                                                     max_length
                                                                     -2)
                                                                    (("2"
                                                                      (assert)
                                                                      nil
                                                                      nil))
                                                                    nil))
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil)
                                             ("2"
                                              (expand max -1)
                                              (("2"
                                                (lift-if)
                                                (("2"
                                                  (split)
                                                  (("1"
                                                    (flatten)
                                                    nil
                                                    nil)
                                                   ("2"
                                                    (flatten)
                                                    (("2"
                                                      (assert)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (grind) nil nil))
          nil)
         ("3" (skeep)
          (("3" (inst -1 "i+1")
            (("1" (split)
              (("1" (expand nth -1) (("1" (propax) nil nil)) nil)
               ("2" (skeep)
                (("2" (inst -1 "n")
                  (("1" (expand nth -1 2) (("1" (propax) nil nil)) nil)
                   ("2" (expand nth 1) (("2" (assert) nil nil)) nil))
                  nil))
                nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((joining type-eq-decl nil semi_algebraic nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (max_length def-decl "nat" standard_form_mult_poly nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (join def-decl "bool" semi_algebraic nil)
    (TRUE const-decl "bool" booleans nil)
    (FALSE const-decl "bool" booleans nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (list_induction formula-decl nil list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (meet def-decl "bool" semi_algebraic nil)
    (cons2_var skolem-const-decl "list[meeting]" semi_algebraic nil)
    (cons1_var skolem-const-decl "meeting" semi_algebraic nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (x skolem-const-decl
     "{x: list[real] | length(x) >= meet_max(cons(cons1_var, cons2_var))}"
     semi_algebraic nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (n skolem-const-decl "below(length(cons1_var))" semi_algebraic nil)
    (atom_eval const-decl "bool" semi_algebraic nil)
    (full_eval_recurs formula-decl nil eval_properties nil)
    (alpha_null_eval formula-decl nil eval_properties nil)
    (real_plus_real_is_real application-judgement "real" reals nil)
    (cons1_var!2 skolem-const-decl "monomial" semi_algebraic nil)
    (cons2_var!2 skolem-const-decl "list[monomial]" semi_algebraic nil)
    (x skolem-const-decl
     "{x: list[real] | length(x) >= max_length(cons(cons1_var!2, cons2_var!2))}"
     semi_algebraic nil)
    (full_eval const-decl "real" eval_MultPoly nil)
    (sum_C def-decl "real" eval_MultPoly nil)
    (eval def-decl "MultPoly" eval_MultPoly nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (list_length_n def-decl "list[nat]" list_lemmas nil)
    (list_length_n formula-decl nil list_lemmas nil)
    (x!1 skolem-const-decl
     "{x: list[real] | length(x) >= atom_max(cons(cons1_var!1, cons2_var!1))}"
     semi_algebraic nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (n skolem-const-decl "below(length(cons2_var!1))" semi_algebraic
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (full_eval def-decl "real" eval_MultPoly nil)
    (cons2_var!1 skolem-const-decl "list[atomic_poly]" semi_algebraic
     nil)
    (cons1_var!1 skolem-const-decl "atomic_poly" semi_algebraic nil)
    (i skolem-const-decl "below(length(cons2_var))" semi_algebraic nil)
    (n skolem-const-decl "below(length(nth(cons2_var, i)))"
     semi_algebraic nil))
   shostak))
 (join_dim_TCC1 0
  (join_dim_TCC1-1 nil 3859464667 ("" (subtype-tcc) nil nil) nil nil
   (join_dim subtype "semi_algebraic.i" "below[length[real](x1)]")))
 (join_dim_TCC2 0
  (join_dim_TCC2-1 nil 3859464667 ("" (subtype-tcc) nil nil) nil nil
   (join_dim subtype "semi_algebraic.i" "below[length[real](x2)]")))
 (join_dim_TCC3 0
  (join_dim_TCC3-1 nil 3859464667 ("" (subtype-tcc) nil nil) nil nil
   (join_dim subtype "semi_algebraic.x2"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.meet_max(semi_algebraic.j))}")))
 (join_dim 0
  (join_dim-1 nil 3859464681
   ("" (induct j)
    (("1" (skeep) (("1" (grind) nil nil)) nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand join 1)
          (("2" (inst -1 "x1" "x2")
            (("2" (split -1)
              (("1" (case "meet(cons1_var)(x1) =meet(cons1_var)(x2)")
                (("1" (grind) nil nil)
                 ("2" (hide 2)
                  (("2" (hide -1)
                    (("2" (lemma "meet_dim")
                      (("2" (inst?)
                        (("2" (split -1)
                          (("1" (propax) nil nil)
                           ("2" (skeep)
                            (("2" (inst -1 "i")
                              (("2"
                                (typepred i)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (skeep)
                (("2" (inst -1 "i")
                  (("2" (typepred i) (("2" (grind) nil nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((meet_dim formula-decl nil semi_algebraic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cons1_var skolem-const-decl "meeting" semi_algebraic nil)
    (i skolem-const-decl "below(atom_max(cons1_var))" semi_algebraic
       nil)
    (cons2_var skolem-const-decl "list[meeting]" semi_algebraic nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (meet def-decl "bool" semi_algebraic nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (i skolem-const-decl "below(meet_max(cons2_var))" semi_algebraic
       nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (join def-decl "bool" semi_algebraic nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (joining type-eq-decl nil semi_algebraic nil))
   shostak))
 (max_append_to_each 0
  (max_append_to_each-1 nil 3810907555
   ("" (induct "L")
    (("1" (assert) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand append_to_each 1)
          (("2" (expand meet_max 1 1)
            (("2" (lemma "max_atom")
              (("2" (inst?)
                (("2" (replace -1)
                  (("2" (hide -1)
                    (("2" (expand meet_max 1 2)
                      (("2" (inst?)
                        (("2" (case "cons2_var = null")
                          (("1" (replace -1)
                            (("1" (expand append_to_each 1)
                              (("1"
                                (expand meet_max 1)
                                (("1" (grind) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (assert)
                            (("2" (replace -1) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max_atom formula-decl nil semi_algebraic nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (append_to_each def-decl "joining" semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (joining type-eq-decl nil semi_algebraic nil))
   shostak))
 (append_join_TCC1 0
  (append_join_TCC1-1 nil 3810907544
   ("" (skeep)
    (("" (lemma "max_append_to_each")
      (("" (inst?)
        (("" (case "L = null")
          (("1" (replace -1)
            (("1" (expand append_to_each)
              (("1" (typepred "x")
                (("1" (expand meet_max -2)
                  (("1" (assert)
                    (("1" (assert)
                      (("1" (expand meet_max 1)
                        (("1" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((max_append_to_each formula-decl nil semi_algebraic nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (append_to_each def-decl "joining" semi_algebraic nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (list type-decl nil list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil))
   nil
   (append_join subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.meet_max(semi_algebraic.append_to_each(semi_algebraic.m, semi_algebraic.L)))}")))
 (append_join_TCC2 0
  (append_join_TCC2-1 nil 3810907544 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (append_join subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.atom_max(semi_algebraic.m))}")))
 (append_join_TCC3 0
  (append_join_TCC3-1 nil 3810907544 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (append_join subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.meet_max(semi_algebraic.L))}")))
 (append_join 0
  (append_join-1 nil 3810907559
   ("" (induct "L")
    (("1" (skeep)
      (("1" (expand append_to_each)
        (("1" (expand join) (("1" (propax) nil nil)) nil)) nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand append_to_each 1)
          (("2" (expand join 1 1)
            (("2" (expand join 1 2)
              (("2" (inst -1 "m" "x")
                (("1" (lemma "meet_meet")
                  (("1" (inst? -1)
                    (("1" (replace -1)
                      (("1" (replace -2) (("1" (grind) nil nil)) nil))
                      nil)
                     ("2" (typepred "x")
                      (("2" (hide -1)
                        (("2" (hide -2)
                          (("2" (expand meet_max -1)
                            (("2" (assert) (("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ("2" (typepred "x")
                  (("2" (expand meet_max -2) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep) (("3" (typepred "x") (("3" (assert) nil nil)) nil))
      nil)
     ("4" (skeep) (("4" (typepred "x") (("4" (assert) nil nil)) nil))
      nil)
     ("5" (skeep)
      (("5" (typepred "x")
        (("5" (lemma "max_append_to_each")
          (("5" (inst?)
            (("5" (case "L=null")
              (("1" (expand append_to_each 1) (("1" (assert) nil nil))
                nil)
               ("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max_append_to_each formula-decl nil semi_algebraic nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (meet_meet formula-decl nil semi_algebraic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (x skolem-const-decl "{x: list[real] |
   length(x) >= max(atom_max(m), meet_max(cons(cons1_var, cons2_var)))}"
     semi_algebraic nil)
    (cons2_var skolem-const-decl "list[meeting]" semi_algebraic nil)
    (cons1_var skolem-const-decl "meeting" semi_algebraic nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (m skolem-const-decl "meeting" semi_algebraic nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (join def-decl "bool" semi_algebraic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (meet def-decl "bool" semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (append_to_each def-decl "joining" semi_algebraic nil))
   shostak))
 (max_cap_join 0
  (max_cap_join-1 nil 3810907564
   ("" (induct j1)
    (("1" (skeep) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (case "cons2_var = null")
          (("1" (replace -1)
            (("1" (expand cap_join 1)
              (("1" (assert)
                (("1" (expand cap_join 1)
                  (("1" (expand meet_max 1 2)
                    (("1" (expand meet_max 1 2)
                      (("1" (expand max 1 2)
                        (("1" (assert)
                          (("1" (lift-if 1)
                            (("1" (assert)
                              (("1"
                                (lemma "max_meet")
                                (("1"
                                  (inst? -1)
                                  (("1"
                                    (replace -1)
                                    (("1"
                                      (expand meet_max 1 2)
                                      (("1"
                                        (lemma "max_append_to_each")
                                        (("1"
                                          (inst? -1)
                                          (("1"
                                            (assert)
                                            (("1"
                                              (replace -1)
                                              (("1" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (expand cap_join 2)
            (("2" (assert)
              (("2" (lemma "max_meet")
                (("2" (inst? -1)
                  (("2" (replace -1)
                    (("2" (lemma "max_append_to_each")
                      (("2" (inst? -1)
                        (("2" (assert)
                          (("2" (replace -1)
                            (("2" (hide -1)
                              (("2"
                                (hide -1)
                                (("2"
                                  (expand meet_max 2 3)
                                  (("2"
                                    (inst -1 "j2")
                                    (("2"
                                      (assert)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (append_to_each def-decl "joining" semi_algebraic nil)
    (append def-decl "list[T]" list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (max_append_to_each formula-decl nil semi_algebraic nil)
    (max_meet formula-decl nil semi_algebraic nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (cap_join def-decl "joining" semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (joining type-eq-decl nil semi_algebraic nil))
   shostak))
 (union_join_TCC1 0
  (union_join_TCC1-1 nil 3810907544 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (union_join subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.meet_max(semi_algebraic.j1))}")))
 (union_join_TCC2 0
  (union_join_TCC2-1 nil 3810907544 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (union_join subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.meet_max(semi_algebraic.j2))}")))
 (union_join_TCC3 0
  (union_join_TCC3-1 nil 3810907544
   ("" (skeep)
    (("" (typepred "x")
      (("" (lemma "max_meet")
        (("" (inst?) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((meet_max def-decl "nat" semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max_meet formula-decl nil semi_algebraic nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil))
   nil
   (union_join subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.meet_max(list_props[semi_algebraic.meeting].append(semi_algebraic.j1, semi_algebraic.j2)))}")))
 (union_join 0
  (union_join-1 nil 3810907574
   ("" (induct "j1")
    (("1" (skeep)
      (("1" (lemma "append_null_left[meeting]")
        (("1" (inst?)
          (("1" (replace -1)
            (("1" (expand join 1 1) (("1" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand join 1 1)
          (("2" (expand join 1 3)
            (("2" (expand append 1 1)
              (("2" (lemma "car_append[meeting]")
                (("2" (inst?)
                  (("2" (replace -1)
                    (("2" (assert)
                      (("2" (lemma "cdr_append[meeting]")
                        (("2" (inst?)
                          (("2" (replace -1)
                            (("2" (assert)
                              (("2"
                                (typepred "x")
                                (("2"
                                  (expand meet_max -2 1)
                                  (("2"
                                    (inst -5 "j2" "x")
                                    (("1" (grind) nil nil)
                                     ("2"
                                      (assert)
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep)
      (("3" (typepred "x")
        (("3" (lemma "max_meet")
          (("3" (inst?)
            (("3" (replace -1) (("3" (propax) nil nil)) nil)) nil))
          nil))
        nil))
      nil)
     ("4" (skeep) (("4" (typepred "x") (("4" (assert) nil nil)) nil))
      nil)
     ("5" (skeep) (("5" (typepred "x") (("5" (assert) nil nil)) nil))
      nil))
    nil)
   ((max_meet formula-decl nil semi_algebraic nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (x skolem-const-decl "{x: list[real] |
   length(x) >= max(meet_max(cons(cons1_var, cons2_var)), meet_max(j2))}"
     semi_algebraic nil)
    (j2 skolem-const-decl "joining" semi_algebraic nil)
    (cons2_var skolem-const-decl "list[meeting]" semi_algebraic nil)
    (cons1_var skolem-const-decl "meeting" semi_algebraic nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (cdr_append formula-decl nil more_list_props structures)
    (car_append formula-decl nil more_list_props structures)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (append_null_left formula-decl nil more_list_props structures)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (append def-decl "list[T]" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (join def-decl "bool" semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (meet_max def-decl "nat" semi_algebraic nil))
   shostak))
 (intersect_join_TCC1 0
  (intersect_join_TCC1-1 nil 3810907544 ("" (subtype-tcc) nil nil)
   ((listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (intersect_join subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.meet_max(semi_algebraic.j2))}")))
 (intersect_join_TCC2 0
  (intersect_join_TCC2-1 nil 3810907544
   ("" (skeep)
    (("" (typepred "x")
      (("" (hide -1)
        (("" (case "j1 = null")
          (("1" (expand cap_join 1) (("1" (assert) nil nil)) nil)
           ("2" (case "j2 = null")
            (("1" (expand cap_join) (("1" (assert) nil nil)) nil)
             ("2" (lemma "max_cap_join")
              (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((meet_max def-decl "nat" semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (cap_join def-decl "joining" semi_algebraic nil)
    (max_cap_join formula-decl nil semi_algebraic nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil))
   nil
   (intersect_join subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.meet_max(semi_algebraic.cap_join(semi_algebraic.j1, semi_algebraic.j2)))}")))
 (intersect_join 0
  (intersect_join-1 nil 3810907577
   ("" (induct "j1")
    (("1" (expand cap_join)
      (("1" (expand join) (("1" (propax) nil nil)) nil)) nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand cap_join 1)
          (("2" (assert)
            (("2" (lift-if)
              (("2" (split 1)
                (("1" (flatten)
                  (("1" (expand join 1)
                    (("1" (flatten) (("1" (assert) nil nil)) nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (expand join 2 1)
                    (("2" (lemma "union_join")
                      (("2"
                        (inst -1 "append_to_each(cons1_var, j2)"
                         "cap_join(cons2_var, j2)" "x")
                        (("1" (inst -2 "j2" "x")
                          (("1" (lemma "append_join")
                            (("1" (inst -1 "cons1_var" "j2" "x")
                              (("1"
                                (replace -1)
                                (("1" (grind) nil nil))
                                nil)
                               ("2"
                                (hide -1)
                                (("2"
                                  (hide -1)
                                  (("2"
                                    (typepred "x")
                                    (("2"
                                      (hide -1)
                                      (("2"
                                        (expand meet_max -1 1)
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (hide -1)
                            (("2" (typepred "x")
                              (("2"
                                (expand meet_max -2 1)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (hide -1)
                          (("2" (typepred "x")
                            (("2" (hide -1)
                              (("2"
                                (expand meet_max -1 1)
                                (("2"
                                  (lemma "max_append_to_each")
                                  (("2"
                                    (inst -1 "cons1_var" "j2")
                                    (("2"
                                      (assert)
                                      (("2"
                                        (replace -1)
                                        (("2"
                                          (hide -1)
                                          (("2"
                                            (lemma "max_cap_join")
                                            (("2"
                                              (inst? -1)
                                              (("2"
                                                (assert)
                                                (("2"
                                                  (case
                                                   "cons2_var = null")
                                                  (("1"
                                                    (replace -1)
                                                    (("1"
                                                      (expand
                                                       meet_max
                                                       -3
                                                       1)
                                                      (("1"
                                                        (expand
                                                         cap_join
                                                         1)
                                                        (("1"
                                                          (expand
                                                           meet_max
                                                           1
                                                           2)
                                                          (("1"
                                                            (assert)
                                                            (("1"
                                                              (grind)
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil)
                                                   ("2"
                                                    (assert)
                                                    (("2"
                                                      (replace -1)
                                                      (("2"
                                                        (hide -1)
                                                        (("2"
                                                          (hide 4)
                                                          (("2"
                                                            (assert)
                                                            (("2"
                                                              (expand
                                                               max)
                                                              (("2"
                                                                (assert)
                                                                (("2"
                                                                  (grind)
                                                                  nil
                                                                  nil))
                                                                nil))
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep)
      (("3" (typepred "x")
        (("3" (hide -1)
          (("3" (case "j1=null")
            (("1" (replace -1)
              (("1" (expand meet_max -2 1)
                (("1" (expand cap_join 1)
                  (("1" (expand meet_max 1) (("1" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (case "j2=null")
              (("1" (expand cap_join 2) (("1" (assert) nil nil)) nil)
               ("2" (lemma "max_cap_join")
                (("2" (inst?) (("2" (assert) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skeep) (("4" (typepred "x") (("4" (assert) nil nil)) nil))
      nil)
     ("5" (skeep) (("5" (typepred "x") (("5" (assert) nil nil)) nil))
      nil))
    nil)
   ((union_join formula-decl nil semi_algebraic nil)
    (max_append_to_each formula-decl nil semi_algebraic nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (max_cap_join formula-decl nil semi_algebraic nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (append def-decl "list[T]" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (append_join formula-decl nil semi_algebraic nil)
    (append_to_each def-decl "joining" semi_algebraic nil)
    (x skolem-const-decl "{x: list[real] |
   length(x) >= max(meet_max(cons(cons1_var, cons2_var)), meet_max(j2))}"
     semi_algebraic nil)
    (j2 skolem-const-decl "joining" semi_algebraic nil)
    (cons2_var skolem-const-decl "list[meeting]" semi_algebraic nil)
    (cons1_var skolem-const-decl "meeting" semi_algebraic nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cap_join def-decl "joining" semi_algebraic nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (join def-decl "bool" semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (meet_max def-decl "nat" semi_algebraic nil))
   shostak))
 (not_join_cons 0
  (not_join_cons-1 nil 3857722673
   ("" (induct j)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep)
      (("3" (split -1)
        (("1" (expand not_join 1)
          (("1" (expand cap_join 1)
            (("1" (lift-if 1)
              (("1" (assert)
                (("1" (split 1)
                  (("1" (expand negative_atom_meet -1)
                    (("1" (inst -3 0)
                      (("1" (expand nth -3) (("1" (assert) nil nil))
                        nil)
                       ("2" (expand length 1) (("2" (assert) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (lemma "null_append[meeting]")
                      (("2" (inst?)
                        (("2" (assert)
                          (("2" (flatten)
                            (("2" (expand append_to_each -1)
                              (("2" (propax) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (inst -1 "i+1")
            (("1" (expand nth -1) (("1" (propax) nil nil)) nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((i skolem-const-decl "below(length(cons2_var))" semi_algebraic nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons1_var skolem-const-decl "meeting" semi_algebraic nil)
    (cons2_var skolem-const-decl "list[meeting]" semi_algebraic nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (negative_atom_meet def-decl "joining" semi_algebraic nil)
    (null_append formula-decl nil more_list_props structures)
    (append_to_each def-decl "joining" semi_algebraic nil)
    (car adt-accessor-decl "[(cons?) -> T]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cap_join def-decl "joining" semi_algebraic nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (not_join def-decl "joining" semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   shostak))
 (not_join_null 0
  (not_join_null-1 nil 3860148361
   ("" (induct j)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep)
      (("3" (expand not_join 1)
        (("3" (skeep -2)
          (("3" (case i=0)
            (("1" (expand nth -3)
              (("1" (assert)
                (("1" (expand negative_atom_meet)
                  (("1" (expand cap_join) (("1" (propax) nil nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (expand nth -2)
              (("2" (assert)
                (("2" (split -1)
                  (("1" (replace -1)
                    (("1" (expand cap_join) (("1" (propax) nil nil))
                      nil))
                    nil)
                   ("2" (inst 1 "i-1") nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (negative_atom_meet def-decl "joining" semi_algebraic nil)
    (cap_join def-decl "joining" semi_algebraic nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (not_join def-decl "joining" semi_algebraic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   shostak))
 (max_not_meet 0
  (max_not_meet-1 nil 3810907594
   ("" (induct "m")
    (("1" (expand atom_max)
      (("1" (expand negative_atom_meet)
        (("1" (expand meet_max) (("1" (propax) nil nil)) nil)) nil))
      nil)
     ("2" (skeep)
      (("2" (expand atom_max 1)
        (("2" (expand negative_atom_meet 1)
          (("2" (expand meet_max 1)
            (("2" (expand atom_max 1 2)
              (("2" (expand negative_atom 1)
                (("2" (assert)
                  (("2" (expand atom_max 1 2)
                    (("2" (assert) (("2" (grind) nil nil)) nil)) nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (negative_atom const-decl "atomic_poly" semi_algebraic nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (negative_atom_meet def-decl "joining" semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (meeting type-eq-decl nil semi_algebraic nil))
   shostak))
 (max_not_null 0
  (max_not_null-1 nil 3857647277
   ("" (induct j)
    (("1" (grind) nil nil) ("2" (grind) nil nil)
     ("3" (skeep)
      (("3" (expand not_join 1)
        (("3" (lemma "max_cap_join")
          (("3" (inst? -1)
            (("3" (split -1)
              (("1" (replace -1)
                (("1" (expand meet_max 1 1)
                  (("1" (lemma "max_not_meet")
                    (("1" (inst? -1)
                      (("1" (replace -1)
                        (("1" (split -3)
                          (("1" (grind) nil nil)
                           ("2" (skeep)
                            (("2" (inst -3 "i+1")
                              (("1"
                                (expand nth -3)
                                (("1" (propax) nil nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (inst -2 "0")
                (("1" (expand nth -2)
                  (("1" (expand negative_atom_meet 1)
                    (("1" (assert) nil nil)) nil))
                  nil)
                 ("2" (grind) nil nil))
                nil)
               ("3" (lemma "not_join_cons")
                (("3" (inst -1 "cons2_var")
                  (("3" (split -1)
                    (("1" (skeep)
                      (("1" (inst -2 "i+1")
                        (("1" (expand nth -2) (("1" (propax) nil nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (skeep)
                      (("2" (inst -1 "i+1")
                        (("1" (expand nth -1) (("1" (propax) nil nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max_cap_join formula-decl nil semi_algebraic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (cons2_var skolem-const-decl "list[meeting]" semi_algebraic nil)
    (i skolem-const-decl "below(length(cons2_var))" semi_algebraic nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons1_var skolem-const-decl "meeting" semi_algebraic nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (max_not_meet formula-decl nil semi_algebraic nil)
    (i skolem-const-decl "below(length(cons2_var))" semi_algebraic nil)
    (i skolem-const-decl "below(length(cons2_var))" semi_algebraic nil)
    (not_join_cons formula-decl nil semi_algebraic nil)
    (negative_atom_meet def-decl "joining" semi_algebraic nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (not_join def-decl "joining" semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil))
   shostak))
 (max_not 0
  (max_not-1 nil 3810907596
   ("" (skeep)
    (("" (split 1)
      (("1" (flatten)
        (("1" (lemma "max_not_null") (("1" (inst?) nil nil)) nil)) nil)
       ("2" (flatten)
        (("2" (case "EXISTS(i: below(length(j))): null?(nth(j, i))")
          (("1" (lemma "not_join_null")
            (("1" (inst?)
              (("1" (replace -1)
                (("1" (expand meet_max) (("1" (propax) nil nil)) nil))
                nil))
              nil))
            nil)
           ("2" (skeep)
            (("2" (inst 1 "i") (("2" (assert) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((max_not_null formula-decl nil semi_algebraic nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (j skolem-const-decl "joining" semi_algebraic nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (not_join_null formula-decl nil semi_algebraic nil))
   shostak))
 (not_meet_TCC1 0
  (not_meet_TCC1-1 nil 3810907544
   ("" (skeep)
    (("" (typepred "x")
      (("" (lemma "max_not_meet")
        (("" (inst? -1) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((atom_max def-decl "nat" semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max_not_meet formula-decl nil semi_algebraic nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil))
   nil
   (not_meet subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.meet_max(semi_algebraic.negative_atom_meet(semi_algebraic.m)))}")))
 (not_meet 0
  (not_meet-1 nil 3810907598
   ("" (induct "m")
    (("1" (skeep)
      (("1" (expand negative_atom_meet)
        (("1" (expand join)
          (("1" (expand meet) (("1" (propax) nil nil)) nil)) nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand meet 1)
          (("2" (simplify 1)
            (("2" (expand negative_atom_meet 1)
              (("2" (expand join 1)
                (("2" (expand negative_atom 1)
                  (("2" (lift-if 1)
                    (("2" (inst -1 "x")
                      (("1" (split 1)
                        (("1" (flatten)
                          (("1" (expand atom_eval 1 1)
                            (("1" (replace -1)
                              (("1"
                                (expand meet 1 2)
                                (("1"
                                  (expand atom_eval 1)
                                  (("1"
                                    (expand meet 1 2)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (flatten)
                          (("2" (split 2)
                            (("1" (flatten)
                              (("1"
                                (hide 2)
                                (("1"
                                  (expand meet 1 2)
                                  (("1"
                                    (expand atom_eval 1)
                                    (("1" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (split 2)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (expand meet 1 2)
                                    (("1"
                                      (expand atom_eval 1)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (typepred "cons1_var`ineq")
                                    (("2"
                                      (assert)
                                      (("2"
                                        (expand meet 2 2)
                                        (("2"
                                          (expand atom_eval 2)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (typepred "x")
                        (("2" (expand atom_max -2)
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep)
      (("3" (typepred "x")
        (("3" (lemma "max_not_meet")
          (("3" (inst? -1) (("3" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((max_not_meet formula-decl nil semi_algebraic nil)
    (negative_atom const-decl "atomic_poly" semi_algebraic nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons1_var skolem-const-decl "atomic_poly" semi_algebraic nil)
    (cons2_var skolem-const-decl "list[atomic_poly]" semi_algebraic
     nil)
    (x skolem-const-decl
     "{x: list[real] | length(x) >= atom_max(cons(cons1_var, cons2_var))}"
     semi_algebraic nil)
    (> const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (<= const-decl "bool" reals nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (atom_eval const-decl "bool" semi_algebraic nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (join def-decl "bool" semi_algebraic nil)
    (meet def-decl "bool" semi_algebraic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (negative_atom_meet def-decl "joining" semi_algebraic nil))
   shostak))
 (not_join_TCC1 0
  (not_join_TCC1-1 nil 3810907544
   ("" (skeep)
    (("" (typepred "x")
      (("" (lemma "max_not")
        (("" (inst? -1) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((meet_max def-decl "nat" semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (max_not formula-decl nil semi_algebraic nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil))
   nil
   (not_join subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.meet_max(semi_algebraic.not_join(semi_algebraic.j)))}")))
 (not_join 0
  (not_join-1 nil 3810907602
   ("" (induct "j")
    (("1" (expand not_join)
      (("1" (expand join)
        (("1" (expand meet) (("1" (propax) nil nil)) nil)) nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand not_join 1)
          (("2" (lemma "intersect_join")
            (("2" (inst? -1)
              (("1" (lemma "not_meet")
                (("1" (inst? -1)
                  (("1" (expand join 1 1) (("1" (grind) nil nil)) nil)
                   ("2" (hide 2)
                    (("2" (typepred "x")
                      (("2" (expand meet_max -2)
                        (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (hide -1)
                (("2" (typepred "x")
                  (("2" (expand meet_max -2)
                    (("2" (lemma "max_not")
                      (("2" (inst? -1)
                        (("2" (assert)
                          (("2" (hide -2)
                            (("2" (lemma "max_not_meet")
                              (("2"
                                (inst? -1)
                                (("2"
                                  (replace -1)
                                  (("2"
                                    (assert)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep)
      (("3" (typepred "x")
        (("3" (lemma "max_not")
          (("3" (inst? -1) (("3" (assert) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons1_var skolem-const-decl "meeting" semi_algebraic nil)
    (cons2_var skolem-const-decl "list[meeting]" semi_algebraic nil)
    (x skolem-const-decl
     "{x: list[real] | length(x) >= meet_max(cons(cons1_var, cons2_var))}"
     semi_algebraic nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (negative_atom_meet def-decl "joining" semi_algebraic nil)
    (atom_max def-decl "nat" semi_algebraic nil)
    (not_meet formula-decl nil semi_algebraic nil)
    (max_not formula-decl nil semi_algebraic nil)
    (max_not_meet formula-decl nil semi_algebraic nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (intersect_join formula-decl nil semi_algebraic nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (meet def-decl "bool" semi_algebraic nil)
    (list_induction formula-decl nil list_adt nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (join def-decl "bool" semi_algebraic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (not_join def-decl "joining" semi_algebraic nil))
   shostak))
 (semi_alg_TCC1 0
  (semi_alg_TCC1-1 nil 3810907544 ("" (subtype-tcc) nil nil) nil nil
   (semi_alg subtype "semi_algebraic.x"
    "{x: list_adt[real].list | reals.>=(list_props[real].length(x), semi_algebraic.meet_max(semi_algebraic.j))}")))
 (all_true_TCC1 0
  (all_true_TCC1-1 nil 3810907544
   ("" (skeep)
    (("" (expand meet_max)
      (("" (expand atom_max)
        (("" (expand meet_max)
          (("" (assert)
            (("" (typepred "n")
              (("" (expand max) (("" (propax) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((meet_max def-decl "nat" semi_algebraic nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (>= const-decl "bool" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (atom_max def-decl "nat" semi_algebraic nil))
   nil
   (all_true subtype "semi_algebraic.n"
    "{n: naturalnumbers.nat | reals.>=(n, semi_algebraic.meet_max((: (: :) :)))}")))
 (all_true 0
  (all_true-1 nil 3810907605
   ("" (skeep)
    (("" (expand semi_alg)
      (("" (expand join)
        (("" (expand meet) (("" (propax) nil nil)) nil)) nil))
      nil))
    nil)
   ((semi_alg const-decl "set[VectorN(n)]" semi_algebraic nil)
    (meet def-decl "bool" semi_algebraic nil)
    (join def-decl "bool" semi_algebraic nil))
   shostak))
 (sa_union_TCC1 0
  (sa_union_TCC1-1 nil 3810907544 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (sa_union subtype "semi_algebraic.n"
    "{n: naturalnumbers.nat | reals.>=(n, semi_algebraic.meet_max(semi_algebraic.j1))}")))
 (sa_union_TCC2 0
  (sa_union_TCC2-1 nil 3810907544 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (sa_union subtype "semi_algebraic.n"
    "{n: naturalnumbers.nat | reals.>=(n, semi_algebraic.meet_max(semi_algebraic.j2))}")))
 (sa_union 0
  (sa_union-1 nil 3810907606
   ("" (skeep)
    (("" (inst 1 "append(j1,j2)")
      (("" (typepred "n")
        (("" (assert)
          (("" (lemma "max_meet")
            (("" (inst?)
              (("" (assert)
                (("" (expand union)
                  (("" (expand member)
                    (("" (expand semi_alg)
                      (("" (lemma "union_join")
                        (("" (inst?)
                          (("" (hide -2)
                            (("" (hide -2)
                              ((""
                                (decompose-equality 1)
                                (("" (inst? -1) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (append def-decl "list[T]" list_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (union const-decl "set" sets nil)
    (semi_alg const-decl "set[VectorN(n)]" semi_algebraic nil)
    (VectorN type-eq-decl nil matrices matrices)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (join def-decl "bool" semi_algebraic nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (union_join formula-decl nil semi_algebraic nil)
    (member const-decl "bool" sets nil)
    (max_meet formula-decl nil semi_algebraic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (meet_max def-decl "nat" semi_algebraic nil))
   shostak))
 (sa_intersection 0
  (sa_intersection-1 nil 3810907608
   ("" (skeep)
    (("" (inst 1 "cap_join(j1,j2)")
      (("" (flatten)
        (("" (expand intersection)
          (("" (expand semi_alg)
            (("" (expand member)
              (("" (decompose-equality 1)
                (("1" (lemma "intersect_join")
                  (("1" (inst? -1) nil nil)) nil)
                 ("2" (skeep)
                  (("2" (typepred "x")
                    (("2" (typepred "n") (("2" (assert) nil nil)) nil))
                    nil))
                  nil)
                 ("3" (skeep)
                  (("3" (typepred "x")
                    (("3" (typepred "n") (("3" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (cap_join def-decl "joining" semi_algebraic nil)
    (intersection const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (intersect_join formula-decl nil semi_algebraic nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (VectorN type-eq-decl nil matrices matrices)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (join def-decl "bool" semi_algebraic nil)
    (n skolem-const-decl
     "{n: nat | n >= max(meet_max(j1), meet_max(j2))}" semi_algebraic
     nil)
    (j2 skolem-const-decl "joining" semi_algebraic nil)
    (j1 skolem-const-decl "joining" semi_algebraic nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (semi_alg const-decl "set[VectorN(n)]" semi_algebraic nil))
   shostak))
 (sa_complement 0
  (sa_complement-1 nil 3810907610
   ("" (skeep)
    (("" (inst 1 "not_join(j)")
      (("" (flatten)
        (("" (expand complement)
          (("" (expand semi_alg)
            (("" (expand member)
              (("" (decompose-equality 1)
                (("" (lemma "not_join") (("" (inst?) nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (not_join def-decl "joining" semi_algebraic nil)
    (complement const-decl "set" sets nil)
    (member const-decl "bool" sets nil)
    (not_join formula-decl nil semi_algebraic nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (length def-decl "nat" list_props nil)
    (meet_max def-decl "nat" semi_algebraic nil)
    (VectorN type-eq-decl nil matrices matrices)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (join def-decl "bool" semi_algebraic nil)
    (n skolem-const-decl "{n: nat | n >= meet_max(j)}" semi_algebraic
     nil)
    (j skolem-const-decl "joining" semi_algebraic nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (semi_alg const-decl "set[VectorN(n)]" semi_algebraic nil))
   shostak))
 (sa_difference 0
  (sa_difference-1 nil 3810907611
   ("" (skeep)
    (("" (expand difference)
      (("" (expand member)
        (("" (inst 1 " cap_join(j1,not_join(j2))")
          (("" (flatten)
            (("" (lemma "intersect_join")
              (("" (inst?)
                (("" (decompose-equality 1)
                  (("1" (inst? -1)
                    (("1" (lemma "not_join")
                      (("1" (inst -1 "j2" "x!1")
                        (("1" (assert) (("1" (grind) nil nil)) nil)
                         ("2" (hide -1)
                          (("2" (typepred "x!1")
                            (("2" (lemma "max_not")
                              (("2"
                                (inst -1 "j2")
                                (("2"
                                  (case "not_join(j2) = null")
                                  (("1"
                                    (replace -1)
                                    (("1"
                                      (expand not_join -1)
                                      (("1"
                                        (lift-if -1)
                                        (("1"
                                          (assert)
                                          (("1"
                                            (split -1)
                                            (("1" (propax) nil nil)
                                             ("2"
                                              (flatten)
                                              (("2"
                                                (typepred "n")
                                                (("2"
                                                  (assert)
                                                  nil
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (typepred "n")
                                    (("2" (assert) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (lemma "max_not")
                      (("2" (inst -1 "j2")
                        (("2" (typepred "n")
                          (("2" (assert)
                            (("2" (typepred "x!1")
                              (("2"
                                (assert)
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (skeep)
                    (("2" (typepred "n") (("2" (assert) nil nil)) nil))
                    nil)
                   ("3" (skeep)
                    (("3" (typepred "n") (("3" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((difference const-decl "set" sets nil)
    (INEQ type-eq-decl nil semi_algebraic nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (monomial type-eq-decl nil standard_form_mult_poly nil)
    (MultPoly type-eq-decl nil standard_form_mult_poly nil)
    (mv_standard_form? const-decl "bool" standard_form_mult_poly nil)
    (atomic_poly type-eq-decl nil semi_algebraic nil)
    (meeting type-eq-decl nil semi_algebraic nil)
    (joining type-eq-decl nil semi_algebraic nil)
    (cap_join def-decl "joining" semi_algebraic nil)
    (not_join def-decl "joining" semi_algebraic nil)
    (intersect_join formula-decl nil semi_algebraic nil)
    (listn_0 name-judgement "listn[nat](0)" standard_form_mult_poly
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (j1 skolem-const-decl "joining" semi_algebraic nil)
    (j2 skolem-const-decl "joining" semi_algebraic nil)
    (n skolem-const-decl
     "{n: nat | n >= max(meet_max(j1), meet_max(j2))}" semi_algebraic
     nil)
    (semi_alg const-decl "set[VectorN(n)]" semi_algebraic nil)
    (set type-eq-decl nil sets nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (VectorN type-eq-decl nil matrices matrices)
    (meet_max def-decl "nat" semi_algebraic nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (not_join formula-decl nil semi_algebraic nil)
    (max_not formula-decl nil semi_algebraic nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (x!1 skolem-const-decl "VectorN(n)" semi_algebraic nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (member const-decl "bool" sets nil))
   shostak)))

