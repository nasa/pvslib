(sorting (lt_le 0 (lt_le-1 nil 3797719502 ("" (skeep) (("" (expand "lt") (("" (typepred "leq") (("" (expand "total_preorder?") (("" (flatten) (("" (expand "dichotomous?") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((lt const-decl "bool" sorting nil) (dichotomous? const-decl "bool" orders nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil sorting nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" sorting nil)) shostak)) (gt_not_le 0 (gt_not_le-1 nil 3797719594 ("" (skeep) (("" (expand "gt") (("" (expand "converse") (("" (expand "lt") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((gt const-decl "pred[[T, T]]" sorting nil) (lt const-decl "bool" sorting nil) (converse const-decl "pred[[T2, T1]]" relation_defs nil)) shostak)) (search_TCC1 0 (search_TCC1-1 nil 3517307925 ("" (tcc)) nil shostak (search subtype "sorting.l" "(list_adt[sorting.T].cons?)"))) (search_TCC2 0 (search_TCC2-1 nil 3517307925 ("" (tcc)) ((length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (search termination "sorting.search(sorting.i, list_adt[sorting.T].cdr(sorting.l))" "nil"))) (not_in_l_gives_lenght_l 0 (not_in_l_gives_lenght_l-1 nil 3778236903 ("" (measure-induct+ "length(l)" "l") (("1" (skeep) (("1" (case "null?(x!1)") (("1" (grind) nil nil) ("2" (case "car(x!1)=i") (("1" (inst -3 0) (("1" (hide-all-but (-1 2)) (("1" (grind) nil nil)) nil) ("2" (hide-all-but (1 2)) (("2" (grind) nil nil)) nil)) nil) ("2" (expand "search" 3) (("2" (assert) (("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "i") (("2" (expand "list2finseq") (("2" (expand "length" 3) (("2" (prop) (("1" (skeep) (("1" (lemma "preservation_contents") (("1" (inst -1 "x!1" "i") (("1" (prop) (("1" (inst -1 "k") nil nil) ("2" (hide-all-but (-2 1)) (("2" (skeep :preds? t) (("2" (inst?) (("2" (expand "list2finseq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil) ("3" (typepred "k!1") (("3" (expand "list2finseq") (("3" (propax) nil nil)) nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (x!1 skolem-const-decl "list[T]" sorting nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (preservation_contents formula-decl nil sorting_aux nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (search def-decl "nat" sorting nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil)) (not_member_gives_length 0 (not_member_gives_length-1 nil 3532265028 ("" (lemma "not_in_l_gives_lenght_l") (("" (skeep) (("" (inst -1 "l" "i") (("" (prop) (("" (hide 3) (("" (skeep) (("" (lemma "nth_implies_member") (("" (inst -1 "l" "i" "k") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (nth_implies_member formula-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting nil) (not_in_l_gives_lenght_l formula-decl nil sorting nil)) shostak)) (search_works_TCC1 0 (search_works_TCC1-1 nil 3517307926 ("" (measure-induct "length(l)" "l") (("" (skeep) (("" (skeep) (("" (case "null?(x)") (("1" (grind) nil nil) ("2" (case "car(x)=k") (("1" (expand "search" 2) (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "search" 3) (("2" (assert) (("2" (inst -1 "cdr(x)") (("2" (prop) (("1" (inst -1 "k") (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (search def-decl "nat" sorting nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak (search_works subtype "sorting.search(sorting.k, sorting.l)" "below[length[T](l)]"))) (search_works 0 (search_works-2 "" 3804612396 ("" (measure-induct+ "length(l)" "l") (("1" (skeep) (("1" (case "null?(x!1)") (("1" (hide -2) (("1" (grind) nil nil)) nil) ("2" (expand "search" 2) (("2" (assert) (("2" (case "car(x!1)=k") (("1" (assert) (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "k") (("2" (prop) (("1" (expand "member" -2) (("1" (expand "nth" 3) (("1" (propax) nil nil)) nil)) nil) ("2" (hide 4) (("2" (grind) nil nil)) nil) ("3" (hide -1 2 4) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "search_works_TCC1") nil nil) ("3" (hide 2) (("3" (rewrite "search_works_TCC1") nil nil)) nil)) nil) nil shostak) (search_works-1 nil 3517564787 ("" (measure-induct+ "length(l)" "l") (("1" (skeep) (("1" (case "null?(x!1)") (("1" (hide -2) (("1" (grind) nil nil)) nil) ("2" (expand "search" 2) (("2" (assert) (("2" (case "car(x!1)=k") (("1" (assert) (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "k") (("2" (prop) (("1" (expand "member" -2) (("1" (expand "nth" 3) (("1" (propax) nil nil)) nil)) nil) ("2" (hide 4) (("2" (grind) nil nil)) nil) ("3" (hide -1 2 4) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (rewrite "search_works_TCC1") nil nil)) nil) ("3" (hide 2) (("3" (rewrite "search_works_TCC1") nil nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (T formal-type-decl nil sorting nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (search def-decl "nat" sorting nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (nth def-decl "T" list_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (search_works_TCC1 subtype-tcc nil sorting nil)) shostak)) (search_min_index 0 (search_min_index-1 nil 3518184887 ("" (measure-induct+ "length(l)" "l") (("1" (expand "search" 1) (("1" (case "null?(x!1)") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (assert) (("2" (case "car(x!1) = k!1") (("1" (assert) nil nil) ("2" (assert) (("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "k!1") (("2" (prop) (("1" (inst -1 "m!1 - 1") (("1" (expand "nth" -2) (("1" (grind) nil nil)) nil) ("2" (typepred "m!1") (("2" (hide 4) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide -1 2 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (typepred "m!1") (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (typepred "m!1") (("3" (hide 2) (("3" (grind) nil nil)) nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (m!1 skolem-const-decl "below[length(x!1)]" sorting nil) (x!1 skolem-const-decl "list[T]" sorting nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (search def-decl "nat" sorting nil) (<= const-decl "bool" reals nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (search_in_rev_max_index 0 (search_in_rev_max_index-1 nil 3519243847 ("" (lemma "search_min_index") (("" (skosimp*) (("" (lemma "nth_rev") (("" (inst -1 "m!1" "l!1") (("1" (inst -2 "reverse(l!1)" "k!1" "length(l!1) - 1 - m!1") (("1" (grind) nil nil) ("2" (lemma "length_reverse") (("2" (inst -1 "l!1") (("2" (typepred "m!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "m!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (l!1 skolem-const-decl "list[T]" sorting nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (reverse def-decl "list[T]" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (search def-decl "nat" sorting nil) (nth_rev formula-decl nil sorting_aux nil) (T formal-type-decl nil sorting nil) (search_min_index formula-decl nil sorting nil)) shostak)) (search_in_append_of_lists_key_in_the_first 0 (search_in_append_of_lists_key_in_the_first-1 nil 3531728399 ("" (measure-induct+ "l1`length" ("l1")) (("" (skeep) (("" (case "null?(x!1)") (("1" (hide -2 1) (("1" (expand "member") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "search" 2 1) (("2" (assert) (("2" (lift-if) (("2" (case "null?(append(x!1,l2))") (("1" (assert) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (prop) (("1" (expand "search" 1) (("1" (case "car(x!1) = k") (("1" (assert) nil nil) ("2" (hide-all-but (-1 -3 1 3 4)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (case "cdr(append(x!1, l2)) = append(cdr(x!1), l2)") (("1" (replace -1 2) (("1" (inst -2 "cdr(x!1)") (("1" (inst -2 "l2" "k") (("1" (assert) (("1" (prop) (("1" (expand "member" -3) (("1" (case "k = car(x!1)") (("1" (assert) (("1" (prop) (("1" (hide-all-but (-1 1 4)) (("1" (grind) nil nil)) nil) ("2" (replace -2 2) (("2" (hide-all-but (-3 1 4)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "search" 3 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3 4) (("2" (grind) nil nil)) nil) ("3" (hide-all-but (1 5)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (append def-decl "list[T]" list_props nil) (search def-decl "nat" sorting nil) (= const-decl "[T, T -> boolean]" equalities nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (search_in_append_of_lists_key_not_member_of_the_first 0 (search_in_append_of_lists_key_not_member_of_the_first-1 nil 3532272614 ("" (measure-induct+ "length(l1)" ("l1")) (("" (skeep) (("" (case "null?(x!1)") (("1" (expand "search" 2 1) (("1" (case "null?(append(x!1, l2))") (("1" (assert) (("1" (expand "length" 2) (("1" (expand "append" -1) (("1" (expand "search" 2) (("1" (assert) (("1" (hide-all-but (-1 2)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "append" 3 1) (("2" (expand "append" 3 1) (("2" (expand "length" 3) (("2" (expand "search" 3 2) (("2" (expand "append" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 3) (("2" (assert) (("2" (expand "search" 3 1) (("2" (assert) (("2" (case "car(x!1) = k") (("1" (hide-all-but (-1 2)) (("1" (expand "member") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) (("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "l2" "k") (("2" (prop) (("1" (expand "member" 3) (("1" (replaces -1) (("1" (expand "length" 4 2) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (grind) nil nil)) nil) ("3" (hide 2 4 5) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (append def-decl "list[T]" list_props nil) (search def-decl "nat" sorting nil) (= const-decl "[T, T -> boolean]" equalities nil) (member def-decl "bool" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (search_in_append_of_lists_with_searched_key 0 (search_in_append_of_lists_with_searched_key-1 nil 3531738934 ("" (skeep) (("" (case "member(k,l1)") (("1" (lemma "search_min_index") (("1" (inst -1 "l1" "k" "_") (("1" (lemma "member_implies_exists_nth") (("1" (inst -1 "l1" "k") (("1" (assert) (("1" (skosimp*) (("1" (inst -2 "k!1") (("1" (assert) (("1" (case "nth(append(l1, cons(k, l2)), k!1) = k") (("1" (lemma "search_min_index") (("1" (inst -1 "append(l1, cons(k, l2))" k k!1) (("1" (assert) nil nil) ("2" (typepred "k!1") (("2" (assert) (("2" (expand "list2finseq") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 2) (("2" (typepred "k!1") (("2" (lemma "nth_of_list_is_nth_append_list") (("2" (inst -1 "l1" "cons(k, l2)" k!1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (lemma "length_append") (("3" (inst -1 "l1" "cons(k,l2)") (("3" (hide -2 -3 -4 2) (("3" (typepred "k!1") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -2 -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "append" 1) (("2" (assert) (("2" (expand "search" 1) (("2" (hide -2 -3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "search_in_append_of_lists_key_not_member_of_the_first") (("2" (inst -1 "l1" "cons(k,l2)" k) (("2" (assert) (("2" (replace -1 2) (("2" (expand "search" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((member def-decl "bool" list_props nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting nil) (l1 skolem-const-decl "list[T]" sorting nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (length_append formula-decl nil list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nth_of_list_is_nth_append_list formula-decl nil sorting_aux nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (append def-decl "list[T]" list_props nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (search def-decl "nat" sorting nil) (member_implies_exists_nth formula-decl nil sorting_aux nil) (search_min_index formula-decl nil sorting nil) (search_in_append_of_lists_key_not_member_of_the_first formula-decl nil sorting nil)) shostak)) (is_sorted?_TCC1 0 (is_sorted?_TCC1-1 nil 3578072583 ("" (tcc)) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil sorting nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (is_sorted? subtype "(number_fields.+)(sorting.k, 1)" "below[length[T](l)]"))) (is_sorted_implies_monotone_TCC1 0 (is_sorted_implies_monotone_TCC1-1 nil 3784473959 ("" (subtype-tcc) nil nil) ((is_sorted? const-decl "bool" sorting nil)) nil (is_sorted_implies_monotone subtype "sorting.i" "below[length[T](l)]"))) (is_sorted_implies_monotone 0 (is_sorted_implies_monotone-1 nil 3778349074 ("" (measure-induct "length(l)" "l") (("" (skeep) (("" (case "null?(x)") (("1" (grind) nil nil) ("2" (expand "is_sorted?") (("2" (skeep :preds? t) (("2" (expand "nth" 2) (("2" (lift-if) (("2" (prop) (("1" (case-replace "j = 1") (("1" (inst -6 0) (("1" (assert) (("1" (expand "nth" -6) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (inst -4 "cdr(x)") (("2" (expand "length" -4 2) (("2" (assert) (("2" (prop) (("1" (inst -1 "j - 1" "0") (("1" (inst -5 0) (("1" (assert) (("1" (expand "nth" -5) (("1" (typepred "leq") (("1" (expand "total_preorder?") (("1" (expand "preorder?") (("1" (flatten) (("1" (hide-all-but (-2 -4 -8 2)) (("1" (expand "transitive?") (("1" (inst -1 "car(x)" "nth(cdr(x),0)" "nth(cdr(x), j - 1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -5 "k + 1") (("1" (assert) (("1" (prop) (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil) ("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "j = i + 1") (("1" (assert) (("1" (inst -5 "i") (("1" (expand "nth" -5) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (inst -3 "cdr(x)") (("2" (expand "length" -3 2) (("2" (assert) (("2" (prop) (("1" (inst?) nil nil) ("2" (skeep) (("2" (inst -4 "1 + k") (("1" (expand "length" -4) (("1" (assert) (("1" (expand "nth" -4) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (k skolem-const-decl "below[length(cdr(x))]" sorting nil) (x skolem-const-decl "list[T]" sorting nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (preorder? const-decl "bool" orders nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (transitive? const-decl "bool" relations nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (k skolem-const-decl "below[length(cdr(x))]" sorting nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (leq formal-const-decl "(total_preorder?[T])" sorting nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (below type-eq-decl nil nat_types nil) (is_sorted? const-decl "bool" sorting nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil)) (cdr_of_sorted_is_sorted_TCC1 0 (cdr_of_sorted_is_sorted_TCC1-1 nil 3655720139 ("" (subtype-tcc) nil nil) ((is_sorted? const-decl "bool" sorting nil)) nil (cdr_of_sorted_is_sorted subtype "sorting.l" "(list_adt[sorting.T].cons?)"))) (cdr_of_sorted_is_sorted 0 (cdr_of_sorted_is_sorted-1 nil 3589039883 ("" (skeep) (("" (expand "is_sorted?") (("" (skeep) (("" (inst -1 "k+1") (("1" (expand "length" -1) (("1" (assert) (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "list2finseq") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((is_sorted? const-decl "bool" sorting nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (k skolem-const-decl "below[length(cdr(l))]" sorting nil) (below type-eq-decl nil nat_types nil) (l skolem-const-decl "list[T]" sorting nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nth def-decl "T" list_props nil)) shostak)))
