(ford_johnson (t_TCC1 0 (t_TCC1-4 nil 3733825079 ("" (induct "k") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (skeep) (("4" (prop) (("1" (hide -1 -3) (("1" (lemma "div_simple") (("1" (inst -1 "(2 ^ (1 + j) + (-1) ^ j)" "3") (("1" (iff) (("1" (prop) (("1" (skeep) (("1" (hide -2 -3) (("1" (lemma "div_simple") (("1" (inst?) (("1" (iff) (("1" (prop) (("1" (lemma " int_minus_int_is_int") (("1" (inst -1 "(2 ^ (j + 1 + 1) + (-1) ^ (j + 1)) / 3" "1") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 1 3) (("2" (lemma "even_m1_pow") (("2" (inst -1 "j") (("2" (prop) (("1" (replace -1 -2) (("1" (case-replace "2 ^ (2 + j) + (-1) ^ (1 + j) = 2 * 2 ^ (1 + j) - 1") (("1" (inst 1 "2*k - 1") (("1" (assert) nil nil)) nil) ("2" (hide -2 2) (("2" (expand "^") (("2" (expand "expt" 1 (1 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (inst -1 "j") (("2" (assert) (("2" (hide 1) (("2" (case-replace "2 ^ (2 + j) + (-1) ^ (1 + j) = 2 * 2 ^ (1 + j) + 1") (("1" (inst 1 "2*k + 1") (("1" (assert) nil nil)) nil) ("2" (hide -2 2) (("2" (expand "^") (("2" (expand "expt" 1 (1 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "forall(x:int): integer_pred(x)=> integer_pred(x+1)") (("1" (inst -1 "(2 ^ (j + 1) + (-1) ^ j) / 3 - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (lemma "even_m1_pow") (("2" (inst -1 "j") (("2" (prop) (("1" (replace -1 -2) (("1" (expand "^") (("1" (expand "expt" 1) (("1" (replaces) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (inst -1 "j") (("2" (assert) (("2" (replace -1 -2) (("2" (expand "^") (("2" (expand "expt" 2) (("2" (replaces) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -3 -4) (("3" (lemma "even_m1_pow") (("3" (inst -1 "j") (("3" (prop) (("1" (replace -1 -3) (("1" (expand "^") (("1" (expand "expt" 1 (1 2)) (("1" (replace -1 1) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (inst -1 "j") (("2" (prop) (("2" (hide 1) (("2" (expand "^") (("2" (expand "expt" 1) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -) (("4" (case-replace "j=0") (("1" (hide 2) (("1" (grind) nil nil)) nil) ("2" (case-replace "j=1") (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("5" (hide -) (("5" (case-replace "j=0") (("1" (grind) nil nil) ("2" (case-replace "j=1") (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("6" (hide -2 -3 -4) (("6" (case-replace "j = 1") (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((odd_plus_odd_is_even application-judgement "even_int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (TRUE const-decl "bool" booleans nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nzint nonempty-type-eq-decl nil integers nil) (j skolem-const-decl "nat" ford_johnson nil) (int_minus_int_is_int judgement-tcc nil integers nil) (even_m1_pow formula-decl nil exponentiation nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_times_int_is_int application-judgement "int" integers nil) (odd_times_odd_is_odd application-judgement "odd_int" integers nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (not_even_m1_pow formula-decl nil exponentiation nil) (div_simple formula-decl nil integer_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (expt def-decl "real" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nat_induction formula-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield -> numfield]" number_fields nil) (^ const-decl "real" exponentiation nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil)) shostak (t subtype "(number_fields.-)(number_fields./(((number_fields.+)(exponentiation.^(2, ((number_fields.+)(ford_johnson.k, 1))), exponentiation.^(((number_fields.-)(1)), (ford_johnson.k)))), 3), 1)" "{t: naturalnumbers.nat | booleans.=>(reals.>(ford_johnson.k, 1), reals.>=(t, 2))}")) (t_TCC1-3 nil 3733824944 ("" (induct "k") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (assert) nil nil) ("5" (skeep) (("5" (prop) (("1" (hide -1 -3 -4) (("1" (lemma "div_simple") (("1" (assert) (("1" (inst -1 "(2 ^ (1 + j) + (-1) ^ j)" "3") (("1" (iff) (("1" (prop) (("1" (skeep) (("1" (hide -2 -3) (("1" (lemma "div_simple") (("1" (inst?) (("1" (iff) (("1" (prop) (("1" (hide 1 3) (("1" (lemma "even_m1_pow") (("1" (inst -1 "j") (("1" (prop) (("1" (replace -1 -2) (("1" (case-replace "2 ^ (2 + j) + (-1) ^ (1 + j) = 2 * 2 ^ (1 + j) - 1") (("1" (inst 1 "2*k - 1") (("1" (assert) nil nil)) nil) ("2" (hide -2 2) (("2" (expand "^") (("2" (expand "expt" 1 (1 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (inst -1 "j") (("2" (assert) (("2" (hide 1) (("2" (case-replace "2 ^ (2 + j) + (-1) ^ (1 + j) = 2 * 2 ^ (1 + j) + 1") (("1" (inst 1 "2*k + 1") (("1" (assert) nil nil)) nil) ("2" (hide -2 2) (("2" (expand "^") (("2" (expand "expt" 1 (1 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4) (("2" (assert) (("2" (lemma "even_m1_pow") (("2" (inst -1 "j") (("2" (prop) (("1" (replace -1 -2) (("1" (expand "^") (("1" (expand "expt" 1 (1 2)) (("1" (replace -1 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (inst -1 "j") (("2" (prop) (("2" (hide 1) (("2" (expand "^") (("2" (expand "expt" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -2 -3 -4) (("3" (assert) (("3" (lemma "even_m1_pow") (("3" (inst -1 "j") (("3" (prop) (("1" (replace -1 -2) (("1" (expand "^") (("1" (expand "expt" 1 (1 2)) (("1" (replace -1 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (inst -1 "j") (("2" (prop) (("2" (hide 1) (("2" (expand "^") (("2" (expand "expt" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil)) nil)) nil)) nil) nil nil (t subtype "(number_fields.-)(number_fields./(((number_fields.+)(exponentiation.^(2, ((number_fields.+)(ford_johnson.k, 1))), exponentiation.^(((number_fields.-)(1)), (ford_johnson.k)))), 3), 1)" "{t: naturalnumbers.nat | booleans.=>(reals.>(ford_johnson.k, 1), reals.>=(t, 2))}")) (t_TCC1-2 nil 3733824732 ("" (induct "k") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (assert) nil nil) ("5" (skeep) (("5" (prop) (("1" (hide -1 -3 -4) (("1" (lemma "div_simple") (("1" (assert) (("1" (inst -1 "(2 ^ (1 + j) + (-1) ^ j)" "3") (("1" (iff) (("1" (prop) (("1" (skeep) (("1" (hide -2 -3) (("1" (lemma "div_simple") (("1" (inst?) (("1" (iff) (("1" (prop) (("1" (hide 1 3) (("1" (lemma "even_m1_pow") (("1" (inst -1 "j") (("1" (prop) (("1" (replace -1 -2) (("1" (case-replace "2 ^ (2 + j) + (-1) ^ (1 + j) = 2 * 2 ^ (1 + j) - 1") (("1" (inst 1 "2*k - 1") (("1" (assert) nil nil)) nil) ("2" (hide -2 2) (("2" (expand "^") (("2" (expand "expt" 1 (1 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (inst -1 "j") (("2" (assert) (("2" (hide 1) (("2" (case-replace "2 ^ (2 + j) + (-1) ^ (1 + j) = 2 * 2 ^ (1 + j) + 1") (("1" (inst 1 "2*k + 1") (("1" (assert) nil nil)) nil) ("2" (hide -2 2) (("2" (expand "^") (("2" (expand "expt" 1 (1 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4) (("2" (assert) (("2" (lemma "even_m1_pow") (("2" (inst -1 "j") (("2" (prop) (("1" (replace -1 -2) (("1" (expand "^") (("1" (expand "expt" 1 (1 2)) (("1" (replace -1 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (inst -1 "j") (("2" (prop) (("2" (hide 1) (("2" (expand "^") (("2" (expand "expt" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 -3) (("3" (assert) (("3" (lemma "even_m1_pow") (("3" (inst -1 "j") (("3" (prop) (("1" (replace -1 -2) (("1" (expand "^") (("1" (expand "expt" 1 (1 2)) (("1" (replace -1 1) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (inst -1 "j") (("2" (prop) (("2" (hide 1) (("2" (expand "^") (("2" (expand "expt" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil)) nil)) nil)) nil) nil nil (t subtype "(number_fields.-)(number_fields./(((number_fields.+)(exponentiation.^(2, ((number_fields.+)(ford_johnson.k, 1))), exponentiation.^(((number_fields.-)(1)), (ford_johnson.k)))), 3), 1)" "{t: naturalnumbers.nat | booleans.=>(reals.>(ford_johnson.k, 1), reals.>=(t, 2))}")) (t_TCC1-1 nil 3722301915 ("" (induct "k") (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil) ("4" (assert) nil nil) ("5" (skeep) (("5" (prop) (("1" (hide -1 -3 -4) (("1" (lemma "div_simple") (("1" (assert) (("1" (inst -1 "(2 ^ (1 + j) + (-1) ^ j)" "3") (("1" (iff) (("1" (prop) (("1" (skeep) (("1" (hide -2 -3) (("1" (lemma "div_simple") (("1" (inst?) (("1" (iff) (("1" (prop) (("1" (hide 1 3) (("1" (lemma "even_m1_pow") (("1" (inst -1 "j") (("1" (prop) (("1" (replace -1 -2) (("1" (case-replace "2 ^ (2 + j) + (-1) ^ (1 + j) = 2 * 2 ^ (1 + j) - 1") (("1" (inst 1 "2*k - 1") (("1" (assert) nil nil)) nil) ("2" (hide -2 2) (("2" (expand "^") (("2" (expand "expt" 1 (1 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (inst -1 "j") (("2" (assert) (("2" (hide 1) (("2" (case-replace "2 ^ (2 + j) + (-1) ^ (1 + j) = 2 * 2 ^ (1 + j) + 1") (("1" (inst 1 "2*k + 1") (("1" (assert) nil nil)) nil) ("2" (hide -2 2) (("2" (expand "^") (("2" (expand "expt" 1 (1 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 -4) (("2" (assert) (("2" (lemma "even_m1_pow") (("2" (inst -1 "j") (("2" (prop) (("1" (replace -1 -2) (("1" (expand "^") (("1" (expand "expt" 1 (1 2)) (("1" (replace -1 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (inst -1 "j") (("2" (prop) (("2" (hide 1) (("2" (expand "^") (("2" (expand "expt" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 -2 -3) (("3" (postpone) nil nil)) nil) ("4" (postpone) nil nil) ("5" (postpone) nil nil) ("6" (postpone) nil nil) ("7" (postpone) nil nil) ("8" (postpone) nil nil)) nil)) nil)) nil) nil nil (t subtype "(number_fields.-)(number_fields./(((number_fields.+)(exponentiation.^(2, ((number_fields.+)(ford_johnson.k, 1))), exponentiation.^(((number_fields.-)(1)), (ford_johnson.k)))), 3), 1)" "{t: naturalnumbers.nat | booleans.=>(reals.>(ford_johnson.k, 1), reals.>=(t, 2))}"))) (t_is_increasing 0 (t_is_increasing-3 nil 3734224056 ("" (skeep) (("" (prop) (("1" (expand "t") (("1" (expand "^") (("1" (lemma " both_sides_expt_gt1_lt_aux") (("1" (inst -1 "2" "i" "j") (("1" (assert) (("1" (case "EXISTS (k : posnat) : i+k = j") (("1" (skeep) (("1" (lemma "expt_plus_aux") (("1" (replace -2 1 rl) (("1" (inst -1 "i + 1" "k" "2") (("1" (replace -1 1) (("1" (case "expt(2, k) >= 2") (("1" (case "(expt(2, 1 + i) + expt((-1), i))  < (expt(2, i + 1) * 2 + expt((-1), i + k)) AND (expt(2, i + 1) * 2 + expt((-1), i + k)) <= (expt(2, i + 1) * expt(2, k) + expt((-1), i + k))") (("1" (prop) (("1" (assert) nil nil)) nil) ("2" (prop) (("1" (hide 2) (("1" (case "even?(i) ") (("1" (case "even?(i + k)") (("1" (lemma "even_m1_pow") (("1" (lemma "even_m1_pow") (("1" (inst?) (("1" (inst -2 "i ") (("1" (assert) (("1" (expand "^" -1) (("1" (expand "^" -2) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (lemma "even_m1_pow") (("2" (inst -1 "i") (("2" (inst -2 "i + k") (("2" (assert) (("2" (expand "^" -1) (("2" (expand "^" -2) (("2" (replaces -1) (("2" (replaces -1) (("2" (assert) (("2" (case "expt(2, 1 + i) > 2") (("1" (assert) nil nil) ("2" (lemma "increasing_expt_aux") (("2" (inst -1 "2" "1 + i -2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "even?(i + k)") (("1" (lemma "not_even_m1_pow") (("1" (lemma "even_m1_pow") (("1" (inst?) (("1" (inst -2 "i") (("1" (assert) (("1" (expand "^" -1) (("1" (expand "^" -2) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (lemma "not_even_m1_pow") (("2" (inst?) (("2" (inst -2 "i") (("2" (assert) (("2" (expand "^" -1) (("2" (expand "^" -2) (("2" (replaces -1) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "both_sides_plus_le1") (("2" (lemma "both_sides_times_pos_le1") (("2" (inst -1 "expt(2,1 + i)" "2" "expt(2,k)") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "k = 1") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (lemma "increasing_expt_aux") (("2" (inst -1 "2" "k - 2") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (typepred "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "j - i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "t") (("2" (expand "^") (("2" (lemma " both_sides_expt_gt1_lt_aux") (("2" (inst -1 "2" "i" "j") (("2" (assert) (("2" (case "even?(i) ") (("1" (case "even?(j) ") (("1" (lemma "even_m1_pow") (("1" (lemma "even_m1_pow") (("1" (inst?) (("1" (inst -2 "i ") (("1" (assert) (("1" (expand "^" -1) (("1" (expand "^" -2) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (lemma "even_m1_pow") (("2" (inst -1 "i") (("2" (inst -2 "j") (("2" (assert) (("2" (expand "^" -1) (("2" (expand "^" -2) (("2" (replaces -1) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "even?(j) ") (("1" (lemma "not_even_m1_pow") (("1" (lemma "even_m1_pow") (("1" (inst?) (("1" (inst -2 "i") (("1" (assert) (("1" (expand "^" -1) (("1" (expand "^" -2) (("1" (replaces -1) (("1" (replaces -1) (("1" (typepred "i") (("1" (typepred "j") (("1" (lemma "increasing_expt_aux") (("1" (inst?) (("1" (assert) (("1" (lemma "increasing_expt_aux") (("1" (inst -1 "2" "1 + j -2") (("1" (assert) (("1" (case "i = j") (("1" (assert) nil nil) ("2" (case "j < i") (("1" (case "EXISTS (k : posnat) : i  = j + k") (("1" (skeep) (("1" (replaces -1) (("1" (lemma "expt_plus_aux") (("1" (inst -1 "1 + j" "k" "2") (("1" (replaces -1) (("1" (case "expt(2,k) >= 2") (("1" (case "1 + expt(2, 1 + j)  <  expt(2, 1 + j) *  2  - 1 AND   expt(2, 1 + j) *  2  - 1 <= expt(2, 1 + j) * expt(2, k) - 1") (("1" (prop) (("1" (assert) nil nil)) nil) ("2" (prop) (("1" (assert) nil nil) ("2" (rewrite "both_sides_minus_le1") (("2" (lemma "both_sides_times_pos_le1") (("2" (inst -1 "expt(2, 1 + j)" "2" "expt(2,k)") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "k = 1") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (typepred "k") (("2" (lemma "increasing_expt_aux") (("2" (inst -1 "2" "k-2") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 " i - j") (("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (lemma "not_even_m1_pow") (("2" (inst?) (("2" (inst -2 "i") (("2" (assert) (("2" (expand "^" -1) (("2" (expand "^" -2) (("2" (replaces -1) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posnat_expt application-judgement "posnat" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (^ const-decl "real" exponentiation nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (expt_plus_aux formula-decl nil exponentiation nil) (nzreal nonempty-type-eq-decl nil reals nil) (/= const-decl "boolean" notequal nil) (expt def-decl "real" exponentiation nil) (even? const-decl "bool" integers nil) (not_even_m1_pow formula-decl nil exponentiation nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (increasing_expt_aux formula-decl nil exponentiation nil) (even_m1_pow formula-decl nil exponentiation nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (TRUE const-decl "bool" booleans nil) (both_sides_plus_le1 formula-decl nil real_props nil) (both_sides_times_pos_le1 formula-decl nil real_props nil) (int_times_even_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (<= const-decl "bool" reals nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (- const-decl "[numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (k skolem-const-decl "posnat" ford_johnson nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (both_sides_expt_gt1_lt_aux formula-decl nil exponentiation nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (int_plus_int_is_int application-judgement "int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (k skolem-const-decl "posnat" ford_johnson nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (both_sides_minus_le1 formula-decl nil real_props nil)) shostak) (t_is_increasing-2 nil 3734220884 ("" (skeep) (("" (prop) (("1" (expand "t") (("1" (rewrite "both_sides_div_pos_lt1") (("1" (expand "^") (("1" (lemma " both_sides_expt_gt1_lt_aux") (("1" (inst -1 "2" "i" "j") (("1" (assert) (("1" (case "EXISTS (k : posnat) : i+k = j") (("1" (skeep) (("1" (lemma "expt_plus_aux") (("1" (replace -2 1 rl) (("1" (inst -1 "i + 1" "k" "2") (("1" (replace -1 1) (("1" (case "expt(2, k) >= 2") (("1" (case "(expt(2, 1 + i) + expt((-1), i))  < (expt(2, i + 1) * 2 + expt((-1), i + k)) AND (expt(2, i + 1) * 2 + expt((-1), i + k)) < (expt(2, i + 1) * expt(2, k) + expt((-1), i + k))") (("1" (prop) (("1" (assert) nil nil)) nil) ("2" (prop) (("1" (hide 2) (("1" (case "even?(i) ") (("1" (case "even?(i + k)") (("1" (lemma "even_m1_pow") (("1" (lemma "even_m1_pow") (("1" (inst?) (("1" (inst -2 "i ") (("1" (assert) (("1" (expand "^" -1) (("1" (expand "^" -2) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (lemma "even_m1_pow") (("2" (inst -1 "i") (("2" (inst -2 "i + k") (("2" (assert) (("2" (expand "^" -1) (("2" (expand "^" -2) (("2" (replaces -1) (("2" (replaces -1) (("2" (assert) (("2" (case "expt(2, 1 + i) > 2") (("1" (assert) nil nil) ("2" (lemma "increasing_expt_aux") (("2" (inst -1 "2" "1 + i -2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "even?(i + k)") (("1" (lemma "not_even_m1_pow") (("1" (lemma "even_m1_pow") (("1" (inst?) (("1" (inst -2 "i") (("1" (assert) (("1" (expand "^" -1) (("1" (expand "^" -2) (("1" (replaces -1) (("1" (replaces -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "not_even_m1_pow") (("2" (lemma "not_even_m1_pow") (("2" (inst?) (("2" (inst -2 "i") (("2" (assert) (("2" (expand "^" -1) (("2" (expand "^" -2) (("2" (replaces -1) (("2" (replaces -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "both_sides_plus_lt1") (("2" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (case-replace "k = 1") (("1" (hide-all-but 1) (("1" (grind) nil nil)) nil) ("2" (lemma "increasing_expt_aux") (("2" (inst -1 "2" "k - 2") (("1" (assert) nil nil) ("2" (typepred "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "j - i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) nil nil) (t_is_increasing-1 nil 3734219093 ("" (skeep) (("" (prop) (("1" (expand "t") (("1" (rewrite "both_sides_div_pos_lt1") (("1" (expand "^") (("1" (lemma " both_sides_expt_gt1_lt_aux") (("1" (inst -1 "2" "i" "j") (("1" (assert) (("1" (case "EXISTS (k : posnat) : i+k = j") (("1" (skeep) (("1" (lemma "expt_plus_aux") (("1" (replace -2 1 rl) (("1" (inst -1 "i + 1" "k" "2") (("1" (replace -1 1) (("1" (case "expt(2, k) > 2") (("1" (postpone) nil nil) ("2" (lemma "increasing_expt_aux") (("2" (typepred "k") (("2" (case "k = 1") (("1" (replaces -1) (("1" (hide-all-but 1) (("1" (grind) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "j - i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil) nil shostak)) (t_is_unbounded 0 (t_is_unbounded-1 nil 3734227733 ("" (induct "i") (("1" (inst 1 "2") (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (lemma "t_is_increasing") (("2" (typepred "j_1") (("2" (case-replace "j_1=0") (("1" (assert) (("1" (hide -) (("1" (inst 1 "2") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (case-replace "j=0") (("1" (hide-all-but (-1 -3 -5 1)) (("1" (grind) nil nil)) nil) ("2" (inst -3 "j" "j+1") (("1" (inst 3 "j+1") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((t_is_increasing formula-decl nil ford_johnson nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (j skolem-const-decl "nat" ford_johnson nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nat_induction formula-decl nil naturalnumbers nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) shostak)) (t_qinversible_TCC1 0 (t_qinversible_TCC1-1 nil 3734425542 ("" (subtype-tcc) nil nil) nil shostak (t_qinversible subtype "(number_fields.-)(ford_johnson.k, 1)" "nat"))) (t_qinversible 0 (t_qinversible-1 nil 3734425565 ("" (induct "l") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skeep) (("3" (case-replace "j=0") (("1" (hide -2 -3) (("1" (inst 1 "2") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (skeep) (("2" (case-replace "t(k)=j") (("1" (inst 2 "k+1") (("1" (assert) (("1" (lemma "t_is_increasing") (("1" (inst -1 "k" "k+1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst 3 "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (t_is_increasing formula-decl nil ford_johnson nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nat_induction formula-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (maxk_TCC1 0 (maxk_TCC1-1 nil 3730794875 ("" (existence-tcc) (("" (lemma "t_qinversible") (("" (inst 1 "LAMBDA(l :above(1)) : choose({k: posnat | t(k - 1) < l AND t(k) >= l})") (("" (skeep) (("" (inst -1 "l") (("" (skeep) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak (maxk subtype "(number_fields.-)(ford_johnson.k, 1)" "nat"))) (maxk_TCC2 0 (maxk_TCC2-1 nil 3772304891 ("" (lemma "t_qinversible") (("" (inst 1 "LAMBDA (ll : posnat) : min({kk : above(1) |  t(kk-1) < ll AND t(kk)>=ll})") (("" (skeep) (("" (inst -1 "ll") (("" (expand "nonempty?") (("" (expand "empty?") (("" (skeep) (("" (inst -1 "k") (("1" (expand "member") (("1" (assert) nil nil)) nil) ("2" (case-replace "k=1") (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (set type-eq-decl nil sets nil) (nonempty? const-decl "bool" sets nil) (<= const-decl "bool" reals nil) (min const-decl "{a | S(a) AND (FORALL x: S(x) IMPLIES a <= x)}" min_nat nil) (empty? const-decl "bool" sets nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (k skolem-const-decl "posnat" ford_johnson nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member const-decl "bool" sets nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (t_qinversible formula-decl nil ford_johnson nil)) nil (maxk existence "" "[l: integers.posnat -> {k: integers.above(1) | booleans.AND(reals.<(ford_johnson.t((number_fields.-)(k, 1)), l), reals.>=(ford_johnson.t(k), l))}]"))) (maxk_correction 0 (maxk_correction-1 nil 3730796592 ("" (skeep) (("" (split) (("1" (flatten) (("1" (typepred "maxk(l)") (("1" (lemma "t_is_increasing") (("1" (inst -1 "k" "maxk(l)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "maxk(l)") (("2" (lemma "t_is_increasing") (("2" (case-replace "k = maxk(l) - 1") (("2" (inst -1 "k" "maxk(l) - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (above nonempty-type-eq-decl nil integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (t_is_increasing formula-decl nil ford_johnson nil) (= const-decl "[T, T -> boolean]" equalities nil) (l skolem-const-decl "posnat" ford_johnson nil)) shostak)) (upToOneIsCorrectAll_TCC1 0 (upToOneIsCorrectAll_TCC1-1 nil 3715773407 ("" (subtype-tcc) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (upToOne const-decl "finseq[nat]" ford_johnson nil)) shostak (upToOneIsCorrectAll subtype "ford_johnson.k" "below[length(upToOne(indx, i))]"))) (upToOneIsCorrectAll_TCC2 0 (upToOneIsCorrectAll_TCC2-1 nil 3715773407 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (insert? const-decl "finseq" seq_extras structures)) shostak (upToOneIsCorrectAll subtype "finite_sequences[nat].finseq_appl(ford_johnson.upToOne(ford_johnson.indx, ford_johnson.i))(ford_johnson.k)" "below[length(insert?[fjnode[T]](x, s, i))]"))) (upToOneIsCorrectAll_TCC3 0 (upToOneIsCorrectAll_TCC3-1 nil 3715773407 ("" (subtype-tcc) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak (upToOneIsCorrectAll subtype "ford_johnson.i" "upto[length(s)]"))) (upToOneIsCorrectAll 0 (upToOneIsCorrectAll-1 nil 3715773591 ("" (skeep) (("" (skeep) (("" (expand "finseq_appl") (("" (expand "insert?") (("" (expand "finseq_appl") (("" (lift-if) (("" (prop) (("1" (expand "upToOne") (("1" (lift-if) (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide-all-but (-1 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (rewrite "<") (("1" (assert) nil nil)) nil)) nil) ("2" (rewrite "<") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne" 2) (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("1" (hide -2 1 2) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (rewrite "<") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((insert? const-decl "finseq" seq_extras structures) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak)) (upToOnePreservesIndx_TCC1 0 (upToOnePreservesIndx_TCC1-1 nil 3764060742 ("" (subtype-tcc) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (is_sorted? const-decl "bool" sorting_seq nil) (is_indx? const-decl "bool" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (insert? const-decl "finseq" seq_extras structures)) nil (upToOnePreservesIndx subtype "seq_extras[fjnode_adt[ford_johnson.T].fjnode].insert?(ford_johnson.x, ford_johnson.s, ford_johnson.i)" "{s: finite_sequences[fjnode_adt[ford_johnson.T].fjnode].finseq | reals.>(length(s), 0)}"))) (upToOnePreservesIndx_TCC2 0 (upToOnePreservesIndx_TCC2-1 nil 3764060742 ("" (subtype-tcc) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (is_sorted? const-decl "bool" sorting_seq nil) (is_indx? const-decl "bool" ford_johnson nil) (upToOne const-decl "finseq[nat]" ford_johnson nil)) nil (upToOnePreservesIndx subtype "ford_johnson.upToOne(ford_johnson.indx, ford_johnson.i)" "{indx: finite_sequences[nat].finseq | reals.>(length(indx), 0)}"))) (upToOnePreservesIndx 0 (upToOnePreservesIndx-1 nil 3773148447 ("" (skeep) (("" (auto-rewrite "finseq_appl") (("" (expand "is_indx?") (("" (prop) (("1" (hide -2) (("1" (expand "upToOne") (("1" (expand "is_sorted?") (("1" (skeep) (("1" (inst -2 "k") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (skeep) (("2" (assert) (("2" (split) (("1" (inst -1 "i_1") (("1" (flatten) (("1" (expand "upToOne") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "insert?") (("1" (hide-all-but (-2 1)) (("1" (rewrite "<") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "insert?") (("2" (hide-all-but (-1 2)) (("2" (rewrite "<") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "insert?") (("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (typepred "i_1") (("1" (expand "upToOne") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (typepred "i_1") (("2" (expand "upToOne") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (lift-if) (("1" (prop) (("1" (typepred "j") (("1" (inst -6 "i_1") (("1" (flatten) (("1" (inst -6 "j") nil nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (hide -3) (("1" (grind) nil nil)) nil)) nil) ("2" (inst -2 "i_1") (("2" (flatten) (("2" (inst -3 "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((upToOne const-decl "finseq[nat]" ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (> const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (is_sorted? const-decl "bool" sorting_seq nil) (NOT const-decl "[bool -> bool]" booleans nil) (insert? const-decl "finseq" seq_extras structures) (indx skolem-const-decl "{indx: finseq[nat] | length(indx) > 0}" ford_johnson nil) (<= const-decl "bool" reals nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (s skolem-const-decl "{s: finseq[fjnode[T]] | length(s) > 0}" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (i skolem-const-decl "upto[length(s)]" ford_johnson nil) (i_1 skolem-const-decl "below[length(upToOne(indx, i))]" ford_johnson nil) (/= const-decl "boolean" notequal nil) (is_indx? const-decl "bool" ford_johnson nil)) shostak)) (bin_search_TCC1 0 (bin_search_TCC1-1 nil 3718042630 ("" (subtype-tcc) nil nil) nil shostak (bin_search subtype "(number_fields.-)(ford_johnson.j, ford_johnson.i)" "naturalnumber"))) (bin_search_TCC2 0 (bin_search_TCC2-1 nil 3718042630 ("" (subtype-tcc) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak (bin_search subtype "ford_johnson.i" "upto[j + 1]"))) (bin_search_TCC3 0 (bin_search_TCC3-1 nil 3718042630 ("" (subtype-tcc) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak (bin_search subtype "(number_fields.+)(ford_johnson.i, 1)" "upto[j + 1]"))) (bin_search_TCC4 0 (bin_search_TCC4-1 nil 3718042630 ("" (subtype-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (bin_search subtype "ford_johnson.l" "below[length(s)]"))) (bin_search_TCC5 0 (bin_search_TCC5-1 nil 3718042630 ("" (subtype-tcc) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (bin_search subtype "ford_johnson.l" "upto[j + 1]"))) (bin_search_TCC6 0 (bin_search_TCC6-1 nil 3718042630 ("" (subtype-tcc) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (bin_search subtype "ford_johnson.i" "upto[j + 1]"))) (bin_search_TCC7 0 (bin_search_TCC7-1 nil 3718042630 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (finseq type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (bin_search subtype "(number_fields.-)(ford_johnson.l, 1)" "{j: nat_types[length(ford_johnson.s)].below | reals.<=(ford_johnson.i, j)}"))) (bin_search_TCC8 0 (bin_search_TCC8-1 nil 3718042630 ("" (termination-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak (bin_search termination "ford_johnson.bin_search(ford_johnson.s)(ford_johnson.k)(ford_johnson.i, (number_fields.-)(ford_johnson.l, 1))" "nil"))) (bin_search_TCC9 0 (bin_search_TCC9-1 nil 3718042630 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (finseq type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (bin_search subtype "ford_johnson.bin_search(ford_johnson.s)(ford_johnson.k)(ford_johnson.i, (number_fields.-)(ford_johnson.l, 1))" "upto[j + 1]"))) (bin_search_TCC10 0 (bin_search_TCC10-1 nil 3718042630 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (finseq type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (int_minus_int_is_int application-judgement "int" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (bin_search subtype "(number_fields.+)(ford_johnson.l, 1)" "below[length(s)]"))) (bin_search_TCC11 0 (bin_search_TCC11-1 nil 3718042630 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (finseq type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (bin_search subtype "ford_johnson.j" "{j: nat_types[length(ford_johnson.s)].below | reals.<=((number_fields.+)(1, ford_johnson.l), j)}"))) (bin_search_TCC12 0 (bin_search_TCC12-1 nil 3718042630 ("" (termination-tcc) nil nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak (bin_search termination "ford_johnson.bin_search(ford_johnson.s)(ford_johnson.k)((number_fields.+)(ford_johnson.l, 1), ford_johnson.j)" "nil"))) (b_search_bound 0 (b_search_bound-1 nil 3783111794 ("" (skeep) (("" (skeep) (("" (measure-induct "j-i" ("i" "j")) (("" (assert) (("" (skeep) (("" (expand "bin_search" +) (("" (lift-if) (("" (ground) (("1" (expand "finseq_appl") (("1" (inst?) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (inst?) (("2" (assert) (("2" (grind) nil nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (integer nonempty-type-from-decl nil integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (int_minus_int_is_int application-judgement "int" integers nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (b_search_preserves_sorting_TCC1 0 (b_search_preserves_sorting_TCC1-1 nil 3725215655 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (fjnode type-decl nil fjnode_adt nil) (finseq type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil ford_johnson nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil)) shostak (b_search_preserves_sorting subtype "(number_fields.-)(ford_johnson.i, 1)" "below[length(s)]"))) (b_search_preserves_sorting_TCC2 0 (b_search_preserves_sorting_TCC2-1 nil 3725215655 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (fjnode type-decl nil fjnode_adt nil) (finseq type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil ford_johnson nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil)) shostak (b_search_preserves_sorting subtype "(number_fields.+)(ford_johnson.j, 1)" "below[length(s)]"))) (b_search_preserves_sorting_TCC3 0 (b_search_preserves_sorting_TCC3-1 nil 3725215655 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (fjnode type-decl nil fjnode_adt nil) (finseq type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil ford_johnson nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil)) shostak (b_search_preserves_sorting subtype "ford_johnson.bin_search(ford_johnson.s)(ford_johnson.k)(ford_johnson.i, ford_johnson.j)" "upto[length(s)]"))) (b_search_preserves_sorting 0 (b_search_preserves_sorting-4 nil 3797760786 ("" (skeep) (("" (skeep) (("" (measure-induct "j-i" ("i" "j")) (("1" (skeep) (("1" (expand "is_sorted?" +) (("1" (auto-rewrite "finseq_appl") (("1" (skeep) (("1" (assert) (("1" (case " bin_search(s)(k)(x_1, x_2) < i") (("1" (expand "insert?" +) (("1" (assert) (("1" (hide -2) (("1" (expand "is_sorted?") (("1" (inst -2 "i-1") (("1" (assert) (("1" (typepred "i") (("1" (expand "insert?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case " bin_search(s)(k)(x_1, x_2) > i+1") (("1" (expand "insert?" +) (("1" (assert) (("1" (hide -2) (("1" (expand "is_sorted?") (("1" (inst -2 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "bin_search(s)(k)(x_1, x_2) = i") (("1" (hide 1 2) (("1" (expand "insert?" +) (("1" (assert) (("1" (expand "bin_search" -1) (("1" (assert) (("1" (lift-if) (("1" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (split -6) (("1" (expand "insert?" -7) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -6) (("1" (replaces) (("1" (assert) (("1" (typepred "leq") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (replaces) (("2" (assert) (("2" (typepred "leq") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (replace -2) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst? -3) (("1" (assert) (("1" (split -3) (("1" (expand "is_sorted?") (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst? -2) (("2" (assert) (("2" (split) (("1" (expand "is_sorted?") (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "leq") (("2" (expand "total_preorder?") (("2" (flatten) (("2" (expand "dichotomous?") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace " bin_search(s)(k)(x_1, x_2) = i + 1") (("1" (hide 1 2 3) (("1" (expand "insert?" +) (("1" (assert) (("1" (expand "bin_search" -1) (("1" (lift-if) (("1" (assert) (("1" (split -1) (("1" (typepred "leq") (("1" (flatten) (("1" (split -3) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (replaces -3 :dir rl) (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (replace -2) (("1" (hide -3) (("1" (expand "is_sorted?") (("1" (inst -3 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (swap-rel -1) (("1" (replaces -1) (("1" (replaces -1) (("1" (hide -2) (("1" (expand "is_sorted?") (("1" (inst -2 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst? -3) (("1" (assert) (("1" (split -3) (("1" (expand "is_sorted?") (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst?) (("2" (assert) (("2" (split -2) (("1" (expand "is_sorted?") (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 2 3)) (("2" (typepred "leq") (("2" (expand "total_preorder?") (("2" (flatten) (("2" (expand "dichotomous?") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (assert) nil nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (assert) nil nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (assert) nil nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (assert) nil nil)) nil)) nil) ("11" (hide 2) (("11" (skeep) (("11" (assert) nil nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (assert) nil nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (dichotomous? const-decl "bool" orders nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil) (TRUE const-decl "bool" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (integer nonempty-type-from-decl nil integers nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (x_1 skolem-const-decl "below[length(s)]" ford_johnson nil) (x_2 skolem-const-decl "{j: below[length(s)] | x_1 <= j}" ford_johnson nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (insert? const-decl "finseq" seq_extras structures) (upto nonempty-type-eq-decl nil nat_types nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[fjnode -> T]" fjnode_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (k skolem-const-decl "fjnode[T]" ford_johnson nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (s skolem-const-decl "finseq[fjnode[T]]" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (int_minus_int_is_int application-judgement "int" integers nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil) (b_search_preserves_sorting-3 nil 3797585463 ("" (skeep) (("" (skeep) (("" (measure-induct "j-i" ("i" "j")) (("1" (skeep) (("1" (expand "is_sorted?" +) (("1" (auto-rewrite "finseq_appl") (("1" (skeep) (("1" (assert) (("1" (case " bin_search(s)(k)(x_1, x_2) < i") (("1" (expand "insert?" +) (("1" (assert) (("1" (hide -2) (("1" (expand "is_sorted?") (("1" (inst -2 "i-1") (("1" (assert) (("1" (typepred "i") (("1" (expand "insert?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case " bin_search(s)(k)(x_1, x_2) > i+1") (("1" (expand "insert?" +) (("1" (assert) (("1" (hide -2) (("1" (expand "is_sorted?") (("1" (inst -2 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "bin_search(s)(k)(x_1, x_2) = i") (("1" (hide 1 2) (("1" (expand "insert?" +) (("1" (assert) (("1" (expand "bin_search" -1) (("1" (assert) (("1" (lift-if) (("1" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (split -6) (("1" (expand "insert?" -7) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -6) (("1" (replaces) (("1" (assert) (("1" (typepred "<=") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (replaces) (("2" (assert) (("2" (typepred "<=") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (replace -2) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst? -3) (("1" (assert) (("1" (split -3) (("1" (expand "is_sorted?") (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst? -2) (("2" (assert) (("2" (split) (("1" (expand "is_sorted?") (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "<=") (("2" (expand "total_preorder?") (("2" (flatten) (("2" (expand "dichotomous?") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace " bin_search(s)(k)(x_1, x_2) = i + 1") (("1" (hide 1 2 3) (("1" (expand "insert?" +) (("1" (assert) (("1" (expand "bin_search" -1) (("1" (lift-if) (("1" (assert) (("1" (split -1) (("1" (typepred "<=") (("1" (flatten) (("1" (split -3) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (replaces -3 :dir rl) (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (replace -2) (("1" (hide -3) (("1" (expand "is_sorted?") (("1" (inst -3 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (swap-rel -1) (("1" (replaces -1) (("1" (replaces -1) (("1" (hide -2) (("1" (expand "is_sorted?") (("1" (inst -2 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst? -3) (("1" (assert) (("1" (split -3) (("1" (expand "is_sorted?") (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst?) (("2" (assert) (("2" (split -2) (("1" (expand "is_sorted?") (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 2 3)) (("2" (typepred "<=") (("2" (expand "total_preorder?") (("2" (flatten) (("2" (expand "dichotomous?") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (assert) nil nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (assert) nil nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (assert) nil nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (assert) nil nil)) nil)) nil) ("11" (hide 2) (("11" (skeep) (("11" (assert) nil nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (assert) nil nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (assert) nil nil)) nil)) nil) ("14" (grind) nil nil) ("15" (grind) nil nil) ("16" (hide 2) (("16" (expand "well_founded?") (("16" (skeep* :preds? t) (("16" (inst -2 "p") (("16" (prop) (("1" (skeep) (("1" (inst 1 "y!1") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (dichotomous? const-decl "bool" orders nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil) (TRUE const-decl "bool" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (integer nonempty-type-from-decl nil integers nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (insert? const-decl "finseq" seq_extras structures) (upto nonempty-type-eq-decl nil nat_types nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[fjnode -> T]" fjnode_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (int_minus_int_is_int application-judgement "int" integers nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil) (b_search_preserves_sorting-2 nil 3797070525 ("" (skeep) (("" (skeep) (("" (measure-induct "j-i" ("i" "j")) (("1" (skeep) (("1" (expand "is_sorted?" +) (("1" (auto-rewrite "finseq_appl") (("1" (skeep) (("1" (assert) (("1" (case " bin_search(s)(k)(x_1, x_2) < i") (("1" (expand "insert?" +) (("1" (assert) (("1" (hide -2) (("1" (expand "is_sorted?") (("1" (inst -2 "i-1") (("1" (assert) (("1" (typepred "i") (("1" (expand "insert?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case " bin_search(s)(k)(x_1, x_2) > i+1") (("1" (expand "insert?" +) (("1" (assert) (("1" (hide -2) (("1" (expand "is_sorted?") (("1" (inst -2 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "bin_search(s)(k)(x_1, x_2) = i") (("1" (hide 1 2) (("1" (expand "insert?" +) (("1" (assert) (("1" (expand "bin_search" -1) (("1" (assert) (("1" (lift-if) (("1" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (split -6) (("1" (expand "insert?" -7) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -6) (("1" (replaces) (("1" (assert) (("1" (typepred "<=") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (replaces) (("2" (assert) (("2" (typepred "<=") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (replace -2) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst? -3) (("1" (assert) (("1" (split -3) (("1" (expand "is_sorted?") (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst? -2) (("2" (assert) (("2" (split) (("1" (expand "is_sorted?") (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "<=") (("2" (expand "total_preorder?") (("2" (flatten) (("2" (expand "dichotomous?") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace " bin_search(s)(k)(x_1, x_2) = i + 1") (("1" (hide 1 2 3) (("1" (expand "insert?" +) (("1" (assert) (("1" (expand "bin_search" -1) (("1" (lift-if) (("1" (assert) (("1" (split -1) (("1" (typepred "<=") (("1" (flatten) (("1" (split -3) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (replaces -3 :dir rl) (("2" (replaces -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (replace -1) (("1" (replace -2) (("1" (hide -3) (("1" (expand "is_sorted?") (("1" (inst -3 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split -1) (("1" (flatten) (("1" (split -2) (("1" (flatten) (("1" (swap-rel -1) (("1" (replaces -1) (("1" (replaces -1) (("1" (hide -2) (("1" (expand "is_sorted?") (("1" (inst -2 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst? -3) (("1" (assert) (("1" (split -3) (("1" (expand "is_sorted?") (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil) ("3" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst?) (("2" (assert) (("2" (split -2) (("1" (expand "is_sorted?") (("1" (inst -1 "i") (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1 2 3)) (("2" (typepred "<=") (("2" (expand "total_preorder?") (("2" (flatten) (("2" (expand "dichotomous?") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil) ("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (assert) nil nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (assert) nil nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (assert) nil nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (assert) nil nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (assert) nil nil)) nil)) nil) ("11" (hide 2) (("11" (skeep) (("11" (assert) nil nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (assert) nil nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (assert) nil nil)) nil)) nil) ("14" (grind) nil nil) ("15" (grind) nil nil) ("16" (hide 2) (("16" (expand "well_founded?") (("16" (skeep* :preds? t) (("16" (inst -2 "p") (("16" (prop) (("1" (skeep) (("1" (inst 1 "y!1") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (dichotomous? const-decl "bool" orders nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil) (TRUE const-decl "bool" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (integer nonempty-type-from-decl nil integers nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (insert? const-decl "finseq" seq_extras structures) (upto nonempty-type-eq-decl nil nat_types nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[fjnode -> T]" fjnode_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (reflexive_restrict application-judgement "(reflexive?[S])" restrict_order_props nil) (antisymmetric_restrict application-judgement "(antisymmetric?[S])" restrict_order_props nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (preorder_restrict application-judgement "(preorder?[S])" restrict_order_props nil) (partial_order_restrict application-judgement "(partial_order?[S])" restrict_order_props nil) (dichotomous_restrict application-judgement "(dichotomous?[S])" restrict_order_props nil) (total_order_restrict application-judgement "(total_order?[S])" restrict_order_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil) (b_search_preserves_sorting-1 nil 3732669463 ("" (skeep) (("" (skeep) (("" (postpone) nil nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (integer nonempty-type-from-decl nil integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (insert? const-decl "finseq" seq_extras structures) (upto nonempty-type-eq-decl nil nat_types nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[fjnode -> T]" fjnode_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (fjnode type-decl nil fjnode_adt nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (int_minus_int_is_int application-judgement "int" integers nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (b_search_removeSon_TCC1 0 (b_search_removeSon_TCC1-1 nil 3782727301 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (finseq type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (b_search_removeSon subtype "(number_fields.-)(ford_johnson.i, 1)" "below[length(s)]"))) (b_search_removeSon_TCC2 0 (b_search_removeSon_TCC2-1 nil 3782727301 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (finseq type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (b_search_removeSon subtype "(number_fields.+)(ford_johnson.j, 1)" "below[length(s)]"))) (b_search_removeSon_TCC3 0 (b_search_removeSon_TCC3-1 nil 3782727301 ("" (subtype-tcc) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil)) nil (b_search_removeSon subtype "ford_johnson.i" "below[length(removeSon(s, indx))]"))) (b_search_removeSon_TCC4 0 (b_search_removeSon_TCC4-1 nil 3782727301 ("" (subtype-tcc) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil)) nil (b_search_removeSon subtype "ford_johnson.j" "{j: nat_types[length(ford_johnson.removeSon(ford_johnson.s, ford_johnson.indx))].below | reals.<=(ford_johnson.i, j)}"))) (b_search_removeSon 0 (b_search_removeSon-3 nil 3797760836 ("" (skeep) (("" (skeep) (("" (skeep) (("" (measure-induct "j-i" ("i" "j")) (("1" (skeep) (("1" (auto-rewrite "finseq_appl") (("1" (assert) (("1" (expand "bin_search" 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand "finseq_appl") (("1" (expand "bin_search" 1) (("1" (assert) (("1" (expand "removeSon" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "bin_search" +) (("2" (assert) (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "bin_search" +) (("3" (assert) (("3" (expand "removeSon") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (expand "bin_search" +) (("4" (expand "removeSon" +) (("4" (assert) (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (inst?) (("1" (assert) (("1" (expand "bin_search" 2 2) (("1" (assert) (("1" (expand "removeSon" 2 (1 2)) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("6" (inst?) (("6" (assert) (("6" (expand "bin_search" 2 2) (("6" (expand "removeSon" 2 (1 2)) (("6" (assert) (("6" (assert) (("6" (typepred "leq") (("6" (hide 2) (("6" (expand "total_preorder?") (("6" (flatten) (("6" (expand "dichotomous?") (("6" (inst?) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand "bin_search" +) (("7" (assert) (("7" (expand "removeSon" +) (("7" (assert) nil nil)) nil)) nil)) nil) ("8" (assert) (("8" (expand "bin_search" +) (("8" (expand "removeSon" +) (("8" (assert) (("8" (assert) nil nil)) nil)) nil)) nil)) nil) ("9" (expand "bin_search" +) (("9" (expand "removeSon" +) (("9" (assert) (("9" (assert) nil nil)) nil)) nil)) nil) ("10" (expand "bin_search" +) (("10" (expand "removeSon" +) (("10" (assert) (("10" (assert) nil nil)) nil)) nil)) nil) ("11" (inst?) (("1" (assert) (("1" (expand "bin_search" 2 2) (("1" (expand "removeSon" 2 (1 2)) (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("12" (inst?) (("12" (expand "bin_search" 2 2) (("12" (assert) (("12" (assert) (("12" (expand "removeSon" 2 (1 2)) (("12" (assert) (("12" (typepred "leq") (("12" (hide 2) (("12" (expand "total_preorder?") (("12" (flatten) (("12" (expand "dichotomous?") (("12" (inst?) (("12" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("13" (expand "bin_search" +) (("13" (expand "removeSon" +) (("13" (assert) (("13" (assert) nil nil)) nil)) nil)) nil) ("14" (expand "bin_search" +) (("14" (expand "removeSon" +) (("14" (assert) (("14" (assert) nil nil)) nil)) nil)) nil) ("15" (expand "bin_search" +) (("15" (expand "removeSon" +) (("15" (assert) (("15" (assert) nil nil)) nil)) nil)) nil) ("16" (expand "bin_search" +) (("16" (expand "removeSon" +) (("16" (assert) (("16" (assert) nil nil)) nil)) nil)) nil) ("17" (inst?) (("1" (assert) (("1" (expand "bin_search" 2 2) (("1" (expand "removeSon" 2 (1 2)) (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("18" (inst?) (("18" (assert) (("18" (expand "bin_search" 2 2) (("18" (expand "removeSon" 2 (1 2)) (("18" (assert) (("18" (assert) (("18" (typepred "leq") (("18" (hide 2) (("18" (expand "total_preorder?") (("18" (flatten) (("18" (expand "dichotomous?") (("18" (inst?) (("18" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("19" (expand "bin_search" +) (("19" (expand "removeSon" +) (("19" (assert) (("19" (assert) nil nil)) nil)) nil)) nil) ("20" (expand "bin_search" +) (("20" (expand "removeSon" +) (("20" (assert) (("20" (assert) nil nil)) nil)) nil)) nil) ("21" (expand "bin_search" +) (("21" (expand "removeSon" +) (("21" (assert) (("21" (assert) nil nil)) nil)) nil)) nil) ("22" (expand "bin_search" +) (("22" (expand "removeSon" +) (("22" (assert) (("22" (assert) nil nil)) nil)) nil)) nil) ("23" (inst?) (("1" (assert) (("1" (expand "bin_search" 2 2) (("1" (expand "removeSon" 2 (1 2)) (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("24" (inst?) (("24" (assert) (("24" (expand "bin_search" 2 2) (("24" (expand "removeSon" 2 (1 2)) (("24" (assert) (("24" (assert) (("24" (typepred "leq") (("24" (hide 2) (("24" (expand "total_preorder?") (("24" (flatten) (("24" (expand "dichotomous?") (("24" (inst?) (("24" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "removeSon") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (expand "removeSon") (("6" (assert) nil nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (expand "removeSon") (("7" (assert) nil nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (expand "removeSon") (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (expand "removeSon") (("9" (assert) nil nil)) nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (expand "removeSon") (("10" (assert) nil nil)) nil)) nil)) nil) ("11" (hide 2) (("11" (skeep) (("11" (expand "removeSon") (("11" (assert) nil nil)) nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (assert) nil nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (assert) nil nil)) nil)) nil) ("14" (hide 2) (("14" (skeep) (("14" (assert) (("14" (grind) nil nil)) nil)) nil)) nil) ("15" (hide 2) (("15" (skeep) (("15" (assert) (("15" (grind) nil nil)) nil)) nil)) nil) ("16" (hide 2) (("16" (skeep) (("16" (assert) nil nil)) nil)) nil) ("17" (hide 2) (("17" (skeep) (("17" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (int_minus_int_is_int application-judgement "int" integers nil) (measure_induction formula-decl nil measure_induction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (finseq type-eq-decl nil finite_sequences nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (wf_nat formula-decl nil naturalnumbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (s skolem-const-decl "finseq[fjnode[T]]" ford_johnson nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (k skolem-const-decl "fjnode[T]" ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (val adt-accessor-decl "[fjnode -> T]" fjnode_adt nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (indx skolem-const-decl "nat" ford_johnson nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (x_2 skolem-const-decl "{j: below[length(s)] | x_1 <= j}" ford_johnson nil) (x_1 skolem-const-decl "below[length(s)]" ford_johnson nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (integer nonempty-type-from-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (dichotomous? const-decl "bool" orders nil)) nil) (b_search_removeSon-2 nil 3797585520 ("" (skeep) (("" (skeep) (("" (skeep) (("" (measure-induct "j-i" ("i" "j")) (("1" (skeep) (("1" (auto-rewrite "finseq_appl") (("1" (assert) (("1" (expand "bin_search" 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand "finseq_appl") (("1" (expand "bin_search" 1) (("1" (assert) (("1" (expand "removeSon" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "bin_search" +) (("2" (assert) (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "bin_search" +) (("3" (assert) (("3" (expand "removeSon") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (expand "bin_search" +) (("4" (expand "removeSon" +) (("4" (assert) (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (inst?) (("1" (assert) (("1" (expand "bin_search" 2 2) (("1" (assert) (("1" (expand "removeSon" 2 (1 2)) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("6" (inst?) (("6" (assert) (("6" (expand "bin_search" 2 2) (("6" (expand "removeSon" 2 (1 2)) (("6" (assert) (("6" (assert) (("6" (typepred "<=") (("6" (hide 2) (("6" (expand "total_preorder?") (("6" (flatten) (("6" (expand "dichotomous?") (("6" (inst?) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand "bin_search" +) (("7" (assert) (("7" (expand "removeSon" +) (("7" (assert) nil nil)) nil)) nil)) nil) ("8" (assert) (("8" (expand "bin_search" +) (("8" (expand "removeSon" +) (("8" (assert) (("8" (assert) nil nil)) nil)) nil)) nil)) nil) ("9" (expand "bin_search" +) (("9" (expand "removeSon" +) (("9" (assert) (("9" (assert) nil nil)) nil)) nil)) nil) ("10" (expand "bin_search" +) (("10" (expand "removeSon" +) (("10" (assert) (("10" (assert) nil nil)) nil)) nil)) nil) ("11" (inst?) (("1" (assert) (("1" (expand "bin_search" 2 2) (("1" (expand "removeSon" 2 (1 2)) (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("12" (inst?) (("12" (expand "bin_search" 2 2) (("12" (assert) (("12" (assert) (("12" (expand "removeSon" 2 (1 2)) (("12" (assert) (("12" (typepred "<=") (("12" (hide 2) (("12" (expand "total_preorder?") (("12" (flatten) (("12" (expand "dichotomous?") (("12" (inst?) (("12" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("13" (expand "bin_search" +) (("13" (expand "removeSon" +) (("13" (assert) (("13" (assert) nil nil)) nil)) nil)) nil) ("14" (expand "bin_search" +) (("14" (expand "removeSon" +) (("14" (assert) (("14" (assert) nil nil)) nil)) nil)) nil) ("15" (expand "bin_search" +) (("15" (expand "removeSon" +) (("15" (assert) (("15" (assert) nil nil)) nil)) nil)) nil) ("16" (expand "bin_search" +) (("16" (expand "removeSon" +) (("16" (assert) (("16" (assert) nil nil)) nil)) nil)) nil) ("17" (inst?) (("1" (assert) (("1" (expand "bin_search" 2 2) (("1" (expand "removeSon" 2 (1 2)) (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("18" (inst?) (("18" (assert) (("18" (expand "bin_search" 2 2) (("18" (expand "removeSon" 2 (1 2)) (("18" (assert) (("18" (assert) (("18" (typepred "<=") (("18" (hide 2) (("18" (expand "total_preorder?") (("18" (flatten) (("18" (expand "dichotomous?") (("18" (inst?) (("18" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("19" (expand "bin_search" +) (("19" (expand "removeSon" +) (("19" (assert) (("19" (assert) nil nil)) nil)) nil)) nil) ("20" (expand "bin_search" +) (("20" (expand "removeSon" +) (("20" (assert) (("20" (assert) nil nil)) nil)) nil)) nil) ("21" (expand "bin_search" +) (("21" (expand "removeSon" +) (("21" (assert) (("21" (assert) nil nil)) nil)) nil)) nil) ("22" (expand "bin_search" +) (("22" (expand "removeSon" +) (("22" (assert) (("22" (assert) nil nil)) nil)) nil)) nil) ("23" (inst?) (("1" (assert) (("1" (expand "bin_search" 2 2) (("1" (expand "removeSon" 2 (1 2)) (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("24" (inst?) (("24" (assert) (("24" (expand "bin_search" 2 2) (("24" (expand "removeSon" 2 (1 2)) (("24" (assert) (("24" (assert) (("24" (typepred "<=") (("24" (hide 2) (("24" (expand "total_preorder?") (("24" (flatten) (("24" (expand "dichotomous?") (("24" (inst?) (("24" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "removeSon") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (expand "removeSon") (("6" (assert) nil nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (expand "removeSon") (("7" (assert) nil nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (expand "removeSon") (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (expand "removeSon") (("9" (assert) nil nil)) nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (expand "removeSon") (("10" (assert) nil nil)) nil)) nil)) nil) ("11" (hide 2) (("11" (skeep) (("11" (expand "removeSon") (("11" (assert) nil nil)) nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (assert) nil nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (assert) nil nil)) nil)) nil) ("14" (hide 2) (("14" (skeep) (("14" (assert) (("14" (grind) nil nil)) nil)) nil)) nil) ("15" (hide 2) (("15" (skeep) (("15" (assert) (("15" (grind) nil nil)) nil)) nil)) nil) ("16" (hide 2) (("16" (skeep) (("16" (assert) nil nil)) nil)) nil) ("17" (hide 2) (("17" (skeep) (("17" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((dichotomous? const-decl "bool" orders nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (integer nonempty-type-from-decl nil integers nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (val adt-accessor-decl "[fjnode -> T]" fjnode_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (int_minus_int_is_int application-judgement "int" integers nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil) (b_search_removeSon-1 nil 3783110107 ("" (skeep) (("" (skeep) (("" (skeep) (("" (measure-induct "j-i" ("i" "j")) (("1" (skeep) (("1" (auto-rewrite "finseq_appl") (("1" (assert) (("1" (expand "bin_search" 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand "finseq_appl") (("1" (expand "bin_search" 1) (("1" (assert) (("1" (expand "removeSon" 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "bin_search" +) (("2" (assert) (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "bin_search" +) (("3" (assert) (("3" (expand "removeSon") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (expand "bin_search" +) (("4" (expand "removeSon" +) (("4" (assert) (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (inst?) (("1" (assert) (("1" (expand "bin_search" 2 2) (("1" (assert) (("1" (expand "removeSon" 2 (1 2)) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("6" (inst?) (("6" (assert) (("6" (expand "bin_search" 2 2) (("6" (expand "removeSon" 2 (1 2)) (("6" (assert) (("6" (assert) (("6" (typepred "<=") (("6" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (expand "bin_search" +) (("7" (assert) (("7" (expand "removeSon" +) (("7" (assert) nil nil)) nil)) nil)) nil) ("8" (assert) (("8" (expand "bin_search" +) (("8" (expand "removeSon" +) (("8" (assert) (("8" (assert) nil nil)) nil)) nil)) nil)) nil) ("9" (expand "bin_search" +) (("9" (expand "removeSon" +) (("9" (assert) (("9" (assert) nil nil)) nil)) nil)) nil) ("10" (expand "bin_search" +) (("10" (expand "removeSon" +) (("10" (assert) (("10" (assert) nil nil)) nil)) nil)) nil) ("11" (inst?) (("1" (assert) (("1" (expand "bin_search" 2 2) (("1" (expand "removeSon" 2 (1 2)) (("1" (assert) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("12" (inst?) (("12" (expand "bin_search" 2 2) (("12" (assert) (("12" (assert) (("12" (expand "removeSon" 2 (1 2)) (("12" (assert) (("12" (typepred "<=") (("12" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("13" (expand "bin_search" +) (("13" (expand "removeSon" +) (("13" (assert) (("13" (assert) nil nil)) nil)) nil)) nil) ("14" (expand "bin_search" +) (("14" (expand "removeSon" +) (("14" (assert) (("14" (assert) nil nil)) nil)) nil)) nil) ("15" (expand "bin_search" +) (("15" (expand "removeSon" +) (("15" (assert) (("15" (assert) nil nil)) nil)) nil)) nil) ("16" (expand "bin_search" +) (("16" (expand "removeSon" +) (("16" (assert) (("16" (assert) nil nil)) nil)) nil)) nil) ("17" (inst?) (("1" (assert) (("1" (expand "bin_search" 2 2) (("1" (expand "removeSon" 2 (1 2)) (("1" (assert) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("18" (inst?) (("18" (assert) (("18" (expand "bin_search" 2 2) (("18" (expand "removeSon" 2 (1 2)) (("18" (assert) (("18" (assert) (("18" (typepred "<=") (("18" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("19" (expand "bin_search" +) (("19" (expand "removeSon" +) (("19" (assert) (("19" (assert) nil nil)) nil)) nil)) nil) ("20" (expand "bin_search" +) (("20" (expand "removeSon" +) (("20" (assert) (("20" (assert) nil nil)) nil)) nil)) nil) ("21" (expand "bin_search" +) (("21" (expand "removeSon" +) (("21" (assert) (("21" (assert) nil nil)) nil)) nil)) nil) ("22" (expand "bin_search" +) (("22" (expand "removeSon" +) (("22" (assert) (("22" (assert) nil nil)) nil)) nil)) nil) ("23" (inst?) (("1" (assert) (("1" (expand "bin_search" 2 2) (("1" (expand "removeSon" 2 (1 2)) (("1" (assert) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("24" (inst?) (("24" (assert) (("24" (expand "bin_search" 2 2) (("24" (expand "removeSon" 2 (1 2)) (("24" (assert) (("24" (assert) (("24" (typepred "<=") (("24" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (expand "removeSon") (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (assert) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (expand "removeSon") (("6" (assert) nil nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (expand "removeSon") (("7" (assert) nil nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (expand "removeSon") (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (expand "removeSon") (("9" (assert) nil nil)) nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (expand "removeSon") (("10" (assert) nil nil)) nil)) nil)) nil) ("11" (hide 2) (("11" (skeep) (("11" (expand "removeSon") (("11" (assert) nil nil)) nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (assert) nil nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (assert) nil nil)) nil)) nil) ("14" (hide 2) (("14" (skeep) (("14" (assert) nil nil)) nil)) nil) ("15" (hide 2) (("15" (skeep) (("15" (assert) nil nil)) nil)) nil) ("16" (hide 2) (("16" (skeep) (("16" (assert) (("16" (grind) nil nil)) nil)) nil)) nil) ("17" (hide 2) (("17" (skeep) (("17" (assert) (("17" (grind) nil nil)) nil)) nil)) nil) ("18" (grind) nil nil) ("19" (grind) nil nil) ("20" (hide 2) (("20" (expand "well_founded?") (("20" (skeep* :preds? t) (("20" (inst -2 "p") (("20" (prop) (("1" (skeep) (("1" (inst 1 "y!1") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (int_minus_int_is_int application-judgement "int" integers nil) (total_order_restrict application-judgement "(total_order?[S])" restrict_order_props nil) (dichotomous_restrict application-judgement "(dichotomous?[S])" restrict_order_props nil) (partial_order_restrict application-judgement "(partial_order?[S])" restrict_order_props nil) (preorder_restrict application-judgement "(preorder?[S])" restrict_order_props nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (antisymmetric_restrict application-judgement "(antisymmetric?[S])" restrict_order_props nil) (reflexive_restrict application-judgement "(reflexive?[S])" restrict_order_props nil) (measure_induction formula-decl nil measure_induction nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (finseq type-eq-decl nil finite_sequences nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (restrict const-decl "R" restrict nil) (wf_nat formula-decl nil naturalnumbers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (val adt-accessor-decl "[fjnode -> T]" fjnode_adt nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (integer nonempty-type-from-decl nil integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (dichotomous? const-decl "bool" orders nil) (preorder? const-decl "bool" orders nil) (transitive? const-decl "bool" relations nil) (reflexive? const-decl "bool" relations nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil)) shostak)) (PartialERforK?_TCC1 0 (PartialERforK?_TCC1-1 nil 3736839382 ("" (subtype-tcc) nil nil) nil nil (PartialERforK? subtype "ford_johnson.s`seqfj" "{s: finite_sequences[fjnode_adt[ford_johnson.T].fjnode].finseq | reals.>(length(s), 0)}"))) (PartialERforK?_TCC2 0 (PartialERforK?_TCC2-1 nil 3747585293 ("" (subtype-tcc) nil nil) ((posnat_expt application-judgement "posnat" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (^ const-decl "real" exponentiation nil)) nil (PartialERforK? subtype "(number_fields.-)(ford_johnson.n, 1)" "nat"))) (PartialERforK?_TCC3 0 (PartialERforK?_TCC3-1 nil 3747585293 ("" (skeep* :preds? t) (("" (hide-all-but (-1 -6 1)) (("" (expand "finseq_appl") (("" (expand "is_indx?") (("" (expand "finseq_appl") (("" (flatten) (("" (inst?) (("" (flatten) (("" (assert) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((is_indx? const-decl "bool" ford_johnson nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (PartialERforK? subtype "finite_sequences[nat].finseq_appl(ford_johnson.indx)(ford_johnson.i)" "below[length(s`seqfj)]"))) (PartialERforK?_TCC4 0 (PartialERforK?_TCC4-1 nil 3747585293 ("" (subtype-tcc) nil nil) ((posnat_expt application-judgement "posnat" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_minus_int_is_int application-judgement "int" integers nil) (/= const-decl "boolean" notequal nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (^ const-decl "real" exponentiation nil)) nil (PartialERforK? subtype "(number_fields.-)(ford_johnson.n, 1)" "nat"))) (PartialERforK?_TCC5 0 (PartialERforK?_TCC5-1 nil 3747585293 ("" (skeep* :preds? t) (("" (hide-all-but (-1 -6 2)) (("" (expand "is_indx?") (("" (flatten) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((<= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (is_indx? const-decl "bool" ford_johnson nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (PartialERforK? subtype "finite_sequences[nat].finseq_appl(ford_johnson.indx)(ford_johnson.i)" "below[length(s`seqfj)]"))) (oddNstructDeconstruction_TCC1 0 (oddNstructDeconstruction_TCC1-1 nil 3764066435 ("" (skeep) (("" (expand "length") (("" (assert) nil nil)) nil)) nil) ((length def-decl "nat" list_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil)) nil (oddNstructDeconstruction subtype "0" "below[length[fjnode[T]](s`oddList)]"))) (oddNstructDeconstruction_TCC2 0 (oddNstructDeconstruction_TCC2-1 nil 3764066435 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil)) nil (oddNstructDeconstruction subtype "ford_johnson.s`oddList" "(list_adt[fjnode_adt[ford_johnson.T].fjnode].cons?)"))) (oddNstructDeconstruction_TCC3 0 (oddNstructDeconstruction_TCC3-1 nil 3764066435 ("" (subtype-tcc) nil nil) ((oddNstructPreservation? const-decl "bool" ford_johnson nil)) nil (oddNstructDeconstruction subtype "(# seqfj := ford_johnson.s`seqfj, oddList := list_adt[fjnode_adt[ford_johnson.T].fjnode].cdr(ford_johnson.s`oddList) #)" "{s: firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].finseqfj | reals.>(length(s`seqfj), 0)}"))) (oddNstructDeconstruction 0 (oddNstructDeconstruction-1 nil 3764066441 ("" (skeep) (("" (prop) (("1" (expand "oddNstructPreservation?") (("1" (flatten) (("1" (prop) (("1" (skeep) (("1" (inst -2 "i+1") (("1" (skeep) (("1" (expand "nth" -2) (("1" (inst 1 "m") (("1" (inst -3 "i+1" "0") (("1" (assert) (("1" (expand "nth" (-3 -1)) (("1" (expand "nstruct?") (("1" (prop) (("1" (hide -3) (("1" (swap-rel -2) (("1" (swap-rel -3) (("1" (replaces) (("1" (hide -1 2) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "i+1" "j+1") (("1" (assert) (("1" (expand "nth" (-4)) (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "j") (("2" (hide-all-but (-1 1 3)) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide-all-but (-1 1 3)) (("3" (typepred "i") (("3" (expand "length" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (expand "oddNstructPreservation?") (("3" (flatten) (("3" (split) (("1" (skeep) (("1" (case-replace "i=0") (("1" (inst -2 "0") (("1" (skeep) (("1" (typepred "m") (("1" (inst 1 "m") (("1" (expand "nstruct?") (("1" (prop) (("1" (replaces) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (copy -1) (("2" (inst -1 "i") (("2" (inst -2 "0") (("2" (skeep) (("2" (skeep) (("2" (case " m!1 > m") (("1" (inst -4 "i" "0") (("1" (assert) (("1" (inst 2 "m") nil nil)) nil)) nil) ("2" (hide 3 4) (("2" (inst -3 "i" "0") (("2" (assert) (("2" (expand "nstruct?") (("2" (prop) (("1" (hide -3 -6) (("1" (grind) nil nil)) nil) ("2" (hide -4) (("2" (replaces) (("2" (grind) nil nil)) nil)) nil) ("3" (hide -3) (("3" (replaces) (("3" (assert) nil nil)) nil)) nil) ("4" (replaces) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((j skolem-const-decl "below[length(cdr(s`oddList))]" ford_johnson nil) (i skolem-const-decl "below[length(cdr(s`oddList))]" ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (n skolem-const-decl "posnat" ford_johnson nil) (m skolem-const-decl "below[n]" ford_johnson nil) (NOT const-decl "[bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (nth def-decl "T" list_props nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (> const-decl "bool" reals nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (below type-eq-decl nil nat_types nil) (i skolem-const-decl "below[length(cdr(s`oddList))]" ford_johnson nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (TRUE const-decl "bool" booleans nil) (m skolem-const-decl "below[n]" ford_johnson nil)) shostak)) (nstructER_vs_nstructER_basic_TCC1 0 (nstructER_vs_nstructER_basic_TCC1-1 nil 3766827320 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (/= const-decl "boolean" notequal nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil)) nil (nstructER_vs_nstructER_basic subtype "ford_johnson.s`seqfj`length" "{x: reals.real | reals.>=(x, 1)}"))) (nstructER_vs_nstructER_basic_TCC2 0 (nstructER_vs_nstructER_basic_TCC2-1 nil 3772220942 ("" (skeep) (("" (lemma "lengthBottleneckIs1") (("" (inst -1 "s" "0" "s") (("1" (assert) (("1" (lemma "plain_finseqfj_nstructER0") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (expand "^") (("3" (expand "expt") (("3" (assert) nil nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil) ((leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil ford_johnson nil) (lengthBottleneckIs1 formula-decl nil firt_phase_ford_johnson nil) (expt def-decl "real" exponentiation nil) (plain_finseqfj_nstructER0 formula-decl nil firt_phase_ford_johnson nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (/= const-decl "boolean" notequal nil) (s skolem-const-decl "{s: finseqfj | plain_finseqfj(s) AND length(s`seqfj) /= 0}" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil)) nil (nstructER_vs_nstructER_basic subtype "firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].seqfjBottleneck(ford_johnson.s)" "{s: firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].finseqfj | reals.>(length(s`seqfj), 0)}"))) (nstructER_vs_nstructER_basic 0 (nstructER_vs_nstructER_basic-1 nil 3766827334 ("" (skeep) (("" (beta) (("" (lemma "correctionER") (("" (inst -1 "s" "s") (("1" (beta) (("1" (split) (("1" (expand "nstructER_basic?") (("1" (split) (("1" (expand "nstructER?") (("1" (flatten) nil nil)) nil) ("2" (assert) (("2" (expand "oddNstructPreservation?") (("2" (split) (("1" (expand "nstructER?") (("1" (flatten) (("1" (hide-all-but (-6 1)) (("1" (skeep) (("1" (inst? -1) (("1" (skeep) (("1" (inst? 1) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nstructER?") (("2" (flatten) (("2" (hide-all-but (-5 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "seqfjBottleneck_works") (("3" (inst -1 "s") (("3" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "0") (("1" (lemma "plain_finseqfj_nstructER0") (("1" (inst -1 "s") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (s skolem-const-decl "{s: finseqfj | plain_finseqfj(s) AND length(s`seqfj) /= 0}" ford_johnson nil) (/= const-decl "boolean" notequal nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (nstructER? const-decl "bool" firt_phase_ford_johnson nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (posint_exp application-judgement "posint" exponentiation nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (seqfjBottleneck def-decl "finseqfj" firt_phase_ford_johnson nil) (below type-eq-decl nil nat_types nil) (^ const-decl "real" exponentiation nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (integer nonempty-type-from-decl nil integers nil) (odd? const-decl "bool" integers nil) (logb const-decl "nat" firt_phase_ford_johnson nil) (above nonempty-type-eq-decl nil integers nil) (seqfjBottleneck_works formula-decl nil firt_phase_ford_johnson nil) (nstructER_basic? const-decl "bool" ford_johnson nil) (plain_finseqfj_nstructER0 formula-decl nil firt_phase_ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (correctionER formula-decl nil firt_phase_ford_johnson nil) (T formal-type-decl nil ford_johnson nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil)) shostak)) (occ_in_rest_TCC1 0 (occ_in_rest_TCC1-1 nil 3754145599 ("" (subtype-tcc) nil nil) nil nil (occ_in_rest subtype "0" "below[s`length]"))) (occ_in_rest 0 (occ_in_rest-1 nil 3754148745 ("" (skeep) (("" (expand "occurrences" 1 2) (("" (expand "map") (("" (expand "finseq_appl") (("" (expand "occurrences" 1 1) (("" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((occurrences const-decl "nat" firt_phase_ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (map def-decl "nat" firt_phase_ford_johnson nil)) shostak)) (occ_in_removeson 0 (occ_in_removeson-1 nil 3754148980 ("" (measure-induct "length(s)" "s") (("1" (skeep) (("1" (skeep) (("1" (inst -1 "rest(x_1)") (("1" (split) (("1" (case "i=0") (("1" (hide -2) (("1" (replace -1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) nil nil)) nil) ("2" (hide 1) (("2" (expand "finseq_appl") (("2" (case " rest(removeSon(x_1, 0)) = rest(x_1)") (("1" (replaces) (("1" (expand "occurrences" 1 3) (("1" (expand "map" 1 2) (("1" (expand "finseq_appl") (("1" (expand "removeSon") (("1" (expand "finseq_appl") (("1" (assert) (("1" (lemma "occ_list_vs_fjnodes") (("1" (copy -1) (("1" (inst -2 "x_1`seq(0)" "x" "cdr(smallerones(x_1`seq(0)))") (("1" (expand "occurrences" 1 2) (("1" (lift-if) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 -6)) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "add_fold" 2) (("2" (assert) (("2" (replaces) (("2" (expand "occurrences" 2 1) (("2" (lift-if) (("2" (prop) (("1" (expand "occurrences" 1) (("1" (expand "map") (("1" (assert) nil nil)) nil)) nil) ("2" (inst -1 "consFjnode(x, cdr(smallerones(x_1`seq(0))))" "x" "cdr(smallerones(x_1`seq(0)))") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 -5)) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "add_fold" 2 1) (("2" (assert) (("2" (replaces) (("2" (expand "occurrences" 2 1) (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 1)) (("1" (expand "occurrences") (("1" (expand "map") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (inst -1 "consFjnode(val(x_1`seq(0)), cdr(smallerones(x_1`seq(0))))" "x" "cdr(smallerones(x_1`seq(0)))") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (hide -1 -2) (("2" (lemma "nodes_TCC1") (("2" (inst -1 "x_1`seq(0)") (("2" (split) (("1" (skeep) (("1" (inst -1 "i!1+1") (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (expand "rest") (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) nil nil)) nil) ("2" (expand "^") (("2" (expand "removeSon") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "i-1" "x") (("1" (split) (("1" (case "removeSon(x_1, i) = add_first(x_1`seq(0), removeSon(rest(x_1), i - 1))") (("1" (replaces) (("1" (expand "add_first") (("1" (expand "occurrences" 2 1) (("1" (expand "map") (("1" (lift-if) (("1" (prop) (("1" (hide -2) (("1" (hide -2 1) (("1" (expand "insert?") (("1" (expand "removeSon") (("1" (expand "rest") (("1" (typepred "i") (("1" (expand "^") (("1" (expand "empty_seq") (("1" (assert) (("1" (expand "min") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (expand "finseq_appl") (("2" (expand "insert?" 1 2) (("2" (case "rest(insert?(x_1`seq(0), removeSon(rest(x_1), i - 1), 0)) = removeSon(rest(x_1), i - 1)") (("1" (replaces) (("1" (expand "occurrences" -1 1) (("1" (lemma "occ_in_rest") (("1" (inst -1 "x_1" "x") (("1" (replaces) (("1" (case "occurrences(x)(car(smallerones(rest(x_1)`seq(i - 1)))) =  occurrences(x)(car(smallerones(x_1`seq(i))))") (("1" (replaces) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (expand "rest") (("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (expand "add_first") (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (hide 3) (("2" (expand "rest") (("2" (expand "^") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "rest") (("2" (expand "^") (("2" (expand "empty_seq") (("2" (expand "min") (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "rest") (("2" (expand "^") (("2" (expand "min") (("2" (expand "empty_seq") (("2" (lift-if) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "well_founded?") (("2" (skeep* :preds? t) (("2" (inst -2 "p") (("2" (prop) (("1" (skeep) (("1" (inst 1 "y!1") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rest const-decl "finseq" seq_extras structures) (map def-decl "nat" firt_phase_ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (^ const-decl "finseq" finite_sequences nil) (TRUE const-decl "bool" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (nodes_TCC1 subtype-tcc nil firt_phase_ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (i!1 skolem-const-decl "below[length(cdr(smallerones(x_1`seq(0))))]" ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (map def-decl "nat" firt_phase_ford_johnson nil) (occurrences const-decl "nat" firt_phase_ford_johnson nil) (consFjnode? adt-recognizer-decl "[fjnode -> boolean]" fjnode_adt nil) (consFjnode adt-constructor-decl "[[T, list[fjnode]] -> (consFjnode?)]" fjnode_adt nil) (add_fold def-decl "nat" firt_phase_ford_johnson nil) (val adt-accessor-decl "[fjnode -> T]" fjnode_adt nil) (nth def-decl "T" list_props nil) (<< adt-def-decl "(strict_well_founded?[fjnode])" fjnode_adt nil) (strict_well_founded? const-decl "bool" orders nil) (x_1 skolem-const-decl "finseq[fjnode[T]]" ford_johnson nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (length def-decl "nat" list_props nil) (occ_list_vs_fjnodes formula-decl nil firt_phase_ford_johnson nil) (occ_in_rest formula-decl nil ford_johnson nil) (> const-decl "bool" reals nil) (upto nonempty-type-eq-decl nil nat_types nil) (<= const-decl "bool" reals nil) (insert? const-decl "finseq" seq_extras structures) (int_plus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (add_first const-decl "finseq" seq_extras structures) (i skolem-const-decl "below[length(x_1)]" ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (occurrences def-decl "nat" firt_phase_ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (occurrences const-decl "nat" firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list type-decl nil list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (occ_in_insert 0 (occ_in_insert-1 nil 3754144993 ("" (measure-induct "length(s)" "s") (("1" (skeep) (("1" (skeep) (("1" (case "length(x_1) = 0") (("1" (hide -2) (("1" (expand "occurrences" 1 2) (("1" (expand "map") (("1" (assert) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (lift-if) (("1" (prop) (("1" (expand "insert?") (("1" (assert) nil nil)) nil) ("2" (hide 1) (("2" (expand "finseq_appl") (("2" (expand "map") (("2" (lift-if) (("2" (prop) (("1" (expand "insert?") (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (expand "insert?") (("2" (expand "rest") (("2" (expand "^") (("2" (expand "empty_seq") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "rest(x_1)") (("2" (split) (("1" (case "i=0") (("1" (replaces) (("1" (hide -1) (("1" (expand "occurrences" 2 1) (("1" (expand "map") (("1" (lift-if) (("1" (prop) (("1" (expand "insert?") (("1" (assert) nil nil)) nil) ("2" (hide 1) (("2" (expand "finseq_appl") (("2" (expand "insert?" 1 2) (("2" (case "rest(insert?(node, x_1, 0)) = x_1") (("1" (replaces) (("1" (expand "occurrences" 1 2) (("1" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "node" "i-1" "x") (("1" (lemma "occ_in_rest") (("1" (inst?) (("1" (replaces) (("1" (case " occurrences(insert?(node, x_1, i))(x) =  occurrences(insert?(node, rest(x_1), i - 1))(x) + occurrences(x)(x_1`seq(0))") (("1" (replaces) (("1" (assert) nil nil)) nil) ("2" (hide 4) (("2" (hide -1) (("2" (case "x_1 = insert?(x_1`seq(0), rest(x_1), 0)") (("1" (replaces -1 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (lift-if) (("1" (prop) (("1" (hide 1) (("1" (expand "insert?") (("1" (expand "rest") (("1" (lift-if) (("1" (prop) (("1" (expand "^") (("1" (expand "min") (("1" (expand "empty_seq") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 1) (("2" (expand "finseq_appl") (("2" (assert) (("2" (case "occurrences(x)
                  (insert?(node, insert?(x_1`seq(0), rest(x_1), 0), i)`seq
                       (0)) =  occurrences(x)(insert?(x_1`seq(0), rest(x_1), 0)`seq(0))") (("1" (replaces) (("1" (assert) (("1" (case "insert?(node, insert?(x_1`seq(0), rest(x_1), 0), i) = insert?(x_1`seq(0), insert?(node, rest(x_1), i-1), 0)") (("1" (replaces) (("1" (case "rest(insert?(x_1`seq(0), insert?(node, rest(x_1), i - 1), 0)) =  insert?(node, rest(x_1), i-1)") (("1" (replaces) (("1" (case "rest(insert?(x_1`seq(0), rest(x_1), 0)) = rest(x_1)") (("1" (replaces) (("1" (expand "occurrences" 1 2) (("1" (propax) nil nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "insert?") (("3" (expand "rest") (("3" (expand "^") (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (expand "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (expand "rest") (("4" (expand "^") (("4" (lift-if) (("4" (prop) (("1" (expand "empty_seq") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (expand "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "insert?") (("2" (expand "finseq_appl") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "insert?") (("3" (expand "rest") (("3" (expand "^") (("3" (expand "min") (("3" (expand "empty_seq") (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (decompose-equality) (("1" (expand "insert?") (("1" (grind) nil nil)) nil) ("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "rest") (("3" (expand "^") (("3" (expand "min") (("3" (expand "empty_seq") (("3" (lift-if) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 4) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "well_founded?") (("2" (skeep* :preds? t) (("2" (inst -2 "p") (("2" (prop) (("1" (skeep) (("1" (inst 1 "y!1") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (rest const-decl "finseq" seq_extras structures) (empty_seq const-decl "finseq" finite_sequences nil) (^ const-decl "finseq" finite_sequences nil) (map def-decl "nat" firt_phase_ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (x_1 skolem-const-decl "finseq[fjnode[T]]" ford_johnson nil) (i skolem-const-decl "upto[length(x_1)]" ford_johnson nil) (> const-decl "bool" reals nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (occ_in_rest formula-decl nil ford_johnson nil) (TRUE const-decl "bool" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (occurrences def-decl "nat" firt_phase_ford_johnson nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (insert? const-decl "finseq" seq_extras structures) (occurrences const-decl "nat" firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (upto nonempty-type-eq-decl nil nat_types nil) (<= const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (insert_removeson_permutation_TCC1 0 (insert_removeson_permutation_TCC1-1 nil 3754138677 ("" (subtype-tcc) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil)) nil (insert_removeson_permutation subtype "ford_johnson.searchIndx" "upto[length(removeSon(s`seqfj, i))]"))) (insert_removeson_permutation 0 (insert_removeson_permutation-1 nil 3754139788 ("" (skeep) (("" (expand "permutation") (("" (skeep) (("" (lemma "occ_in_insert") (("" (inst?) (("" (replaces) (("" (lemma "occ_in_removeson") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((permutation const-decl "bool" firt_phase_ford_johnson nil) (occ_in_insert formula-decl nil ford_johnson nil) (TRUE const-decl "bool" booleans nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (occ_in_removeson formula-decl nil ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (<= const-decl "bool" reals nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (< const-decl "bool" reals nil) (> const-decl "bool" reals nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak)) (insertSonPreservesPartialERforK_TCC1 0 (insertSonPreservesPartialERforK_TCC1-1 nil 3777229366 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (is_sorted? const-decl "bool" sorting_seq nil) (is_indx? const-decl "bool" ford_johnson nil)) nil (insertSonPreservesPartialERforK subtype "ford_johnson.indx" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), ford_johnson.is_indx?(ford_johnson.s`seqfj, indx))}"))) (insertSonPreservesPartialERforK_TCC2 0 (insertSonPreservesPartialERforK_TCC2-1 nil 3777229366 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (below type-eq-decl nil nat_types nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (is_sorted? const-decl "bool" sorting_seq nil) (is_indx? const-decl "bool" ford_johnson nil) (^ const-decl "real" exponentiation nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (posnat_expt application-judgement "posnat" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)) nil (insertSonPreservesPartialERforK subtype "ford_johnson.pos" "{pos: nat_types[length(ford_johnson.indx)].below | booleans.AND((booleans.OR(ford_johnson.k = 1, reals.<=(ford_johnson.t((number_fields.-)(ford_johnson.k, 1)), pos))), reals.<=(pos, ford_johnson.t(ford_johnson.k)))}"))) (insertSonPreservesPartialERforK_TCC3 0 (insertSonPreservesPartialERforK_TCC3-1 nil 3777229366 ("" (subtype-tcc) nil nil) nil nil (insertSonPreservesPartialERforK subtype "ford_johnson.pos" "below[indx`length]"))) (insertSonPreservesPartialERforK_TCC4 0 (insertSonPreservesPartialERforK_TCC4-1 nil 3777229366 ("" (skeep* :preds? t) (("" (hide-all-but (-8 -9 1)) (("" (expand "is_indx?") (("" (flatten) (("" (inst?) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (is_sorted? const-decl "bool" sorting_seq nil) (restrict const-decl "R" restrict nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (PartialERforK? const-decl "bool" ford_johnson nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (is_indx? const-decl "bool" ford_johnson nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (insertSonPreservesPartialERforK subtype "ford_johnson.indx`seq(ford_johnson.pos)" "below[s`seqfj`length]"))) (insertSonPreservesPartialERforK_TCC5 0 (insertSonPreservesPartialERforK_TCC5-1 nil 3777229366 ("" (skeep) (("" (typepred "indx") (("" (typepred "n") (("" (expand "PartialERforK?") (("" (flatten) (("" (hide -4 -5 -6) (("" (inst -4 "pos") (("1" (assert) (("1" (expand "finseq_appl") (("1" (expand "nstruct?") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PartialERforK? const-decl "bool" ford_johnson nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (pos skolem-const-decl "{pos: posnat | (k = 1 OR t(k - 1) < pos) AND pos <= t(k)}" ford_johnson nil) (k skolem-const-decl "posnat" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (insertSonPreservesPartialERforK subtype "fjnode_adt[ford_johnson.T].smallerones(ford_johnson.s`seqfj`seq(ford_johnson.indx`seq(ford_johnson.pos)))" "(list_adt[fjnode_adt[ford_johnson.T].fjnode].cons?)"))) (insertSonPreservesPartialERforK_TCC6 0 (insertSonPreservesPartialERforK_TCC6-1 nil 3777229366 ("" (subtype-tcc) nil nil) nil nil (insertSonPreservesPartialERforK subtype "0" "below[length(s`seqfj)]"))) (insertSonPreservesPartialERforK_TCC7 0 (insertSonPreservesPartialERforK_TCC7-2 nil 3797760915 ("" (skeep) (("" (typepred "indx") (("" (expand "is_indx?") (("" (flatten) (("" (expand "finseq_appl") (("" (inst -3 "pos") (("" (flatten) (("" (assert) (("" (hide -7 -6) (("" (lemma "is_sorted_equiv[nat, <=]") (("" (inst -1 "indx") (("" (assert) (("" (inst -1 "0" "pos") (("" (expand "finseq_appl") (("" (inst -5 "0") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PartialERforK? const-decl "bool" ford_johnson nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (is_sorted_equiv formula-decl nil sorting_seq nil) (restrict const-decl "R" restrict nil) (/= const-decl "boolean" notequal nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (finite_sequence type-eq-decl nil finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (insertSonPreservesPartialERforK subtype "(number_fields.-)(ford_johnson.indx`seq(ford_johnson.pos), 1)" "{j: nat_types[length(ford_johnson.s`seqfj)].below | reals.<=(0, j)}")) (insertSonPreservesPartialERforK_TCC7-1 nil 3777229366 ("" (skeep) (("" (typepred "indx") (("" (expand "is_indx?") (("" (flatten) (("" (expand "finseq_appl") (("" (inst -3 "pos") (("" (flatten) (("" (assert) (("" (hide -7 -6) (("" (lemma "is_sorted_equiv[nat, <=, <, >]") (("" (inst -1 "indx") (("" (assert) (("" (inst -1 "0" "pos") (("" (expand "finseq_appl") (("" (inst -5 "0") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PartialERforK? const-decl "bool" ford_johnson nil) (<= const-decl "bool" reals nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (pred type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (is_sorted_equiv formula-decl nil sorting_seq nil) (restrict const-decl "R" restrict nil) (/= const-decl "boolean" notequal nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (finite_sequence type-eq-decl nil finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (insertSonPreservesPartialERforK subtype "(number_fields.-)(ford_johnson.indx`seq(ford_johnson.pos), 1)" "{j: nat_types[length(ford_johnson.s`seqfj)].below | reals.<=(0, j)}"))) (insertSonPreservesPartialERforK_TCC8 0 (insertSonPreservesPartialERforK_TCC8-2 "" 3804610236 ("" (skeep :preds? t) (("" (hide -10) (("" (grind) nil nil)) nil)) nil) nil shostak (insertSonPreservesPartialERforK subtype "ford_johnson.bsearch" "upto[length(removeSon(s`seqfj, indx`seq(pos)))]")) (insertSonPreservesPartialERforK_TCC8-1 nil 3777229366 ("" (subtype-tcc) nil nil) ((listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (rat_exp application-judgement "rat" exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (is_sorted? const-decl "bool" sorting_seq nil) (is_indx? const-decl "bool" ford_johnson nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (insertSonPreservesPartialERforK subtype "ford_johnson.bsearch" "upto[length(removeSon(s`seqfj, indx`seq(pos)))]"))) (insertSonPreservesPartialERforK_TCC9 0 (insertSonPreservesPartialERforK_TCC9-1 nil 3777229366 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (is_indx? const-decl "bool" ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (/= const-decl "boolean" notequal nil) (is_sorted? const-decl "bool" sorting_seq nil) (restrict const-decl "R" restrict nil) (^ const-decl "real" exponentiation nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (insert? const-decl "finseq" seq_extras structures)) nil (insertSonPreservesPartialERforK subtype "ford_johnson.sk" "{s: firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].finseqfj | reals.>(length(s`seqfj), 0)}"))) (insertSonPreservesPartialERforK_TCC10 0 (insertSonPreservesPartialERforK_TCC10-1 nil 3777229366 ("" (skeep) (("" (skeep) (("" (skeep) (("" (lemma "upToOnePreservesIndx") (("" (inst -1 "removeSon(s`seqfj, indx`seq(pos))" "indx" "b" "bsearch") (("1" (assert) (("1" (split) (("1" (assert) (("1" (hide-all-but (1)) (("1" (expand "upToOne") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "indx") (("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((upToOnePreservesIndx formula-decl nil ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (NOT const-decl "[bool -> bool]" booleans nil) (is_sorted? const-decl "bool" sorting_seq nil) (restrict const-decl "R" restrict nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (finseq type-eq-decl nil finite_sequences nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (is_indx? const-decl "bool" ford_johnson nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (k skolem-const-decl "posnat" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (pos skolem-const-decl "{pos: posnat | (k = 1 OR t(k - 1) < pos) AND pos <= t(k)}" ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (n skolem-const-decl "posnat" ford_johnson nil) (indx skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    is_indx?(s`seqfj, indx) AND
     pos < length(indx) AND PartialERforK?(s, indx, k, pos, n)}" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (insertSonPreservesPartialERforK subtype "ford_johnson.upToOne(ford_johnson.indx, ford_johnson.bsearch)" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), ford_johnson.is_indx?(ford_johnson.sk`seqfj, indx))}"))) (insertSonPreservesPartialERforK_TCC11 0 (insertSonPreservesPartialERforK_TCC11-1 nil 3777229366 ("" (skeep) (("" (skeep) (("" (skeep) (("" (expand "upToOne") (("" (typepred "pos") (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((upToOne const-decl "finseq[nat]" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil)) nil (insertSonPreservesPartialERforK subtype "(number_fields.-)(ford_johnson.pos, 1)" "{pos: nat_types[length(ford_johnson.upToOne(ford_johnson.indx, ford_johnson.bsearch))].below | booleans.AND((booleans.OR(ford_johnson.k = 1, reals.<=(ford_johnson.t((number_fields.-)(ford_johnson.k, 1)), pos))), reals.<=(pos, ford_johnson.t(ford_johnson.k)))}"))) (insertSonPreservesPartialERforK 0 (insertSonPreservesPartialERforK-8 nil 3797782135 ("" (skeep) (("" (beta) (("" (typepred "indx") (("" (auto-rewrite "finseq_appl") (("" (expand "PartialERforK?" 1) (("" (split) (("1" (expand "finseq_appl") (("1" (skeep) (("1" (name-replace "bsearch" "bin_search(s`seqfj)
                                                  (car(smallerones
                                                       (s`seqfj`seq(indx`seq(pos)))))
                                                  (0, indx`seq(pos) - 1)") (("1" (expand "insert?") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (expand "removeSon") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (hide 2) (("1" (inst -12 "pos") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "PartialERforK?") (("2" (expand "removeSon") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (lift-if) (("2" (prop) (("1" (inst -10 "pos") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst 3 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "upToOne") (("2" (split) (("1" (flatten) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 1 2) (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (inst -5 "pos") (("1" (expand "finseq_appl") (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -6 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 1 2) (("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -6 -7) (("4" (inst -6 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -7 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "PartialERforK?") (("5" (flatten) (("5" (expand "removeSon") (("5" (expand "finseq_appl") (("5" (lift-if) (("5" (prop) (("1" (replaces) (("1" (hide -4 -5) (("1" (inst -4 "pos") (("1" (assert) (("1" (hide -1 -2 -5 2 3 4 5 6) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -3) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "i+1") (("1" (expand "nth" -) (("1" (propax) nil nil)) nil) ("2" (typepred "i") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "length" -) (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (hide -4 -5 -7) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -5 -6 -7) (("3" (inst -4 "j-1") (("1" (split) (("1" (propax) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "removeSon") (("6" (lift-if) (("6" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6 -8) (("1" (inst - "pos") (("1" (assert) (("1" (hide 2) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (inst -7 "i+1") (("1" (expand "nth" -) (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "length" -) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (expand "PartialERforK?") (("2" (assert) (("2" (assert) (("2" (flatten) (("2" (hide -4 -5 -7) (("2" (inst - "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -7 -6 -5) (("3" (inst -4 "j-1") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (inst 3 "i") (("1" (expand "upToOne") (("1" (assert) nil nil)) nil) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (typepred "pos") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (inst -7 "0") (("2" (flatten) (("2" (inst -8 "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9 -8 -6) (("1" (assert) (("1" (case "j <=
                                                   bin_search(s`seqfj)(car(smallerones(s`seqfj`seq(indx`seq(pos)))))
                                                             (0, indx`seq(pos) - 1) => j <= indx`seq(t(k))") (("1" (expand "insert?") (("1" (lift-if) (("1" (prop) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide +) (("2" (expand "upToOne") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("4" (hide +) (("4" (expand "upToOne") (("4" (lift-if) (("4" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (expand "upToOne") (("5" (lift-if) (("5" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("6" (hide +) (("6" (expand "upToOne") (("6" (lift-if) (("6" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("7" (expand "removeSon") (("7" (assert) nil nil)) nil) ("8" (assert) nil nil) ("9" (assert) nil nil) ("10" (assert) nil nil) ("11" (expand "finseq_appl") (("11" (expand "upToOne") (("11" (expand "finseq_appl") (("11" (lift-if) (("11" (prop) (("1" (lemma "b_search_bound") (("1" (inst?) (("1" (flatten) (("1" (hide -1) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -8 "pos") (("1" (flatten) (("1" (inst -9 "t(k)") (("1" (typepred "pos") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (hide -10) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (both-sides "-" "1" -1) (("2" (assert) (("2" (inst -6 "j-1") (("1" (assert) (("1" (flatten) (("1" (expand "removeSon") (("1" (assert) (("1" (split 2) (("1" (flatten) (("1" (hide +) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -7 "pos") (("1" (flatten) (("1" (inst -8 "t(k)") (("1" (typepred "pos") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (case "j - 1 > indx`seq(t(k))") (("1" (hide -3) (("1" (inst -6 "j - 1") (("1" (assert) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (skeep) (("1" (inst 1 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split 1) (("1" (case-replace "i=pos") (("1" (typepred "pos") (("1" (swap-rel -9) (("1" (replaces) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (lemma "b_search_bound") (("2" (inst?) (("1" (flatten) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (flatten) (("3" (expand "upToOne") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (typepred "pos") (("4" (hide -9) (("4" (expand "is_indx?") (("4" (flatten) (("4" (lemma "is_sorted_equiv[nat, <=]") (("4" (inst?) (("4" (assert) (("4" (inst -1 "0" "pos") (("4" (inst -9 "0") (("4" (flatten) (("4" (inst -10 "pos") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "j < 1 + indx`seq(t(k - 1))") (("1" (expand "insert?") (("1" (prop) (("1" (expand "finseq_appl") (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9) (("1" (inst -8 "j") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (skeep) (("1" (inst -10 "i") (("1" (prop) (("1" (typepred "i") (("1" (swap-rel -14) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "i") (("1" (inst -11 "i") (("1" (flatten) (("1" (inst -12 "t(k-1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (assert) (("2" (swap-rel -12) (("2" (replaces) (("2" (case-replace "indx`seq(i) <= indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k)" "i") (("1" (inst -12 "i") (("1" (flatten) (("1" (inst -13 "t(k)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "indx`seq(t(k-1)) < indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "k-1" "k") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "t(k)") (("2" (inst -13 "t(k-1)") (("2" (flatten) (("2" (inst -14 "t(k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -8 -9) (("2" (inst -8 "pos") (("1" (assert) (("1" (hide-all-but (-8 1)) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -2 "0") (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (assert) (("3" (expand "removeSon") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (both-sides "-" "1" -3) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "pos") (("1" (assert) nil nil) ("2" (typepred "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (both-sides "-" "1" -2) (("2" (hide -3 -4 -8) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "pos") (("1" (assert) nil nil) ("2" (typepred "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -8) (("3" (inst -7 "j-1") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst -9 "i") (("1" (assert) (("1" (prop) (("1" (swap-rel -9) (("1" (both-sides "-" "1" -2) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (typepred "i") (("1" (assert) (("1" (inst -4 "t(k-1)" "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (assert) (("2" (both-sides "-" "1" -4) (("2" (swap-rel -11) (("2" (replaces) (("2" (assert) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (prop) (("1" (expand "finseq_appl") (("1" (expand "insert?") (("1" (prop) (("1" (assert) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -7 -8) (("1" (assert) (("1" (inst -7 "i") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (name-replace "bsearch" "bin_search(s`seqfj)(car(smallerones(s`seqfj`seq(indx`seq(pos))))) (0, indx`seq(pos) - 1)") (("1" (expand "upToOne") (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "removeSon") (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (hide-all-but (-2 -3 -5)) (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -4 "pos") (("1" (flatten) (("1" (inst -5 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 -4)) (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -4 "pos") (("2" (flatten) (("2" (inst -5 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (inst -5 "i") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 4) (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -4 "pos") (("2" (flatten) (("2" (inst -5 "0") (("2" (assert) (("2" (lemma " sorting_seq[nat,restrict[[real, real], [nat, nat], boolean](<=)].is_sorted_equiv") (("2" (inst?) (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "insert?") (("2" (prop) (("1" (expand "upToOne") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (assert) (("1" (hide -6 -7) (("1" (inst -6 "i") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -5 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (expand "upToOne") (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("3" (expand "removeSon") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6) (("1" (inst -5 "pos") (("1" (assert) (("1" (hide-all-but (-1 -5 1)) (("1" (expand "nstruct?") (("1" (flatten) (("1" (prop) (("1" (hide -4) (("1" (expand "length" -3) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "i!1+1") (("1" (expand "nth" -) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (typepred "i!1") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -3) (("3" (expand "length" -) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (hide 2 3 4 5 6 7 8) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (typepred "n") (("1" (hide -6) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "is_indx?") (("3" (flatten) (("3" (lemma "is_sorted_equiv[nat, <=]") (("3" (inst?) (("3" (assert) (("3" (inst -1 "pos" "i") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -6 -7) (("3" (assert) (("3" (name-replace "bsearch" "bin_search(s`seqfj)(car(smallerones(s`seqfj`seq(indx`seq(pos)))))(0, indx`seq(pos) - 1)") (("1" (inst -6 "i") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil) ("2" (name-replace "bsearch" "bin_search(s`seqfj)(car(smallerones(s`seqfj`seq(indx`seq(pos)))))(0, indx`seq(pos) - 1)") (("1" (hide-all-but (-3 -4 1)) (("1" (inst -2 "pos") (("1" (flatten) (("1" (inst -3 "0") (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "0" "pos") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 -4 1)) (("2" (inst -2 "0") (("2" (flatten) (("2" (inst -3 "pos") (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -4 -5 -6) (("4" (case "is_sorted?(removeSon(s`seqfj, indx`seq(pos)))") (("1" (assert) (("1" (lemma "b_search_preserves_sorting") (("1" (inst -1 "removeSon(s`seqfj, indx`seq(pos))" "car(smallerones(s`seqfj`seq(indx`seq(pos))))" "0" " indx`seq(pos) - 1") (("1" (assert) (("1" (split) (("1" (lemma "b_search_removeSon") (("1" (inst?) (("1" (assert) (("1" (hide -1 2) (("1" (reveal -6) (("1" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (flatten) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "removeSon" +) (("2" (reveal -4) (("2" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "removeSon") (("2" (split) (("1" (typepred "pos") (("1" (expand "is_indx?") (("1" (flatten) (("1" (copy -5) (("1" (expand "is_sorted?" -6) (("1" (inst -6 "0") (("1" (assert) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -8 "0") (("1" (flatten) (("1" (inst -9 "1") (("1" (inst -1 "1" "pos") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "removeSon") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "is_sorted?") (("2" (skeep) (("2" (inst -5 "i") (("1" (expand "removeSon" -1) (("1" (assert) (("1" (expand "removeSon") (("1" (lift-if) (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((is_sorted_equiv formula-decl nil sorting_seq nil) (restrict const-decl "R" restrict nil) (/= const-decl "boolean" notequal nil) (finite_sequence type-eq-decl nil finite_sequences nil) (insert? const-decl "finseq" seq_extras structures) (i skolem-const-decl "below[length(cdr(smallerones(s`seqfj`seq(indx`seq(pos)))))]" ford_johnson nil) (i skolem-const-decl "{i: below[length(indx)] |
   (i <= pos OR i > t(k)) AND (i > t(k - 1) OR k = 1)}" ford_johnson nil) (j skolem-const-decl "below[length
        (insert?(car(smallerones(s`seqfj`seq(indx`seq(pos)))),
                 removeSon(s`seqfj, indx`seq(pos)),
                 bin_search(s`seqfj)
                           (car(smallerones(s`seqfj`seq(indx`seq(pos)))))
                           (0, indx`seq(pos) - 1)))]" ford_johnson nil) (TRUE const-decl "bool" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (i skolem-const-decl "below[length(cdr(smallerones(s`seqfj`seq(indx`seq(pos)))))]" ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (i skolem-const-decl "{i: below[length(indx)] |
   (i <= pos OR i > t(k)) AND (i > t(k - 1) OR k = 1)}" ford_johnson nil) (indx skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    is_indx?(s`seqfj, indx) AND
     pos < length(indx) AND PartialERforK?(s, indx, k, pos, n)}" ford_johnson nil) (n skolem-const-decl "posnat" ford_johnson nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (pos skolem-const-decl "{pos: posnat | (k = 1 OR t(k - 1) < pos) AND pos <= t(k)}" ford_johnson nil) (k skolem-const-decl "posnat" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (i skolem-const-decl "{i: below[length(indx)] |
   (i <= pos OR i > t(k)) AND (i > t(k - 1) OR k = 1)}" ford_johnson nil) (both_sides_minus_lt1 formula-decl nil real_props nil) (odd_minus_even_is_odd application-judgement "odd_int" integers nil) (i skolem-const-decl "{i: below[length(indx)] |
   (i <= pos OR i > t(k)) AND (i > t(k - 1) OR k = 1)}" ford_johnson nil) (t_is_increasing formula-decl nil ford_johnson nil) (odd? const-decl "bool" integers nil) (both_sides_minus_gt1 formula-decl nil real_props nil) (j skolem-const-decl "below[length
        (insert?(car(smallerones(s`seqfj`seq(indx`seq(pos)))),
                 removeSon(s`seqfj, indx`seq(pos)),
                 bin_search(s`seqfj)
                           (car(smallerones(s`seqfj`seq(indx`seq(pos)))))
                           (0, indx`seq(pos) - 1)))]" ford_johnson nil) (b_search_bound formula-decl nil ford_johnson nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (i skolem-const-decl "{i: below[length(indx)] |
   (i <= pos OR i > t(k)) AND (i > t(k - 1) OR k = 1)}" ford_johnson nil) (i skolem-const-decl "{i:
   below[length
           (upToOne(indx,
                    bin_search(s`seqfj)
                              (car(smallerones(s`seqfj`seq(indx`seq(pos)))))
                              (0, indx`seq(pos) - 1)))] |
   (k = 1 OR t(k - 1) < i) AND i <= t(k)}" ford_johnson nil) (i!1 skolem-const-decl "below[length(cdr(smallerones(s`seqfj`seq(indx`seq(pos)))))]" ford_johnson nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (b_search_preserves_sorting formula-decl nil ford_johnson nil) (is_sorted? const-decl "bool" sorting_seq nil) (b_search_removeSon formula-decl nil ford_johnson nil) (i skolem-const-decl "below[length(removeSon(s`seqfj, indx`seq(pos)))]" ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (PartialERforK? const-decl "bool" ford_johnson nil)) nil) (insertSonPreservesPartialERforK-7 nil 3797602421 ("" (skeep) (("" (beta) (("" (typepred "indx") (("" (auto-rewrite "finseq_appl") (("" (expand "PartialERforK?" 1) (("" (split) (("1" (expand "finseq_appl") (("1" (skeep) (("1" (name-replace "bsearch" "bin_search(s`seqfj)
                                              (car(smallerones
                                                   (s`seqfj`seq(indx`seq(pos)))))
                                              (0, indx`seq(pos) - 1)") (("1" (expand "insert?") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (expand "removeSon") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (hide 2) (("1" (inst -12 "pos") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "PartialERforK?") (("2" (expand "removeSon") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (lift-if) (("2" (prop) (("1" (inst -10 "pos") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst 3 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (split) (("1" (flatten) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 1 2) (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (inst -5 "pos") (("1" (expand "finseq_appl") (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -6 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 1 2) (("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -6 -7) (("4" (inst -6 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -7 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "PartialERforK?") (("5" (flatten) (("5" (expand "removeSon") (("5" (expand "finseq_appl") (("5" (lift-if) (("5" (prop) (("1" (replaces) (("1" (hide -4 -5) (("1" (inst -4 "pos") (("1" (assert) (("1" (hide -1 -2 -5 2 3 4 5 6) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -3) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "i+1") (("1" (expand "nth" -) (("1" (propax) nil nil)) nil) ("2" (typepred "i") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "length" -) (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (hide -4 -5 -7) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -5 -6 -7) (("3" (inst -4 "j-1") (("1" (split) (("1" (propax) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "removeSon") (("6" (lift-if) (("6" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6 -8) (("1" (inst - "pos") (("1" (assert) (("1" (hide 2) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (inst -7 "i+1") (("1" (expand "nth" -) (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "length" -) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (expand "PartialERforK?") (("2" (assert) (("2" (assert) (("2" (flatten) (("2" (hide -4 -5 -7) (("2" (inst - "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -7 -6 -5) (("3" (inst -4 "j-1") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (inst 3 "i") (("1" (expand "upToOne") (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (typepred "pos") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (inst -7 "0") (("2" (flatten) (("2" (inst -8 "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9 -8 -6) (("1" (assert) (("1" (case "j <=
                                        bin_search(s`seqfj)(car(smallerones(s`seqfj`seq(indx`seq(pos)))))
                                                  (0, indx`seq(pos) - 1) => j <= indx`seq(t(k))") (("1" (expand "insert?") (("1" (lift-if) (("1" (prop) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide +) (("2" (expand "upToOne") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("4" (hide +) (("4" (expand "upToOne") (("4" (lift-if) (("4" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (expand "upToOne") (("5" (lift-if) (("5" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("6" (hide +) (("6" (expand "upToOne") (("6" (lift-if) (("6" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("7" (expand "removeSon") (("7" (assert) nil nil)) nil) ("8" (assert) nil nil) ("9" (assert) nil nil) ("10" (assert) nil nil) ("11" (expand "finseq_appl") (("11" (expand "upToOne") (("11" (expand "finseq_appl") (("11" (lift-if) (("11" (prop) (("1" (lemma "b_search_bound") (("1" (inst?) (("1" (flatten) (("1" (hide -1) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -8 "pos") (("1" (flatten) (("1" (inst -9 "t(k)") (("1" (typepred "pos") (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (hide -10) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (inst -10 "0") (("2" (flatten) (("2" (inst -11 "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (both-sides "-" "1" -1) (("2" (assert) (("2" (inst -6 "j-1") (("1" (assert) (("1" (flatten) (("1" (expand "removeSon") (("1" (assert) (("1" (split 2) (("1" (flatten) (("1" (hide +) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -7 "pos") (("1" (flatten) (("1" (inst -8 "t(k)") (("1" (typepred "pos") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (case "j - 1 > indx`seq(t(k))") (("1" (hide -3) (("1" (inst -6 "j - 1") (("1" (assert) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (skeep) (("1" (inst 1 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split 1) (("1" (case-replace "i=pos") (("1" (typepred "pos") (("1" (swap-rel -9) (("1" (replaces) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (lemma "b_search_bound") (("2" (inst?) (("1" (flatten) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (flatten) (("3" (expand "upToOne") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (typepred "pos") (("4" (hide -9) (("4" (expand "is_indx?") (("4" (flatten) (("4" (lemma "is_sorted_equiv[nat, <=]") (("4" (inst?) (("4" (assert) (("4" (inst -1 "0" "pos") (("4" (inst -9 "0") (("4" (flatten) (("4" (inst -10 "pos") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "j < 1 + indx`seq(t(k - 1))") (("1" (expand "insert?") (("1" (prop) (("1" (expand "finseq_appl") (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9) (("1" (inst -8 "j") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (skeep) (("1" (inst -10 "i") (("1" (prop) (("1" (typepred "i") (("1" (swap-rel -14) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "i") (("1" (inst -11 "i") (("1" (flatten) (("1" (inst -12 "t(k-1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (assert) (("2" (swap-rel -12) (("2" (replaces) (("2" (case-replace "indx`seq(i) <= indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k)" "i") (("1" (inst -12 "i") (("1" (flatten) (("1" (inst -13 "t(k)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "indx`seq(t(k-1)) < indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "k-1" "k") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "t(k)") (("2" (inst -13 "t(k-1)") (("2" (flatten) (("2" (inst -14 "t(k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -8 -9) (("2" (inst -8 "pos") (("1" (assert) (("1" (hide-all-but (-8 1)) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -2 "0") (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (assert) (("3" (expand "removeSon") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (both-sides "-" "1" -3) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "pos") (("1" (assert) nil nil) ("2" (typepred "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (both-sides "-" "1" -2) (("2" (hide -3 -4 -8) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "pos") (("1" (assert) nil nil) ("2" (typepred "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -8) (("3" (inst -7 "j-1") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst -9 "i") (("1" (assert) (("1" (prop) (("1" (swap-rel -9) (("1" (both-sides "-" "1" -2) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (typepred "i") (("1" (assert) (("1" (inst -4 "t(k-1)" "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (assert) (("2" (both-sides "-" "1" -4) (("2" (swap-rel -11) (("2" (replaces) (("2" (assert) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (prop) (("1" (expand "finseq_appl") (("1" (expand "insert?") (("1" (prop) (("1" (assert) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -7 -8) (("1" (inst -8 "i") (("1" (assert) nil nil) ("2" (typepred "k") (("2" (flatten) (("2" (typepred "t(k - 1)") (("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "is_indx?") (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide +) (("2" (expand "is_indx?") (("2" (flatten) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (assert) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3 5) (("2" (name-replace "bsearch" " bin_search(s`seqfj)(car(smallerones(s`seqfj`seq(indx`seq(pos)))))
                           (0, indx`seq(pos) - 1)") (("1" (case "indx`seq(i) >= bsearch") (("1" (expand "removeSon") (("1" (lift-if) (("1" (assert) (("1" (prop) (("1" (hide -8 +) (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -7 "pos") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (inst -8 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -7 -8) (("2" (inst -7 "i") (("1" (assert) (("1" (typepred "n") (("1" (hide-all-but (-8 1 2)) (("1" (expand "nstruct?") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -5)) (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "pos") (("2" (flatten) (("2" (inst -4 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (inst -8 "i") (("1" (assert) nil nil) ("2" (hide -6 -7 -8) (("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (rewrite "<") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide 2 3 4 5) (("2" (typepred "pos") (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -7 "pos") (("2" (flatten) (("2" (inst -8 "0") (("2" (assert) (("2" (lemma " sorting_seq [nat,restrict[[real, real], [nat, nat], boolean](<=)].is_sorted_equiv") (("2" (inst?) (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "insert?") (("2" (prop) (("1" (expand "upToOne") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (assert) (("1" (hide -7 -8) (("1" (inst -7 "i") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "removeSon") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -5 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (expand "upToOne") (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6) (("1" (inst -5 "pos") (("1" (assert) (("1" (hide-all-but (-1 -5 1)) (("1" (expand "nstruct?") (("1" (flatten) (("1" (prop) (("1" (hide -4) (("1" (expand "length" -3) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "i!1+1") (("1" (expand "nth" -) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (typepred "i!1") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -3) (("3" (expand "length" -) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (hide 2 3 4 5 6 7 8) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (typepred "n") (("1" (hide -6) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "is_indx?") (("3" (flatten) (("3" (lemma "is_sorted_equiv[nat, <=]") (("3" (inst?) (("3" (assert) (("3" (inst -1 "pos" "i") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -6 -7) (("3" (assert) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i" "pos") (("2" (name-replace "bsearch" " bin_search(s`seqfj)(car(smallerones(s`seqfj`seq(indx`seq(pos)))))
                           (0, indx`seq(pos) - 1)") (("1" (case " indx`seq(i) >= bsearch") (("1" (expand "upToOne" -2) (("1" (assert) (("1" (expand "removeSon") (("1" (lift-if) (("1" (assert) (("1" (split +) (("1" (flatten) (("1" (case-replace "i=pos") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -12 -13) (("1" (inst -12 "pos") (("1" (assert) (("1" (split +) (("1" (flatten) (("1" (hide-all-but (-1 -13 1)) (("1" (expand "nstruct?") (("1" (flatten) (("1" (split +) (("1" (flatten) (("1" (split +) (("1" (expand "length" -) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (inst -4 "i!1+1") (("1" (assert) (("1" (flatten) (("1" (expand "nth" -) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "i!1") (("2" (expand "length" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case-replace "n=1") (("1" (expand "length" -) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (hide 2 3 4 5 6 7 8) (("2" (expand "nstruct?") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3 -10 1)) (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -4 "i") (("2" (flatten) (("2" (inst -5 "pos") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -12 -11) (("2" (inst -11 "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide 2 3 4 5 6 7) (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -9 "pos") (("2" (flatten) (("2" (inst -10 "0") (("2" (assert) (("2" (assert) (("2" (lemma "sorting_seq [nat, restrict[[real, real], [nat, nat], boolean](<=)].is_sorted_equiv") (("2" (inst?) (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -4 -5 -6) (("4" (case "is_sorted?(removeSon(s`seqfj, indx`seq(pos)))") (("1" (assert) (("1" (lemma "b_search_preserves_sorting") (("1" (inst -1 "removeSon(s`seqfj, indx`seq(pos))" "car(smallerones(s`seqfj`seq(indx`seq(pos))))" "0" " indx`seq(pos) - 1") (("1" (assert) (("1" (split) (("1" (lemma "b_search_removeSon") (("1" (inst?) (("1" (assert) (("1" (hide -1 2) (("1" (reveal -6) (("1" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (flatten) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "removeSon" +) (("2" (reveal -4) (("2" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "removeSon") (("2" (split) (("1" (typepred "pos") (("1" (expand "is_indx?") (("1" (flatten) (("1" (copy -5) (("1" (expand "is_sorted?" -6) (("1" (inst -6 "0") (("1" (assert) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -8 "0") (("1" (flatten) (("1" (inst -9 "1") (("1" (inst -1 "1" "pos") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "pos") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "removeSon") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "is_sorted?") (("2" (skeep) (("2" (inst -5 "i") (("1" (expand "removeSon" -1) (("1" (assert) (("1" (expand "removeSon") (("1" (lift-if) (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((is_sorted_equiv formula-decl nil sorting_seq nil) (/= const-decl "boolean" notequal nil) (finite_sequence type-eq-decl nil finite_sequences nil) (insert? const-decl "finseq" seq_extras structures) (TRUE const-decl "bool" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (restrict const-decl "R" restrict nil) (is_sorted? const-decl "bool" sorting_seq nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (int_plus_int_is_int application-judgement "int" integers nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (both_sides_minus_lt1 formula-decl nil real_props nil) (total_order_restrict application-judgement "(total_order?[S])" restrict_order_props nil) (dichotomous_restrict application-judgement "(dichotomous?[S])" restrict_order_props nil) (partial_order_restrict application-judgement "(partial_order?[S])" restrict_order_props nil) (preorder_restrict application-judgement "(preorder?[S])" restrict_order_props nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (antisymmetric_restrict application-judgement "(antisymmetric?[S])" restrict_order_props nil) (reflexive_restrict application-judgement "(reflexive?[S])" restrict_order_props nil) (t_is_increasing formula-decl nil ford_johnson nil) (odd? const-decl "bool" integers nil) (both_sides_minus_gt1 formula-decl nil real_props nil) (b_search_bound formula-decl nil ford_johnson nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (rat_exp application-judgement "rat" exponentiation nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (b_search_preserves_sorting formula-decl nil ford_johnson nil) (b_search_removeSon formula-decl nil ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (PartialERforK? const-decl "bool" ford_johnson nil)) nil) (insertSonPreservesPartialERforK-6 nil 3797595465 ("" (skeep) (("" (beta) (("" (typepred "indx") (("" (auto-rewrite "finseq_appl") (("" (expand "PartialERforK?" 1) (("" (split) (("1" (expand "finseq_appl") (("1" (skeep) (("1" (name-replace "bsearch" "bin_search(s`seqfj)
                                              (car(smallerones
                                                   (s`seqfj`seq(indx`seq(pos)))))
                                              (0, indx`seq(pos) - 1)") (("1" (expand "insert?") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (expand "removeSon") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (hide 2) (("1" (inst -12 "pos") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "PartialERforK?") (("2" (expand "removeSon") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (lift-if) (("2" (prop) (("1" (inst -10 "pos") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst 3 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (split) (("1" (flatten) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 1 2) (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (inst -5 "pos") (("1" (expand "finseq_appl") (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -6 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 1 2) (("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -6 -7) (("4" (inst -6 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -7 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "PartialERforK?") (("5" (flatten) (("5" (expand "removeSon") (("5" (expand "finseq_appl") (("5" (lift-if) (("5" (prop) (("1" (replaces) (("1" (hide -4 -5) (("1" (inst -4 "pos") (("1" (assert) (("1" (hide -1 -2 -5 2 3 4 5 6) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -3) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "i+1") (("1" (expand "nth" -) (("1" (propax) nil nil)) nil) ("2" (typepred "i") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "length" -) (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (hide -4 -5 -7) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -5 -6 -7) (("3" (inst -4 "j-1") (("1" (split) (("1" (propax) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "removeSon") (("6" (lift-if) (("6" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6 -8) (("1" (inst - "pos") (("1" (assert) (("1" (hide 2) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (inst -7 "i+1") (("1" (expand "nth" -) (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "length" -) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (expand "PartialERforK?") (("2" (assert) (("2" (assert) (("2" (flatten) (("2" (hide -4 -5 -7) (("2" (inst - "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -7 -6 -5) (("3" (inst -4 "j-1") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (inst 3 "i") (("1" (expand "upToOne") (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (typepred "pos") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (inst -7 "0") (("2" (flatten) (("2" (inst -8 "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9 -8 -6) (("1" (assert) (("1" (case "j <=
                                        bin_search(s`seqfj)(car(smallerones(s`seqfj`seq(indx`seq(pos)))))
                                                  (0, indx`seq(pos) - 1) => j <= indx`seq(t(k))") (("1" (expand "insert?") (("1" (lift-if) (("1" (prop) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide +) (("2" (expand "upToOne") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("4" (hide +) (("4" (expand "upToOne") (("4" (lift-if) (("4" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (expand "upToOne") (("5" (lift-if) (("5" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("6" (hide +) (("6" (expand "upToOne") (("6" (lift-if) (("6" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("7" (expand "removeSon") (("7" (assert) nil nil)) nil) ("8" (assert) nil nil) ("9" (assert) nil nil) ("10" (assert) nil nil) ("11" (expand "finseq_appl") (("11" (expand "upToOne") (("11" (expand "finseq_appl") (("11" (lift-if) (("11" (prop) (("1" (lemma "b_search_bound") (("1" (inst?) (("1" (flatten) (("1" (hide -1) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -8 "pos") (("1" (flatten) (("1" (inst -9 "t(k)") (("1" (typepred "pos") (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (hide -10) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (inst -10 "0") (("2" (flatten) (("2" (inst -11 "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (both-sides "-" "1" -1) (("2" (assert) (("2" (inst -6 "j-1") (("1" (assert) (("1" (flatten) (("1" (expand "removeSon") (("1" (assert) (("1" (split 2) (("1" (flatten) (("1" (hide +) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -7 "pos") (("1" (flatten) (("1" (inst -8 "t(k)") (("1" (typepred "pos") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (case "j - 1 > indx`seq(t(k))") (("1" (hide -3) (("1" (inst -6 "j - 1") (("1" (assert) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (skeep) (("1" (inst 1 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split 1) (("1" (case-replace "i=pos") (("1" (typepred "pos") (("1" (swap-rel -9) (("1" (replaces) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (lemma "b_search_bound") (("2" (inst?) (("1" (flatten) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (flatten) (("3" (expand "upToOne") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (typepred "pos") (("4" (hide -9) (("4" (expand "is_indx?") (("4" (flatten) (("4" (lemma "is_sorted_equiv[nat, <=]") (("4" (inst?) (("4" (assert) (("4" (inst -1 "0" "pos") (("4" (inst -9 "0") (("4" (flatten) (("4" (inst -10 "pos") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "j < 1 + indx`seq(t(k - 1))") (("1" (expand "insert?") (("1" (prop) (("1" (expand "finseq_appl") (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9) (("1" (inst -8 "j") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (skeep) (("1" (inst -10 "i") (("1" (prop) (("1" (typepred "i") (("1" (swap-rel -14) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "i") (("1" (inst -11 "i") (("1" (flatten) (("1" (inst -12 "t(k-1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (assert) (("2" (swap-rel -12) (("2" (replaces) (("2" (case-replace "indx`seq(i) <= indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k)" "i") (("1" (inst -12 "i") (("1" (flatten) (("1" (inst -13 "t(k)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "indx`seq(t(k-1)) < indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "k-1" "k") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "t(k)") (("2" (inst -13 "t(k-1)") (("2" (flatten) (("2" (inst -14 "t(k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -8 -9) (("2" (inst -8 "pos") (("1" (assert) (("1" (hide-all-but (-8 1)) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -2 "0") (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (assert) (("3" (expand "removeSon") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (both-sides "-" "1" -3) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "pos") (("1" (assert) nil nil) ("2" (typepred "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (both-sides "-" "1" -2) (("2" (hide -3 -4 -8) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "pos") (("1" (assert) nil nil) ("2" (typepred "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -8) (("3" (inst -7 "j-1") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst -9 "i") (("1" (assert) (("1" (prop) (("1" (swap-rel -9) (("1" (both-sides "-" "1" -2) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (typepred "i") (("1" (assert) (("1" (inst -4 "t(k-1)" "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (assert) (("2" (both-sides "-" "1" -4) (("2" (swap-rel -11) (("2" (replaces) (("2" (assert) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (prop) (("1" (expand "finseq_appl") (("1" (expand "insert?") (("1" (prop) (("1" (assert) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -7 -8) (("1" (inst -8 "i") (("1" (assert) nil nil) ("2" (typepred "k") (("2" (flatten) (("2" (typepred "t(k - 1)") (("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "is_indx?") (("1" (flatten) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide +) (("2" (expand "is_indx?") (("2" (flatten) (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (assert) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "insert?") (("2" (prop) (("1" (expand "upToOne") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (assert) (("1" (hide -7 -8) (("1" (inst -7 "i") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "removeSon") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -5 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (expand "upToOne") (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6) (("1" (inst -5 "pos") (("1" (assert) (("1" (hide-all-but (-1 -5 1)) (("1" (expand "nstruct?") (("1" (flatten) (("1" (prop) (("1" (hide -4) (("1" (expand "length" -3) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "i!1+1") (("1" (expand "nth" -) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (typepred "i!1") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -3) (("3" (expand "length" -) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (hide 2 3 4 5 6 7 8) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (typepred "n") (("1" (hide -6) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "is_indx?") (("3" (flatten) (("3" (lemma "is_sorted_equiv[nat, <=]") (("3" (inst?) (("3" (assert) (("3" (inst -1 "pos" "i") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -6 -7) (("3" (assert) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i" "pos") (("2" (expand "upToOne") (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -4 -5 -6) (("4" (case "is_sorted?(removeSon(s`seqfj, indx`seq(pos)))") (("1" (assert) (("1" (lemma "b_search_preserves_sorting") (("1" (inst -1 "removeSon(s`seqfj, indx`seq(pos))" "car(smallerones(s`seqfj`seq(indx`seq(pos))))" "0" " indx`seq(pos) - 1") (("1" (assert) (("1" (split) (("1" (lemma "b_search_removeSon") (("1" (inst?) (("1" (assert) (("1" (hide -1 2) (("1" (reveal -6) (("1" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (flatten) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "removeSon" +) (("2" (reveal -4) (("2" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "removeSon") (("2" (split) (("1" (typepred "pos") (("1" (expand "is_indx?") (("1" (flatten) (("1" (copy -5) (("1" (expand "is_sorted?" -6) (("1" (inst -6 "0") (("1" (assert) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -8 "0") (("1" (flatten) (("1" (inst -9 "1") (("1" (inst -1 "1" "pos") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "pos") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "removeSon") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "is_sorted?") (("2" (skeep) (("2" (inst -5 "i") (("1" (expand "removeSon" -1) (("1" (assert) (("1" (expand "removeSon") (("1" (lift-if) (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (insertSonPreservesPartialERforK-5 nil 3797593535 ("" (skeep) (("" (beta) (("" (typepred "indx") (("" (auto-rewrite "finseq_appl") (("" (expand "PartialERforK?" 1) (("" (split) (("1" (expand "finseq_appl") (("1" (skeep) (("1" (name-replace "bsearch" "bin_search(s`seqfj)
                                      (car(smallerones
                                           (s`seqfj`seq(indx`seq(pos)))))
                                      (0, indx`seq(pos) - 1)") (("1" (expand "insert?") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (expand "removeSon") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (hide 2) (("1" (inst -12 "pos") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) nil))))))))))))))))) ("2" (expand "PartialERforK?") (("2" (expand "removeSon") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (lift-if) (("2" (prop) (("1" (inst -10 "pos") (("1" (assert) nil) ("2" (assert) nil))) ("2" (assert) nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst 3 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) nil))))) ("2" (expand "upToOne") (("2" (split) (("1" (flatten) (("1" (typepred "i") (("1" (assert) nil))))) ("2" (typepred "i") (("2" (propax) nil))))))))))))))))))))))))))))))) ("3" (hide -1 1 2) (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (inst -5 "pos") (("1" (expand "finseq_appl") (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -6 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil))))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("4" (hide 1 2) (("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -6 -7) (("4" (inst -6 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -7 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil))))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("5" (expand "PartialERforK?") (("5" (flatten) (("5" (expand "removeSon") (("5" (expand "finseq_appl") (("5" (lift-if) (("5" (prop) (("1" (replaces) (("1" (hide -4 -5) (("1" (inst -4 "pos") (("1" (assert) (("1" (hide -1 -2 -5 2 3 4 5 6) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -3) (("1" (lift-if) (("1" (prop) (("1" (assert) nil) ("2" (assert) nil))))))) ("2" (skeep) (("2" (inst -4 "i+1") (("1" (expand "nth" -) (("1" (propax) nil))) ("2" (typepred "i") (("2" (expand "length" 1) (("2" (assert) nil))))))))) ("3" (expand "length" -) (("3" (lift-if) (("3" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))) ("2" (replaces) (("2" (hide -4 -5 -7) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil))))) ("2" (typepred "pos") (("2" (propax) nil))))))))) ("3" (hide -5 -6 -7) (("3" (inst -4 "j-1") (("1" (split) (("1" (propax) nil) ("2" (assert) nil))) ("2" (assert) nil))))))))))))))))) ("6" (expand "removeSon") (("6" (lift-if) (("6" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6 -8) (("1" (inst - "pos") (("1" (assert) (("1" (hide 2) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -) (("1" (assert) nil))) ("2" (skeep) (("2" (inst -7 "i+1") (("1" (expand "nth" -) (("1" (propax) nil))) ("2" (expand "length") (("2" (assert) nil))))))) ("3" (expand "length" -) (("3" (assert) nil))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("2" (replaces) (("2" (expand "PartialERforK?") (("2" (assert) (("2" (assert) (("2" (flatten) (("2" (hide -4 -5 -7) (("2" (inst - "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))))))) ("3" (expand "finseq_appl") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -7 -6 -5) (("3" (inst -4 "j-1") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (inst 3 "i") (("1" (expand "upToOne") (("1" (assert) nil))) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split) (("1" (assert) nil) ("2" (assert) nil))))))))))))))) ("2" (assert) nil))))))))))))))))))))))))) ("2" (hide 2 3) (("2" (typepred "pos") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (inst -7 "0") (("2" (flatten) (("2" (inst -8 "pos") (("2" (assert) nil))))))))))))))))))))))))))))) ("2" (skeep) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9 -8 -6) (("1" (assert) (("1" (case "j <=
                  bin_search(s`seqfj)(car(smallerones(s`seqfj`seq(indx`seq(pos)))))
                            (0, indx`seq(pos) - 1) => j <= indx`seq(t(k))") (("1" (expand "insert?") (("1" (lift-if) (("1" (prop) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("2" (hide +) (("2" (expand "upToOne") (("2" (lift-if) (("2" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("3" (expand "upToOne") (("3" (lift-if) (("3" (prop) (("1" (assert) nil) ("2" (assert) nil))))))) ("4" (hide +) (("4" (expand "upToOne") (("4" (lift-if) (("4" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("5" (expand "upToOne") (("5" (lift-if) (("5" (prop) (("1" (assert) nil) ("2" (assert) nil))))))) ("6" (hide +) (("6" (expand "upToOne") (("6" (lift-if) (("6" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("7" (expand "removeSon") (("7" (assert) nil))) ("8" (assert) nil) ("9" (assert) nil) ("10" (assert) nil) ("11" (expand "finseq_appl") (("11" (expand "upToOne") (("11" (expand "finseq_appl") (("11" (lift-if) (("11" (prop) (("1" (lemma "b_search_bound") (("1" (inst?) (("1" (flatten) (("1" (hide -1) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -8 "pos") (("1" (flatten) (("1" (inst -9 "t(k)") (("1" (typepred "pos") (("1" (assert) nil))))))))))))))))))))))))))) ("2" (assert) nil))))) ("2" (both-sides "-" "1" -1) (("2" (assert) (("2" (inst -6 "j-1") (("1" (assert) (("1" (flatten) (("1" (expand "removeSon") (("1" (assert) (("1" (split 2) (("1" (flatten) (("1" (hide +) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -7 "pos") (("1" (flatten) (("1" (inst -8 "t(k)") (("1" (typepred "pos") (("1" (assert) nil))))))))))))))))))))))))) ("2" (propax) nil))))))))))) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil))))))))))))))))))))))) ("12" (case "j - 1 > indx`seq(t(k))") (("1" (hide -3) (("1" (inst -6 "j - 1") (("1" (assert) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (skeep) (("1" (inst 1 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) nil))))) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split 1) (("1" (case-replace "i=pos") (("1" (typepred "pos") (("1" (swap-rel -9) (("1" (replaces) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil))))))))))))))))))) ("2" (flatten) (("2" (assert) nil))))) ("2" (propax) nil))))))))))))) ("2" (expand "upToOne") (("2" (propax) nil))))))))) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil))))))))))) ("2" (expand "upToOne") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("3" (expand "upToOne") (("3" (propax) nil))))))))))) ("2" (hide 2) (("2" (flatten) (("2" (lemma "b_search_bound") (("2" (inst?) (("1" (flatten) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil))))))))))))))))) ("2" (assert) nil))))))))) ("3" (hide 2) (("3" (flatten) (("3" (expand "upToOne") (("3" (propax) nil))))))) ("4" (hide 2) (("4" (typepred "pos") (("4" (hide -9) (("4" (expand "is_indx?") (("4" (flatten) (("4" (lemma "is_sorted_equiv") (("4" (inst?) (("4" (assert) (("4" (inst -1 "0" "pos") (("4" (inst -9 "0") (("4" (flatten) (("4" (inst -10 "pos") (("4" (assert) nil))))))))))))))))))))))))))))))))))))) ("2" (flatten) (("2" (case "j < 1 + indx`seq(t(k - 1))") (("1" (expand "insert?") (("1" (prop) (("1" (expand "finseq_appl") (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9) (("1" (inst -8 "j") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (skeep) (("1" (inst -10 "i") (("1" (prop) (("1" (typepred "i") (("1" (swap-rel -14) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "i") (("1" (inst -11 "i") (("1" (flatten) (("1" (inst -12 "t(k-1)") (("1" (assert) nil))))))))))))))))))))))))))) ("2" (assert) nil))) ("2" (typepred "i") (("2" (assert) (("2" (swap-rel -12) (("2" (replaces) (("2" (case-replace "indx`seq(i) <= indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k)" "i") (("1" (inst -12 "i") (("1" (flatten) (("1" (inst -13 "t(k)") (("1" (assert) nil))))))))))))))))))) ("2" (case "indx`seq(t(k-1)) < indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) nil))))))))) ("2" (lemma "t_is_increasing") (("2" (inst -1 "k-1" "k") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "t(k)") (("2" (inst -13 "t(k-1)") (("2" (flatten) (("2" (inst -14 "t(k)") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -8 -9) (("2" (inst -8 "pos") (("1" (assert) (("1" (hide-all-but (-8 1)) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -2 "0") (("1" (assert) (("1" (expand "nth") (("1" (propax) nil))))) ("2" (assert) nil))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))) ("3" (assert) (("3" (assert) (("3" (expand "removeSon") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (both-sides "-" "1" -3) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "pos") (("1" (assert) nil) ("2" (typepred "pos") (("2" (assert) nil))))))))))))))))) ("2" (both-sides "-" "1" -2) (("2" (hide -3 -4 -8) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "pos") (("1" (assert) nil) ("2" (typepred "pos") (("2" (assert) nil))))))))))))))))))) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -8) (("3" (inst -7 "j-1") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst -9 "i") (("1" (assert) (("1" (prop) (("1" (swap-rel -9) (("1" (both-sides "-" "1" -2) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (typepred "i") (("1" (assert) (("1" (inst -4 "t(k-1)" "i") (("1" (assert) nil))))))))))))))))))))))))))))) ("2" (typepred "i") (("2" (assert) (("2" (both-sides "-" "1" -4) (("2" (swap-rel -11) (("2" (replaces) (("2" (assert) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "i") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("2" (assert) nil))))))))) ("3" (expand "upToOne") (("3" (propax) nil))))))))))))) ("3" (skeep) (("3" (prop) (("1" (expand "finseq_appl") (("1" (expand "insert?") (("1" (prop) (("1" (assert) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -7 -8) (("1" (inst -7 "i") (("1" (assert) nil) ("2" (typepred "i") (("2" (propax) nil))))))))))))))) ("2" (assert) nil))))))))))) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("2" (assert) nil))))))))) ("3" (expand "upToOne") (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("3" (expand "removeSon") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -6 "i") (("1" (assert) (("1" (flatten) (("1" (inst -7 "pos") nil))))))))))) ("2" (hide +) (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -5 "i") (("2" (flatten) (("2" (inst -6 "pos") (("2" (assert) nil))))))))))))) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (inst -5 "i") (("1" (assert) nil) ("2" (typepred "i") (("2" (propax) nil))))))))))))))))))))))))))))))))) ("2" (expand "finseq_appl") (("2" (expand "insert?") (("2" (prop) (("1" (expand "upToOne") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (inst -6 "indx`seq(i)") (("1" (assert) (("1" (hide -7 -8) (("1" (flatten) (("1" (skeep) (("1" (typepred "i_1") (("1" (case-replace "i_1 = i") (("1" (assert) nil) ("2" (hide-all-but (-7 -10 1)) (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -2 "i_1") (("2" (flatten) (("2" (inst -3 "i") (("1" (assert) nil) ("2" (assert) nil))))))))))))))))))))))))))))))))))) ("2" (expand "removeSon") (("2" (assert) nil))))))))))) ("2" (hide -1) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -5 "0") (("1" (expand "nth") (("1" (propax) nil))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("3" (expand "finseq_appl") (("3" (expand "upToOne") (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("3" (expand "removeSon") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6) (("1" (inst -5 "pos") (("1" (assert) (("1" (hide-all-but (-1 -5 1)) (("1" (expand "nstruct?") (("1" (flatten) (("1" (prop) (("1" (hide -4) (("1" (expand "length" -3) (("1" (assert) nil))))) ("2" (skeep) (("2" (inst -4 "i!1+1") (("1" (expand "nth" -) (("1" (propax) nil))) ("2" (hide 2) (("2" (typepred "i!1") (("2" (expand "length") (("2" (assert) nil))))))))))) ("3" (hide -3) (("3" (expand "length" -) (("3" (assert) nil))))))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("2" (replaces) (("2" (hide 2 3 4 5 6 7 8) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (typepred "n") (("1" (hide -6) (("1" (expand "length") (("1" (assert) nil))))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))))) ("3" (expand "is_indx?") (("3" (flatten) (("3" (lemma "is_sorted_equiv") (("3" (inst?) (("3" (assert) (("3" (inst -1 "pos" "i") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -6 -7) (("3" (inst -6 "i") (("1" (assert) nil) ("2" (typepred "i") (("2" (propax) nil))))))))))))))))))))))))))))))))))))))))))))))))))) ("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -4 -5 -6) (("4" (case "is_sorted?(removeSon(s`seqfj, indx`seq(pos)))") (("1" (assert) (("1" (lemma "b_search_preserves_sorting") (("1" (inst -1 "removeSon(s`seqfj, indx`seq(pos))" "car(smallerones(s`seqfj`seq(indx`seq(pos))))" "0" " indx`seq(pos) - 1") (("1" (assert) (("1" (split) (("1" (lemma "b_search_removeSon") (("1" (inst?) (("1" (assert) (("1" (hide -1 2) (("1" (reveal -6) (("1" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (flatten) nil))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))) ("2" (assert) nil))))) ("2" (hide 2) (("2" (expand "removeSon" +) (("2" (reveal -4) (("2" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (assert) nil))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))))) ("2" (hide -1 2) (("2" (expand "removeSon") (("2" (split) (("1" (typepred "pos") (("1" (expand "is_indx?") (("1" (flatten) (("1" (copy -5) (("1" (expand "is_sorted?" -6) (("1" (inst -6 "0") (("1" (assert) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -8 "0") (("1" (flatten) (("1" (inst -9 "1") (("1" (inst -1 "1" "pos") (("1" (assert) nil))))))))))))))))))))))))))))) ("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "pos") (("2" (assert) nil))))))))))))) ("3" (hide 2) (("3" (expand "removeSon") (("3" (assert) nil))))))))))) ("2" (hide 2) (("2" (expand "is_sorted?") (("2" (skeep) (("2" (inst -5 "i") (("1" (expand "removeSon" -1) (("1" (assert) (("1" (expand "removeSon") (("1" (lift-if) (("1" (expand "finseq_appl") (("1" (propax) nil))))))))))) ("2" (hide 2) (("2" (expand "removeSon") (("2" (assert) nil)))))))))))))))))))))))))))))))) nil) nil nil) (insertSonPreservesPartialERforK-4 nil 3797590125 ("" (skeep) (("" (beta) (("" (typepred "indx") (("" (auto-rewrite "finseq_appl") (("" (expand "PartialERforK?" 1) (("" (split) (("1" (expand "finseq_appl") (("1" (skeep) (("1" (name-replace "bsearch" "bin_search(s`seqfj)
                                      (car(smallerones
                                           (s`seqfj`seq(indx`seq(pos)))))
                                      (0, indx`seq(pos) - 1)") (("1" (expand "insert?") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (expand "removeSon") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (hide 2) (("1" (inst -12 "pos") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) nil))))))))))))))))) ("2" (expand "PartialERforK?") (("2" (expand "removeSon") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (lift-if) (("2" (prop) (("1" (inst -10 "pos") (("1" (assert) nil) ("2" (assert) nil))) ("2" (assert) nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst 3 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) nil))))) ("2" (expand "upToOne") (("2" (split) (("1" (flatten) (("1" (typepred "i") (("1" (assert) nil))))) ("2" (typepred "i") (("2" (propax) nil))))))))))))))))))))))))))))))) ("3" (hide -1 1 2) (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (inst -5 "pos") (("1" (expand "finseq_appl") (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -6 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil))))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("4" (hide 1 2) (("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -6 -7) (("4" (inst -6 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -7 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil))))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("5" (expand "PartialERforK?") (("5" (flatten) (("5" (expand "removeSon") (("5" (expand "finseq_appl") (("5" (lift-if) (("5" (prop) (("1" (replaces) (("1" (hide -4 -5) (("1" (inst -4 "pos") (("1" (assert) (("1" (hide -1 -2 -5 2 3 4 5 6) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -3) (("1" (lift-if) (("1" (prop) (("1" (assert) nil) ("2" (assert) nil))))))) ("2" (skeep) (("2" (inst -4 "i+1") (("1" (expand "nth" -) (("1" (propax) nil))) ("2" (typepred "i") (("2" (expand "length" 1) (("2" (assert) nil))))))))) ("3" (expand "length" -) (("3" (lift-if) (("3" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))) ("2" (replaces) (("2" (hide -4 -5 -7) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil))))) ("2" (typepred "pos") (("2" (propax) nil))))))))) ("3" (hide -5 -6 -7) (("3" (inst -4 "j-1") (("1" (split) (("1" (propax) nil) ("2" (assert) nil))) ("2" (assert) nil))))))))))))))))) ("6" (expand "removeSon") (("6" (lift-if) (("6" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6 -8) (("1" (inst - "pos") (("1" (assert) (("1" (hide 2) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -) (("1" (assert) nil))) ("2" (skeep) (("2" (inst -7 "i+1") (("1" (expand "nth" -) (("1" (propax) nil))) ("2" (expand "length") (("2" (assert) nil))))))) ("3" (expand "length" -) (("3" (assert) nil))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("2" (replaces) (("2" (expand "PartialERforK?") (("2" (assert) (("2" (assert) (("2" (flatten) (("2" (hide -4 -5 -7) (("2" (inst - "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))))))) ("3" (expand "finseq_appl") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -7 -6 -5) (("3" (inst -4 "j-1") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (inst 3 "i") (("1" (expand "upToOne") (("1" (assert) nil))) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split) (("1" (assert) nil) ("2" (assert) nil))))))))))))))) ("2" (assert) nil))))))))))))))))))))))))) ("2" (hide 2 3) (("2" (typepred "pos") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (inst -7 "0") (("2" (flatten) (("2" (inst -8 "pos") (("2" (assert) nil))))))))))))))))))))))))))))) ("2" (skeep) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9 -8 -6) (("1" (assert) (("1" (case "j <=
                  bin_search(s`seqfj)(car(smallerones(s`seqfj`seq(indx`seq(pos)))))
                            (0, indx`seq(pos) - 1) => j <= indx`seq(t(k))") (("1" (expand "insert?") (("1" (lift-if) (("1" (prop) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("2" (hide +) (("2" (expand "upToOne") (("2" (lift-if) (("2" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("3" (expand "upToOne") (("3" (lift-if) (("3" (prop) (("1" (assert) nil) ("2" (assert) nil))))))) ("4" (hide +) (("4" (expand "upToOne") (("4" (lift-if) (("4" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("5" (expand "upToOne") (("5" (lift-if) (("5" (prop) (("1" (assert) nil) ("2" (assert) nil))))))) ("6" (hide +) (("6" (expand "upToOne") (("6" (lift-if) (("6" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("7" (expand "removeSon") (("7" (assert) nil))) ("8" (assert) nil) ("9" (assert) nil) ("10" (assert) nil) ("11" (expand "finseq_appl") (("11" (expand "upToOne") (("11" (expand "finseq_appl") (("11" (lift-if) (("11" (prop) (("1" (lemma "b_search_bound") (("1" (inst?) (("1" (flatten) (("1" (hide -1) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -8 "pos") (("1" (flatten) (("1" (inst -9 "t(k)") (("1" (typepred "pos") (("1" (assert) nil))))))))))))))))))))))))))) ("2" (assert) nil))))) ("2" (both-sides "-" "1" -1) (("2" (assert) (("2" (inst -6 "j-1") (("1" (assert) (("1" (flatten) (("1" (expand "removeSon") (("1" (assert) (("1" (split 2) (("1" (flatten) (("1" (hide +) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -7 "pos") (("1" (flatten) (("1" (inst -8 "t(k)") (("1" (typepred "pos") (("1" (assert) nil))))))))))))))))))))))))) ("2" (propax) nil))))))))))) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil))))))))))))))))))))))) ("12" (case "j - 1 > indx`seq(t(k))") (("1" (hide -3) (("1" (inst -6 "j - 1") (("1" (assert) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (skeep) (("1" (inst 1 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) nil))))) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split 1) (("1" (case-replace "i=pos") (("1" (typepred "pos") (("1" (swap-rel -9) (("1" (replaces) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil))))))))))))))))))) ("2" (flatten) (("2" (assert) nil))))) ("2" (propax) nil))))))))))))) ("2" (expand "upToOne") (("2" (propax) nil))))))))) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil))))))))))) ("2" (expand "upToOne") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("3" (expand "upToOne") (("3" (propax) nil))))))))))) ("2" (hide 2) (("2" (flatten) (("2" (lemma "b_search_bound") (("2" (inst?) (("1" (flatten) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil))))))))))))))))) ("2" (assert) nil))))))))) ("3" (hide 2) (("3" (flatten) (("3" (expand "upToOne") (("3" (propax) nil))))))) ("4" (hide 2) (("4" (typepred "pos") (("4" (hide -9) (("4" (expand "is_indx?") (("4" (flatten) (("4" (lemma "is_sorted_equiv[nat, <=]") (("4" (inst?) (("4" (assert) (("4" (inst -1 "0" "pos") (("4" (inst -9 "0") (("4" (flatten) (("4" (inst -10 "pos") (("4" (assert) nil))))))))))))))))))))))))))))))))))))) ("2" (flatten) (("2" (case "j < 1 + indx`seq(t(k - 1))") (("1" (expand "insert?") (("1" (prop) (("1" (expand "finseq_appl") (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9) (("1" (inst -8 "j") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (skeep) (("1" (inst -10 "i") (("1" (prop) (("1" (typepred "i") (("1" (swap-rel -14) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "i") (("1" (inst -11 "i") (("1" (flatten) (("1" (inst -12 "t(k-1)") (("1" (assert) nil))))))))))))))))))))))))))) ("2" (assert) nil))) ("2" (typepred "i") (("2" (assert) (("2" (swap-rel -12) (("2" (replaces) (("2" (case-replace "indx`seq(i) <= indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k)" "i") (("1" (inst -12 "i") (("1" (flatten) (("1" (inst -13 "t(k)") (("1" (assert) nil))))))))))))))))))) ("2" (case "indx`seq(t(k-1)) < indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) nil))))))))) ("2" (lemma "t_is_increasing") (("2" (inst -1 "k-1" "k") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "t(k)") (("2" (inst -13 "t(k-1)") (("2" (flatten) (("2" (inst -14 "t(k)") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -8 -9) (("2" (inst -8 "pos") (("1" (assert) (("1" (hide-all-but (-8 1)) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -2 "0") (("1" (assert) (("1" (expand "nth") (("1" (propax) nil))))) ("2" (assert) nil))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))) ("3" (assert) (("3" (assert) (("3" (expand "removeSon") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (both-sides "-" "1" -3) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "pos") (("1" (assert) nil) ("2" (typepred "pos") (("2" (assert) nil))))))))))))))))) ("2" (both-sides "-" "1" -2) (("2" (hide -3 -4 -8) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "pos") (("1" (assert) nil) ("2" (typepred "pos") (("2" (assert) nil))))))))))))))))))) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -8) (("3" (inst -7 "j-1") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst -9 "i") (("1" (assert) (("1" (prop) (("1" (swap-rel -9) (("1" (both-sides "-" "1" -2) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (typepred "i") (("1" (assert) (("1" (inst -4 "t(k-1)" "i") (("1" (assert) nil))))))))))))))))))))))))))))) ("2" (typepred "i") (("2" (assert) (("2" (both-sides "-" "1" -4) (("2" (swap-rel -11) (("2" (replaces) (("2" (assert) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "i") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("2" (assert) nil))))))))) ("3" (expand "upToOne") (("3" (propax) nil))))))))))))) ("3" (skeep) (("3" (prop) (("1" (expand "finseq_appl") (("1" (expand "insert?") (("1" (prop) (("1" (assert) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -7 -8) (("1" (inst -7 "i") (("1" (assert) nil) ("2" (typepred "i") (("2" (propax) nil))))))))))))))) ("2" (assert) nil))))))))))) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("2" (assert) nil))))))))) ("3" (expand "upToOne") (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("3" (expand "removeSon") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -6 "i") (("1" (assert) (("1" (flatten) (("1" (inst -7 "pos") nil))))))))))) ("2" (hide +) (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -5 "i") (("2" (flatten) (("2" (inst -6 "pos") (("2" (assert) nil))))))))))))) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (inst -5 "i") (("1" (assert) nil) ("2" (typepred "i") (("2" (propax) nil))))))))))))))))))))))))))))))))) ("2" (expand "finseq_appl") (("2" (expand "insert?") (("2" (prop) (("1" (expand "upToOne") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (inst -6 "indx`seq(i)") (("1" (assert) (("1" (hide -7 -8) (("1" (flatten) (("1" (skeep) (("1" (typepred "i_1") (("1" (case-replace "i_1 = i") (("1" (assert) nil) ("2" (hide-all-but (-7 -10 1)) (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -2 "i_1") (("2" (flatten) (("2" (inst -3 "i") (("1" (assert) nil) ("2" (assert) nil))))))))))))))))))))))))))))))))))) ("2" (expand "removeSon") (("2" (assert) nil))))))))))) ("2" (hide -1) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -5 "0") (("1" (expand "nth") (("1" (propax) nil))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("3" (expand "finseq_appl") (("3" (expand "upToOne") (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("3" (expand "removeSon") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6) (("1" (inst -5 "pos") (("1" (assert) (("1" (hide-all-but (-1 -5 1)) (("1" (expand "nstruct?") (("1" (flatten) (("1" (prop) (("1" (hide -4) (("1" (expand "length" -3) (("1" (assert) nil))))) ("2" (skeep) (("2" (inst -4 "i!1+1") (("1" (expand "nth" -) (("1" (propax) nil))) ("2" (hide 2) (("2" (typepred "i!1") (("2" (expand "length") (("2" (assert) nil))))))))))) ("3" (hide -3) (("3" (expand "length" -) (("3" (assert) nil))))))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("2" (replaces) (("2" (hide 2 3 4 5 6 7 8) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (typepred "n") (("1" (hide -6) (("1" (expand "length") (("1" (assert) nil))))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))))) ("3" (expand "is_indx?") (("3" (flatten) (("3" (lemma "is_sorted_equiv[nat, <=]") (("3" (inst?) (("3" (assert) (("3" (inst -1 "pos" "i") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -6 -7) (("3" (inst -6 "i") (("1" (assert) nil) ("2" (typepred "i") (("2" (propax) nil))))))))))))))))))))))))))))))))))))))))))))))))))) ("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -4 -5 -6) (("4" (case "is_sorted?(removeSon(s`seqfj, indx`seq(pos)))") (("1" (assert) (("1" (lemma "b_search_preserves_sorting") (("1" (inst -1 "removeSon(s`seqfj, indx`seq(pos))" "car(smallerones(s`seqfj`seq(indx`seq(pos))))" "0" " indx`seq(pos) - 1") (("1" (assert) (("1" (split) (("1" (lemma "b_search_removeSon") (("1" (inst?) (("1" (assert) (("1" (hide -1 2) (("1" (reveal -6) (("1" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (flatten) nil))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))) ("2" (assert) nil))))) ("2" (hide 2) (("2" (expand "removeSon" +) (("2" (reveal -4) (("2" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (assert) nil))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))))) ("2" (hide -1 2) (("2" (expand "removeSon") (("2" (split) (("1" (typepred "pos") (("1" (expand "is_indx?") (("1" (flatten) (("1" (copy -5) (("1" (expand "is_sorted?" -6) (("1" (inst -6 "0") (("1" (assert) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -8 "0") (("1" (flatten) (("1" (inst -9 "1") (("1" (inst -1 "1" "pos") (("1" (assert) nil))))))))))))))))))))))))))))) ("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "pos") (("2" (assert) nil))))))))))))) ("3" (hide 2) (("3" (expand "removeSon") (("3" (assert) nil))))))))))) ("2" (hide 2) (("2" (expand "is_sorted?") (("2" (skeep) (("2" (inst -5 "i") (("1" (expand "removeSon" -1) (("1" (assert) (("1" (expand "removeSon") (("1" (lift-if) (("1" (expand "finseq_appl") (("1" (propax) nil))))))))))) ("2" (hide 2) (("2" (expand "removeSon") (("2" (assert) nil)))))))))))))))))))))))))))))))) nil) nil nil) (insertSonPreservesPartialERforK-3 nil 3797360042 ("" (skeep) (("" (beta) (("" (typepred "indx") (("" (auto-rewrite "finseq_appl") (("" (expand "PartialERforK?" 1) (("" (split) (("1" (expand "finseq_appl") (("1" (skeep) (("1" (name-replace "bsearch" "bin_search(s`seqfj)
                                          (car(smallerones
                                               (s`seqfj`seq(indx`seq(pos)))))
                                          (0, indx`seq(pos) - 1)") (("1" (expand "insert?") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (expand "removeSon") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (hide 2) (("1" (inst -12 "pos") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) nil))))))))))))))))) ("2" (expand "PartialERforK?") (("2" (expand "removeSon") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (lift-if) (("2" (prop) (("1" (inst -10 "pos") (("1" (assert) nil) ("2" (assert) nil))) ("2" (assert) nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst 3 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) (("1" (grind) nil))))))) ("2" (expand "upToOne") (("2" (split) (("1" (flatten) (("1" (typepred "i") (("1" (assert) nil))))) ("2" (typepred "i") (("2" (propax) nil))))))))))))))))))))))))))))))) ("3" (hide -1 1 2) (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (inst -5 "pos") (("1" (expand "finseq_appl") (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -6 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil))))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("4" (hide 1 2) (("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -6 -7) (("4" (inst -6 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -7 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil))))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("5" (expand "PartialERforK?") (("5" (flatten) (("5" (expand "removeSon") (("5" (expand "finseq_appl") (("5" (lift-if) (("5" (prop) (("1" (replaces) (("1" (hide -4 -5) (("1" (inst -4 "pos") (("1" (assert) (("1" (hide -1 -2 -5 2 3 4 5 6) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -3) (("1" (lift-if) (("1" (prop) (("1" (assert) nil) ("2" (assert) nil))))))) ("2" (skeep) (("2" (inst -4 "i+1") (("1" (expand "nth" -) (("1" (propax) nil))) ("2" (typepred "i") (("2" (expand "length" 1) (("2" (assert) nil))))))))) ("3" (expand "length" -) (("3" (lift-if) (("3" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))) ("2" (replaces) (("2" (hide -4 -5 -7) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil))))) ("2" (typepred "pos") (("2" (propax) nil))))))))) ("3" (hide -5 -6 -7) (("3" (inst -4 "j-1") (("1" (split) (("1" (propax) nil) ("2" (assert) nil))) ("2" (assert) nil))))))))))))))))) ("6" (expand "removeSon") (("6" (lift-if) (("6" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6 -8) (("1" (inst - "pos") (("1" (assert) (("1" (hide 2) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -) (("1" (assert) nil))) ("2" (skeep) (("2" (inst -7 "i+1") (("1" (expand "nth" -) (("1" (propax) nil))) ("2" (expand "length") (("2" (assert) nil))))))) ("3" (expand "length" -) (("3" (assert) nil))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("2" (replaces) (("2" (expand "PartialERforK?") (("2" (assert) (("2" (assert) (("2" (flatten) (("2" (hide -4 -5 -7) (("2" (inst - "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))))))) ("3" (expand "finseq_appl") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -7 -6 -5) (("3" (inst -4 "j-1") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (inst 3 "i") (("1" (expand "upToOne") (("1" (assert) (("1" (grind) nil))))) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split) (("1" (assert) nil) ("2" (assert) nil))))))))))))))) ("2" (assert) nil))))))))))))))))))))))))) ("2" (hide 2 3) (("2" (typepred "pos") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (inst -7 "0") (("2" (flatten) (("2" (inst -8 "pos") (("2" (assert) nil))))))))))))))))))))))))))))) ("2" (skeep) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9 -8 -6) (("1" (assert) (("1" (case "j <=
                             bin_search(s`seqfj)(car(smallerones(s`seqfj`seq(indx`seq(pos)))))
                                       (0, indx`seq(pos) - 1) => j <= indx`seq(t(k))") (("1" (expand "insert?") (("1" (lift-if) (("1" (prop) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("2" (hide +) (("2" (expand "upToOne") (("2" (lift-if) (("2" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("3" (expand "upToOne") (("3" (lift-if) (("3" (prop) (("1" (assert) nil) ("2" (assert) nil))))))) ("4" (hide +) (("4" (expand "upToOne") (("4" (lift-if) (("4" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("5" (expand "upToOne") (("5" (lift-if) (("5" (prop) (("1" (assert) nil) ("2" (assert) nil))))))) ("6" (hide +) (("6" (expand "upToOne") (("6" (lift-if) (("6" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("7" (expand "removeSon") (("7" (assert) nil))) ("8" (assert) nil) ("9" (assert) nil) ("10" (assert) nil) ("11" (expand "finseq_appl") (("11" (expand "upToOne") (("11" (expand "finseq_appl") (("11" (lift-if) (("11" (prop) (("1" (lemma "b_search_bound") (("1" (inst?) (("1" (flatten) (("1" (hide -1) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -8 "pos") (("1" (flatten) (("1" (inst -9 "t(k)") (("1" (typepred "pos") (("1" (assert) (("1" (grind) nil))))) ("2" (grind) nil))))))))))))))))))))))))) ("2" (typepred "pos") (("2" (hide -10) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (inst -10 "0") (("2" (flatten) (("2" (inst -11 "pos") (("2" (assert) nil))))))))))))))))))))))))))) ("2" (both-sides "-" "1" -1) (("2" (assert) (("2" (inst -6 "j-1") (("1" (assert) (("1" (flatten) (("1" (expand "removeSon") (("1" (assert) (("1" (split 2) (("1" (flatten) (("1" (hide +) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -7 "pos") (("1" (flatten) (("1" (inst -8 "t(k)") (("1" (typepred "pos") (("1" (assert) nil))))))))))))))))))))))))) ("2" (propax) nil))))))))))) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil))))))))))))))))))))))) ("12" (case "j - 1 > indx`seq(t(k))") (("1" (hide -3) (("1" (inst -6 "j - 1") (("1" (assert) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (skeep) (("1" (inst 1 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) (("1" (grind) nil))))))) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split 1) (("1" (case-replace "i=pos") (("1" (typepred "pos") (("1" (swap-rel -9) (("1" (replaces) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil))))))))))))))))))) ("2" (flatten) (("2" (assert) nil))))) ("2" (propax) nil))))))))))))) ("2" (expand "upToOne") (("2" (propax) nil))))))))) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil))))))))))) ("2" (expand "upToOne") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (grind) nil))) ("2" (assert) nil))))))))) ("3" (expand "upToOne") (("3" (propax) nil))))))))))) ("2" (hide 2) (("2" (flatten) (("2" (lemma "b_search_bound") (("2" (inst?) (("1" (flatten) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil))))))))))))))))) ("2" (assert) nil))))))))) ("3" (hide 2) (("3" (flatten) (("3" (expand "upToOne") (("3" (propax) nil))))))) ("4" (hide 2) (("4" (typepred "pos") (("4" (hide -9) (("4" (expand "is_indx?") (("4" (flatten) (("4" (lemma "is_sorted_equiv[nat, <=]") (("4" (inst?) (("4" (assert) (("4" (inst -1 "0" "pos") (("4" (inst -9 "0") (("4" (flatten) (("4" (inst -10 "pos") (("4" (assert) nil))))))))))))))))))))))))))))))))))))) ("2" (flatten) (("2" (case "j < 1 + indx`seq(t(k - 1))") (("1" (expand "insert?") (("1" (prop) (("1" (expand "finseq_appl") (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9) (("1" (inst -8 "j") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (skeep) (("1" (inst -10 "i") (("1" (prop) (("1" (typepred "i") (("1" (swap-rel -14) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "i") (("1" (inst -11 "i") (("1" (flatten) (("1" (inst -12 "t(k-1)") (("1" (assert) nil))))))))))))))))))))))))))) ("2" (assert) nil))) ("2" (typepred "i") (("2" (assert) (("2" (swap-rel -12) (("2" (replaces) (("2" (case-replace "indx`seq(i) <= indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k)" "i") (("1" (inst -12 "i") (("1" (flatten) (("1" (inst -13 "t(k)") (("1" (assert) nil))))))))))))))))))) ("2" (case "indx`seq(t(k-1)) < indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (grind) nil))))))))))) ("2" (lemma "t_is_increasing") (("2" (inst -1 "k-1" "k") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "t(k)") (("2" (inst -13 "t(k-1)") (("2" (flatten) (("2" (inst -14 "t(k)") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -8 -9) (("2" (inst -8 "pos") (("1" (assert) (("1" (hide-all-but (-8 1)) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -2 "0") (("1" (assert) (("1" (expand "nth") (("1" (propax) nil))))) ("2" (assert) nil))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))) ("3" (assert) (("3" (assert) (("3" (expand "removeSon") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (both-sides "-" "1" -3) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "pos") (("1" (assert) nil) ("2" (typepred "pos") (("2" (assert) nil))))))))))))))))) ("2" (both-sides "-" "1" -2) (("2" (hide -3 -4 -8) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "pos") (("1" (assert) nil) ("2" (typepred "pos") (("2" (assert) nil))))))))))))))))))) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -8) (("3" (inst -7 "j-1") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst -9 "i") (("1" (assert) (("1" (prop) (("1" (swap-rel -9) (("1" (both-sides "-" "1" -2) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (typepred "i") (("1" (assert) (("1" (inst -4 "t(k-1)" "i") (("1" (assert) nil))))))))))))))))))))))))))))) ("2" (typepred "i") (("2" (assert) (("2" (both-sides "-" "1" -4) (("2" (swap-rel -11) (("2" (replaces) (("2" (assert) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "i") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("2" (assert) nil))))))))) ("3" (expand "upToOne") (("3" (propax) nil))))))))))))) ("3" (skeep) (("3" (prop) (("1" (expand "finseq_appl") (("1" (expand "insert?") (("1" (prop) (("1" (assert) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -7 -8) (("1" (inst -8 "i") (("1" (assert) nil) ("2" (typepred "k") (("2" (flatten) (("2" (typepred "t(k - 1)") (("2" (typepred "i") (("2" (grind) nil))))))))))))))))))))) ("2" (assert) (("2" (grind) nil))))))))))))) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (grind) nil))) ("2" (grind) nil))))))))) ("3" (expand "upToOne") (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "is_indx?") (("1" (flatten) (("1" (assert) (("1" (grind) nil))))))) ("2" (hide +) (("2" (expand "is_indx?") (("2" (flatten) (("2" (assert) (("2" (grind) nil))))))))) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (assert) (("3" (grind) nil))))))))))))))))) ("2" (rewrite "<") (("1" (postpone) nil) ("2" (postpone) nil))))))))))))))))) ("2" (expand "finseq_appl") (("2" (expand "insert?") (("2" (prop) (("1" (expand "upToOne") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (assert) (("1" (hide -7 -8) (("1" (inst -7 "i") (("1" (assert) nil) ("2" (typepred "i") (("2" (propax) nil))))))))))))))))) ("2" (expand "removeSon") (("2" (assert) (("2" (grind) nil))))))))))))) ("2" (hide -1) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -5 "0") (("1" (expand "nth") (("1" (propax) nil))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("3" (expand "finseq_appl") (("3" (expand "upToOne") (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6) (("1" (inst -5 "pos") (("1" (assert) (("1" (hide-all-but (-1 -5 1)) (("1" (expand "nstruct?") (("1" (flatten) (("1" (prop) (("1" (hide -4) (("1" (expand "length" -3) (("1" (assert) nil))))) ("2" (skeep) (("2" (inst -4 "i!1+1") (("1" (expand "nth" -) (("1" (propax) nil))) ("2" (hide 2) (("2" (typepred "i!1") (("2" (expand "length") (("2" (assert) nil))))))))))) ("3" (hide -3) (("3" (expand "length" -) (("3" (assert) nil))))))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("2" (replaces) (("2" (hide 2 3 4 5 6 7 8) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (typepred "n") (("1" (hide -6) (("1" (expand "length") (("1" (assert) nil))))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))))) ("3" (expand "is_indx?") (("3" (flatten) (("3" (lemma "is_sorted_equiv[nat, <=]") (("3" (inst?) (("3" (assert) (("3" (inst -1 "pos" "i") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -6 -7) (("3" (assert) (("3" (grind) nil))))))))))))))))))))))))))))) ("2" (typepred "i" "pos") (("2" (expand "upToOne") (("2" (postpone) nil))))))))))))))))))))))))) ("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -4 -5 -6) (("4" (case "is_sorted?(removeSon(s`seqfj, indx`seq(pos)))") (("1" (assert) (("1" (lemma "b_search_preserves_sorting") (("1" (inst -1 "removeSon(s`seqfj, indx`seq(pos))" "car(smallerones(s`seqfj`seq(indx`seq(pos))))" "0" " indx`seq(pos) - 1") (("1" (assert) (("1" (split) (("1" (lemma "b_search_removeSon") (("1" (inst?) (("1" (assert) (("1" (hide -1 2) (("1" (reveal -6) (("1" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (flatten) nil))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))) ("2" (assert) nil))))) ("2" (hide 2) (("2" (expand "removeSon" +) (("2" (reveal -4) (("2" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (assert) nil))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))))) ("2" (hide -1 2) (("2" (expand "removeSon") (("2" (split) (("1" (typepred "pos") (("1" (expand "is_indx?") (("1" (flatten) (("1" (copy -5) (("1" (expand "is_sorted?" -6) (("1" (inst -6 "0") (("1" (assert) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -8 "0") (("1" (flatten) (("1" (inst -9 "1") (("1" (inst -1 "1" "pos") (("1" (assert) nil))))))))))))))))))))))))))))) ("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "pos") (("2" (assert) (("2" (grind) nil))))))))))))))) ("3" (hide 2) (("3" (expand "removeSon") (("3" (assert) nil))))))))))) ("2" (hide 2) (("2" (expand "is_sorted?") (("2" (skeep) (("2" (inst -5 "i") (("1" (expand "removeSon" -1) (("1" (assert) (("1" (expand "removeSon") (("1" (lift-if) (("1" (expand "finseq_appl") (("1" (propax) nil))))))))))) ("2" (hide 2) (("2" (expand "removeSon") (("2" (assert) nil)))))))))))))))))))))))))))))))) nil) nil nil) (insertSonPreservesPartialERforK-2 nil 3797261325 ("" (skeep) (("" (beta) (("" (typepred "indx") (("" (auto-rewrite "finseq_appl") (("" (expand "PartialERforK?" 1) (("" (split) (("1" (expand "finseq_appl") (("1" (skeep) (("1" (name-replace "bsearch" "bin_search(s`seqfj)
                                          (car(smallerones
                                               (s`seqfj`seq(indx`seq(pos)))))
                                          (0, indx`seq(pos) - 1)") (("1" (expand "insert?") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (expand "removeSon") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (hide 2) (("1" (inst -12 "pos") (("1" (assert) nil) ("2" (assert) nil))))) ("2" (assert) nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) nil))))))))))))))))) ("2" (expand "PartialERforK?") (("2" (expand "removeSon") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (lift-if) (("2" (prop) (("1" (inst -10 "pos") (("1" (assert) nil) ("2" (assert) nil))) ("2" (assert) nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst 3 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) (("1" (grind) nil))))))) ("2" (expand "upToOne") (("2" (split) (("1" (flatten) (("1" (typepred "i") (("1" (assert) nil))))) ("2" (typepred "i") (("2" (propax) nil))))))))))))))))))))))))))))))) ("3" (hide -1 1 2) (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (inst -5 "pos") (("1" (expand "finseq_appl") (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -6 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil))))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("4" (hide 1 2) (("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -6 -7) (("4" (inst -6 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -7 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil))))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("5" (expand "PartialERforK?") (("5" (flatten) (("5" (expand "removeSon") (("5" (expand "finseq_appl") (("5" (lift-if) (("5" (prop) (("1" (replaces) (("1" (hide -4 -5) (("1" (inst -4 "pos") (("1" (assert) (("1" (hide -1 -2 -5 2 3 4 5 6) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -3) (("1" (lift-if) (("1" (prop) (("1" (assert) nil) ("2" (assert) nil))))))) ("2" (skeep) (("2" (inst -4 "i+1") (("1" (expand "nth" -) (("1" (propax) nil))) ("2" (typepred "i") (("2" (expand "length" 1) (("2" (assert) nil))))))))) ("3" (expand "length" -) (("3" (lift-if) (("3" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))) ("2" (replaces) (("2" (hide -4 -5 -7) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil))))) ("2" (typepred "pos") (("2" (propax) nil))))))))) ("3" (hide -5 -6 -7) (("3" (inst -4 "j-1") (("1" (split) (("1" (propax) nil) ("2" (assert) nil))) ("2" (assert) nil))))))))))))))))) ("6" (expand "removeSon") (("6" (lift-if) (("6" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6 -8) (("1" (inst - "pos") (("1" (assert) (("1" (hide 2) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -) (("1" (assert) nil))) ("2" (skeep) (("2" (inst -7 "i+1") (("1" (expand "nth" -) (("1" (propax) nil))) ("2" (expand "length") (("2" (assert) nil))))))) ("3" (expand "length" -) (("3" (assert) nil))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("2" (replaces) (("2" (expand "PartialERforK?") (("2" (assert) (("2" (assert) (("2" (flatten) (("2" (hide -4 -5 -7) (("2" (inst - "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))))))) ("3" (expand "finseq_appl") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -7 -6 -5) (("3" (inst -4 "j-1") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (inst 3 "i") (("1" (expand "upToOne") (("1" (assert) (("1" (grind) nil))))) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split) (("1" (assert) nil) ("2" (assert) nil))))))))))))))) ("2" (assert) nil))))))))))))))))))))))))) ("2" (hide 2 3) (("2" (typepred "pos") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (inst -7 "0") (("2" (flatten) (("2" (inst -8 "pos") (("2" (assert) nil))))))))))))))))))))))))))))) ("2" (skeep) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9 -8 -6) (("1" (assert) (("1" (case "j <=
                             bin_search(s`seqfj)(car(smallerones(s`seqfj`seq(indx`seq(pos)))))
                                       (0, indx`seq(pos) - 1) => j <= indx`seq(t(k))") (("1" (expand "insert?") (("1" (lift-if) (("1" (prop) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("2" (hide +) (("2" (expand "upToOne") (("2" (lift-if) (("2" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("3" (expand "upToOne") (("3" (lift-if) (("3" (prop) (("1" (assert) nil) ("2" (assert) nil))))))) ("4" (hide +) (("4" (expand "upToOne") (("4" (lift-if) (("4" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("5" (expand "upToOne") (("5" (lift-if) (("5" (prop) (("1" (assert) nil) ("2" (assert) nil))))))) ("6" (hide +) (("6" (expand "upToOne") (("6" (lift-if) (("6" (prop) (("1" (assert) nil) ("2" (assert) nil))))))))) ("7" (expand "removeSon") (("7" (assert) nil))) ("8" (assert) nil) ("9" (assert) nil) ("10" (assert) nil) ("11" (expand "finseq_appl") (("11" (expand "upToOne") (("11" (expand "finseq_appl") (("11" (lift-if) (("11" (prop) (("1" (lemma "b_search_bound") (("1" (inst?) (("1" (flatten) (("1" (hide -1) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -8 "pos") (("1" (flatten) (("1" (inst -9 "t(k)") (("1" (typepred "pos") (("1" (assert) (("1" (grind) nil))))) ("2" (grind) nil))))))))))))))))))))))))) ("2" (typepred "pos") (("2" (hide -10) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (inst -10 "0") (("2" (flatten) (("2" (inst -11 "pos") (("2" (assert) nil))))))))))))))))))))))))))) ("2" (both-sides "-" "1" -1) (("2" (assert) (("2" (inst -6 "j-1") (("1" (assert) (("1" (flatten) (("1" (expand "removeSon") (("1" (assert) (("1" (split 2) (("1" (flatten) (("1" (hide +) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -7 "pos") (("1" (flatten) (("1" (inst -8 "t(k)") (("1" (typepred "pos") (("1" (assert) nil))))))))))))))))))))))))) ("2" (propax) nil))))))))))) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil))))))))))))))))))))))) ("12" (case "j - 1 > indx`seq(t(k))") (("1" (hide -3) (("1" (inst -6 "j - 1") (("1" (assert) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (skeep) (("1" (inst 1 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) (("1" (grind) nil))))))) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split 1) (("1" (case-replace "i=pos") (("1" (typepred "pos") (("1" (swap-rel -9) (("1" (replaces) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil))))))))))))))))))) ("2" (flatten) (("2" (assert) nil))))) ("2" (propax) nil))))))))))))) ("2" (expand "upToOne") (("2" (propax) nil))))))))) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil))))))))))) ("2" (expand "upToOne") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (grind) nil))) ("2" (assert) nil))))))))) ("3" (expand "upToOne") (("3" (propax) nil))))))))))) ("2" (hide 2) (("2" (flatten) (("2" (lemma "b_search_bound") (("2" (inst?) (("1" (flatten) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil))))))))))))))))) ("2" (assert) nil))))))))) ("3" (hide 2) (("3" (flatten) (("3" (expand "upToOne") (("3" (propax) nil))))))) ("4" (hide 2) (("4" (typepred "pos") (("4" (hide -9) (("4" (expand "is_indx?") (("4" (flatten) (("4" (lemma "is_sorted_equiv[nat, <=]") (("4" (inst?) (("4" (assert) (("4" (inst -1 "0" "pos") (("4" (inst -9 "0") (("4" (flatten) (("4" (inst -10 "pos") (("4" (assert) nil))))))))))))))))))))))))))))))))))))) ("2" (flatten) (("2" (case "j < 1 + indx`seq(t(k - 1))") (("1" (expand "insert?") (("1" (prop) (("1" (expand "finseq_appl") (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9) (("1" (inst -8 "j") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (skeep) (("1" (inst -10 "i") (("1" (prop) (("1" (typepred "i") (("1" (swap-rel -14) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "i") (("1" (inst -11 "i") (("1" (flatten) (("1" (inst -12 "t(k-1)") (("1" (assert) nil))))))))))))))))))))))))))) ("2" (assert) nil))) ("2" (typepred "i") (("2" (assert) (("2" (swap-rel -12) (("2" (replaces) (("2" (case-replace "indx`seq(i) <= indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k)" "i") (("1" (inst -12 "i") (("1" (flatten) (("1" (inst -13 "t(k)") (("1" (assert) nil))))))))))))))))))) ("2" (case "indx`seq(t(k-1)) < indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (grind) nil))))))))))) ("2" (lemma "t_is_increasing") (("2" (inst -1 "k-1" "k") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "t(k)") (("2" (inst -13 "t(k-1)") (("2" (flatten) (("2" (inst -14 "t(k)") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -8 -9) (("2" (inst -8 "pos") (("1" (assert) (("1" (hide-all-but (-8 1)) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -2 "0") (("1" (assert) (("1" (expand "nth") (("1" (propax) nil))))) ("2" (assert) nil))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))) ("3" (assert) (("3" (assert) (("3" (expand "removeSon") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (both-sides "-" "1" -3) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "pos") (("1" (assert) nil) ("2" (typepred "pos") (("2" (assert) nil))))))))))))))))) ("2" (both-sides "-" "1" -2) (("2" (hide -3 -4 -8) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "pos") (("1" (assert) nil) ("2" (typepred "pos") (("2" (assert) nil))))))))))))))))))) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -8) (("3" (inst -7 "j-1") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst -9 "i") (("1" (assert) (("1" (prop) (("1" (swap-rel -9) (("1" (both-sides "-" "1" -2) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (typepred "i") (("1" (assert) (("1" (inst -4 "t(k-1)" "i") (("1" (assert) nil))))))))))))))))))))))))))))) ("2" (typepred "i") (("2" (assert) (("2" (both-sides "-" "1" -4) (("2" (swap-rel -11) (("2" (replaces) (("2" (assert) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "i") (("2" (assert) nil))))))))))))))))))))))))))))))))))))))))))))))))))))))))) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("2" (assert) nil))))))))) ("3" (expand "upToOne") (("3" (propax) nil))))))))))))) ("3" (skeep) (("3" (prop) (("1" (expand "finseq_appl") (("1" (expand "insert?") (("1" (prop) (("1" (assert) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -7 -8) (("1" (inst -8 "i") (("1" (assert) nil) ("2" (typepred "k") (("2" (flatten) (("2" (typepred "t(k - 1)") (("2" (typepred "i") (("2" (grind) nil))))))))))))))))))))) ("2" (assert) (("2" (grind) nil))))))))))))) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (grind) nil))) ("2" (grind) nil))))))))) ("3" (expand "upToOne") (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "is_indx?") (("1" (flatten) (("1" (assert) (("1" (grind) nil))))))) ("2" (hide +) (("2" (expand "is_indx?") (("2" (flatten) (("2" (assert) (("2" (grind) nil))))))))) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (assert) (("3" (grind) nil))))))))))))))))) ("2" (rewrite "<") (("1" (postpone) nil) ("2" (postpone) nil))))))))))))))))) ("2" (expand "finseq_appl") (("2" (expand "insert?") (("2" (prop) (("1" (expand "upToOne") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (assert) (("1" (hide -7 -8) (("1" (inst -7 "i") (("1" (assert) nil) ("2" (typepred "i") (("2" (propax) nil))))))))))))))))) ("2" (expand "removeSon") (("2" (assert) (("2" (grind) nil))))))))))))) ("2" (hide -1) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -5 "0") (("1" (expand "nth") (("1" (propax) nil))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("3" (expand "finseq_appl") (("3" (expand "upToOne") (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6) (("1" (inst -5 "pos") (("1" (assert) (("1" (hide-all-but (-1 -5 1)) (("1" (expand "nstruct?") (("1" (flatten) (("1" (prop) (("1" (hide -4) (("1" (expand "length" -3) (("1" (assert) nil))))) ("2" (skeep) (("2" (inst -4 "i!1+1") (("1" (expand "nth" -) (("1" (propax) nil))) ("2" (hide 2) (("2" (typepred "i!1") (("2" (expand "length") (("2" (assert) nil))))))))))) ("3" (hide -3) (("3" (expand "length" -) (("3" (assert) nil))))))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))) ("2" (replaces) (("2" (hide 2 3 4 5 6 7 8) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (typepred "n") (("1" (hide -6) (("1" (expand "length") (("1" (assert) nil))))))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))))) ("3" (expand "is_indx?") (("3" (flatten) (("3" (lemma "is_sorted_equiv[nat, <=]") (("3" (inst?) (("3" (assert) (("3" (inst -1 "pos" "i") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -6 -7) (("3" (assert) (("3" (grind) nil))))))))))))))))))))))))))))) ("2" (typepred "i" "pos") (("2" (expand "upToOne") (("2" (postpone) nil))))))))))))))))))))))))) ("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -4 -5 -6) (("4" (case "is_sorted?(removeSon(s`seqfj, indx`seq(pos)))") (("1" (assert) (("1" (lemma "b_search_preserves_sorting") (("1" (inst -1 "removeSon(s`seqfj, indx`seq(pos))" "car(smallerones(s`seqfj`seq(indx`seq(pos))))" "0" " indx`seq(pos) - 1") (("1" (assert) (("1" (split) (("1" (lemma "b_search_removeSon") (("1" (inst?) (("1" (assert) (("1" (hide -1 2) (("1" (reveal -6) (("1" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (flatten) nil))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))) ("2" (assert) nil))))) ("2" (hide 2) (("2" (expand "removeSon" +) (("2" (reveal -4) (("2" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (assert) nil))) ("2" (assert) nil))))))))) ("2" (typepred "pos") (("2" (propax) nil))))))))))))))) ("2" (hide -1 2) (("2" (expand "removeSon") (("2" (split) (("1" (typepred "pos") (("1" (expand "is_indx?") (("1" (flatten) (("1" (copy -5) (("1" (expand "is_sorted?" -6) (("1" (inst -6 "0") (("1" (assert) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst?) (("1" (assert) (("1" (inst -8 "0") (("1" (flatten) (("1" (inst -9 "1") (("1" (inst -1 "1" "pos") (("1" (assert) nil))))))))))))))))))))))))))))) ("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "pos") (("2" (assert) (("2" (grind) nil))))))))))))))) ("3" (hide 2) (("3" (expand "removeSon") (("3" (assert) nil))))))))))) ("2" (hide 2) (("2" (expand "is_sorted?") (("2" (skeep) (("2" (inst -5 "i") (("1" (expand "removeSon" -1) (("1" (assert) (("1" (expand "removeSon") (("1" (lift-if) (("1" (expand "finseq_appl") (("1" (propax) nil))))))))))) ("2" (hide 2) (("2" (expand "removeSon") (("2" (assert) nil)))))))))))))))))))))))))))))))) nil) nil nil) (insertSonPreservesPartialERforK-1 nil 3777234307 ("" (skeep) (("" (beta) (("" (typepred "indx") (("" (auto-rewrite "finseq_appl") (("" (expand "PartialERforK?" 1) (("" (split) (("1" (expand "finseq_appl") (("1" (skeep) (("1" (name-replace "bsearch" "bin_search(s`seqfj)
                                  (car(smallerones
                                       (s`seqfj`seq(indx`seq(pos)))))
                                  (0, indx`seq(pos) - 1)") (("1" (expand "insert?") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (expand "removeSon") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (hide 2) (("1" (inst -12 "pos") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "PartialERforK?") (("2" (expand "removeSon") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (lift-if) (("2" (prop) (("1" (inst -10 "pos") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (hide -7 -8 -9) (("3" (inst -6 "j") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst 3 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "upToOne") (("2" (split) (("1" (flatten) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 1 2) (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (inst -5 "pos") (("1" (expand "finseq_appl") (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -6 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 1 2) (("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -6 -7) (("4" (inst -6 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -7 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (expand "PartialERforK?") (("5" (flatten) (("5" (expand "removeSon") (("5" (expand "finseq_appl") (("5" (lift-if) (("5" (prop) (("1" (replaces) (("1" (hide -4 -5) (("1" (inst -4 "pos") (("1" (assert) (("1" (hide -1 -2 -5 2 3 4 5 6) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -3) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "i+1") (("1" (expand "nth" -) (("1" (propax) nil nil)) nil) ("2" (typepred "i") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "length" -) (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (hide -4 -5 -7) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide -5 -6 -7) (("3" (inst -4 "j-1") (("1" (split) (("1" (propax) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "removeSon") (("6" (lift-if) (("6" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6 -8) (("1" (inst - "pos") (("1" (assert) (("1" (hide 2) (("1" (expand "nstruct?") (("1" (prop) (("1" (expand "length" -) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (inst -7 "i+1") (("1" (expand "nth" -) (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "length" -) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (expand "PartialERforK?") (("2" (assert) (("2" (assert) (("2" (flatten) (("2" (hide -4 -5 -7) (("2" (inst - "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (propax) nil nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -7 -6 -5) (("3" (inst -4 "j-1") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (inst 3 "i") (("1" (expand "upToOne") (("1" (assert) nil nil)) nil) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (typepred "pos") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "0" "pos") (("2" (inst -7 "0") (("2" (flatten) (("2" (inst -8 "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9 -8 -6) (("1" (assert) (("1" (case "j <=
       bin_search(s`seqfj)(car(smallerones(s`seqfj`seq(indx`seq(pos)))))
                 (0, indx`seq(pos) - 1) => j <= indx`seq(t(k))") (("1" (expand "insert?") (("1" (lift-if) (("1" (prop) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide +) (("2" (expand "upToOne") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("4" (hide +) (("4" (expand "upToOne") (("4" (lift-if) (("4" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (expand "upToOne") (("5" (lift-if) (("5" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("6" (hide +) (("6" (expand "upToOne") (("6" (lift-if) (("6" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("7" (expand "removeSon") (("7" (assert) nil nil)) nil) ("8" (assert) nil nil) ("9" (assert) nil nil) ("10" (assert) nil nil) ("11" (expand "finseq_appl") (("11" (expand "upToOne") (("11" (expand "finseq_appl") (("11" (lift-if) (("11" (prop) (("1" (lemma "b_search_bound") (("1" (inst?) (("1" (flatten) (("1" (hide -1) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -8 "pos") (("1" (flatten) (("1" (inst -9 "t(k)") (("1" (typepred "pos") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (both-sides "-" "1" -1) (("2" (assert) (("2" (inst -6 "j-1") (("1" (assert) (("1" (flatten) (("1" (expand "removeSon") (("1" (assert) (("1" (split 2) (("1" (flatten) (("1" (hide +) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (inst -7 "pos") (("1" (flatten) (("1" (inst -8 "t(k)") (("1" (typepred "pos") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("12" (case "j - 1 > indx`seq(t(k))") (("1" (hide -3) (("1" (inst -6 "j - 1") (("1" (assert) (("1" (flatten) (("1" (split) (("1" (flatten) (("1" (skeep) (("1" (inst 1 "i") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (split 1) (("1" (case-replace "i=pos") (("1" (typepred "pos") (("1" (swap-rel -9) (("1" (replaces) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) nil nil)) nil)) nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (flatten) (("2" (lemma "b_search_bound") (("2" (inst?) (("1" (flatten) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "pos" "t(k)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (flatten) (("3" (expand "upToOne") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (typepred "pos") (("4" (hide -9) (("4" (expand "is_indx?") (("4" (flatten) (("4" (lemma "is_sorted_equiv") (("4" (inst?) (("4" (assert) (("4" (inst -1 "0" "pos") (("4" (inst -9 "0") (("4" (flatten) (("4" (inst -10 "pos") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (case "j < 1 + indx`seq(t(k - 1))") (("1" (expand "insert?") (("1" (prop) (("1" (expand "finseq_appl") (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -9) (("1" (inst -8 "j") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (skeep) (("1" (inst -10 "i") (("1" (prop) (("1" (typepred "i") (("1" (swap-rel -14) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "i") (("1" (inst -11 "i") (("1" (flatten) (("1" (inst -12 "t(k-1)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (assert) (("2" (swap-rel -12) (("2" (replaces) (("2" (case-replace "indx`seq(i) <= indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k)" "i") (("1" (inst -12 "i") (("1" (flatten) (("1" (inst -13 "t(k)") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "indx`seq(t(k-1)) < indx`seq(t(k))") (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "k-1" "k") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv") (("2" (assert) (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "t(k)") (("2" (inst -13 "t(k-1)") (("2" (flatten) (("2" (inst -14 "t(k)") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -8 -9) (("2" (inst -8 "pos") (("1" (assert) (("1" (hide-all-but (-8 1)) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -2 "0") (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) (("3" (assert) (("3" (expand "removeSon") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (both-sides "-" "1" -3) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "t(k-1)" "pos") (("1" (assert) nil nil) ("2" (typepred "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (both-sides "-" "1" -2) (("2" (hide -3 -4 -8) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "pos") (("1" (assert) nil nil) ("2" (typepred "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -8) (("3" (inst -7 "j-1") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (inst -9 "i") (("1" (assert) (("1" (prop) (("1" (swap-rel -9) (("1" (both-sides "-" "1" -2) (("1" (replaces) (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (typepred "i") (("1" (assert) (("1" (inst -4 "t(k-1)" "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (assert) (("2" (both-sides "-" "1" -4) (("2" (swap-rel -11) (("2" (replaces) (("2" (assert) (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv") (("2" (inst?) (("2" (assert) (("2" (inst -1 "t(k-1)" "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (prop) (("1" (expand "finseq_appl") (("1" (expand "insert?") (("1" (prop) (("1" (assert) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -7 -8) (("1" (inst -7 "i") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("3" (expand "removeSon") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -6 "i") (("1" (assert) (("1" (flatten) (("1" (inst -7 "pos") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide +) (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -5 "i") (("2" (flatten) (("2" (inst -6 "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -5 -6) (("3" (inst -5 "i") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "insert?") (("2" (prop) (("1" (expand "upToOne") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (inst -6 "indx`seq(i)") (("1" (assert) (("1" (hide -7 -8) (("1" (flatten) (("1" (skeep) (("1" (typepred "i_1") (("1" (case-replace "i_1 = i") (("1" (assert) nil nil) ("2" (hide-all-but (-7 -10 1)) (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -2 "i_1") (("2" (flatten) (("2" (inst -3 "i") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -5 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "finseq_appl") (("3" (expand "upToOne") (("3" (expand "finseq_appl") (("3" (lift-if) (("3" (prop) (("3" (expand "removeSon") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -6) (("1" (inst -5 "pos") (("1" (assert) (("1" (hide-all-but (-1 -5 1)) (("1" (expand "nstruct?") (("1" (flatten) (("1" (prop) (("1" (hide -4) (("1" (expand "length" -3) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (inst -4 "i!1+1") (("1" (expand "nth" -) (("1" (propax) nil nil)) nil) ("2" (hide 2) (("2" (typepred "i!1") (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -3) (("3" (expand "length" -) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (hide 2 3 4 5 6 7 8) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -4 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (typepred "n") (("1" (hide -6) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "is_indx?") (("3" (flatten) (("3" (lemma "is_sorted_equiv") (("3" (inst?) (("3" (assert) (("3" (inst -1 "pos" "i") (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -6 -7) (("3" (inst -6 "i") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -4 -5 -6) (("4" (case "is_sorted?(removeSon(s`seqfj, indx`seq(pos)))") (("1" (assert) (("1" (lemma "b_search_preserves_sorting") (("1" (inst -1 "removeSon(s`seqfj, indx`seq(pos))" "car(smallerones(s`seqfj`seq(indx`seq(pos))))" "0" " indx`seq(pos) - 1") (("1" (assert) (("1" (split) (("1" (lemma "b_search_removeSon") (("1" (inst?) (("1" (assert) (("1" (hide -1 2) (("1" (reveal -6) (("1" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (flatten) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (expand "removeSon" +) (("2" (reveal -4) (("2" (inst -1 "pos") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "removeSon") (("2" (split) (("1" (typepred "pos") (("1" (expand "is_indx?") (("1" (flatten) (("1" (copy -5) (("1" (expand "is_sorted?" -6) (("1" (inst -6 "0") (("1" (assert) (("1" (lemma "is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -8 "0") (("1" (flatten) (("1" (inst -9 "1") (("1" (inst -1 "1" "pos") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "removeSon") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "is_sorted?") (("2" (skeep) (("2" (inst -5 "i") (("1" (expand "removeSon" -1) (("1" (assert) (("1" (expand "removeSon") (("1" (lift-if) (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((/= const-decl "boolean" notequal nil) (finite_sequence type-eq-decl nil finite_sequences nil) (insert? const-decl "finseq" seq_extras structures) (TRUE const-decl "bool" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (length def-decl "nat" list_props nil) (nth def-decl "T" list_props nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (both_sides_minus_lt1 formula-decl nil real_props nil) (t_is_increasing formula-decl nil ford_johnson nil) (odd? const-decl "bool" integers nil) (both_sides_minus_gt1 formula-decl nil real_props nil) (b_search_bound formula-decl nil ford_johnson nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (b_search_preserves_sorting formula-decl nil ford_johnson nil) (b_search_removeSon formula-decl nil ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (fjnode type-decl nil fjnode_adt nil) (PRED type-eq-decl nil defined_types nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (< const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (<= const-decl "bool" reals nil) (PartialERforK? const-decl "bool" ford_johnson nil)) shostak)) (insertCarPreservesPartialERforK_TCC1 0 (insertCarPreservesPartialERforK_TCC1-1 nil 3764062305 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (is_sorted? const-decl "bool" sorting_seq nil) (is_indx? const-decl "bool" ford_johnson nil)) nil (insertCarPreservesPartialERforK subtype "ford_johnson.indx" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), ford_johnson.is_indx?(ford_johnson.s`seqfj, indx))}"))) (insertCarPreservesPartialERforK_TCC2 0 (insertCarPreservesPartialERforK_TCC2-1 nil 3764062305 ("" (skeep) (("" (expand "min") (("" (lift-if) (("" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil) ("7" (lemma "t_is_increasing") (("7" (inst -1 "maxk(indx`length) - 1" "maxk(indx`length)") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("8" (assert) nil nil)) nil)) nil)) nil)) nil) ((min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (indx skolem-const-decl "finseq[nat]" ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posnat nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (>= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (t_is_increasing formula-decl nil ford_johnson nil)) nil (insertCarPreservesPartialERforK subtype "real_defs.min(ford_johnson.t(ford_johnson.maxk(ford_johnson.indx`length)), (number_fields.-)(ford_johnson.indx`length, 1))" "{pos: nat_types[length(ford_johnson.indx)].below | booleans.AND((booleans.OR(ford_johnson.maxk(ford_johnson.indx`length) = 1, reals.<=(ford_johnson.t((number_fields.-)(ford_johnson.maxk(ford_johnson.indx`length), 1)), pos))), reals.<=(pos, ford_johnson.t(ford_johnson.maxk(ford_johnson.indx`length))))}"))) (insertCarPreservesPartialERforK_TCC3 0 (insertCarPreservesPartialERforK_TCC3-1 nil 3764062305 ("" (subtype-tcc) nil nil) nil nil (insertCarPreservesPartialERforK subtype "0" "below[length(s`seqfj)]"))) (insertCarPreservesPartialERforK_TCC4 0 (insertCarPreservesPartialERforK_TCC4-1 nil 3764062305 ("" (subtype-tcc) nil nil) nil nil (insertCarPreservesPartialERforK subtype "(number_fields.-)(length(ford_johnson.s`seqfj), 1)" "{j: nat_types[length(ford_johnson.s`seqfj)].below | reals.<=(0, j)}"))) (insertCarPreservesPartialERforK_TCC5 0 (insertCarPreservesPartialERforK_TCC5-1 nil 3764062305 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (is_indx? const-decl "bool" ford_johnson nil) (< const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (PartialERforK? const-decl "bool" ford_johnson nil) (above nonempty-type-eq-decl nil integers nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (rat_exp application-judgement "rat" exponentiation nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (/= const-decl "boolean" notequal nil) (is_sorted? const-decl "bool" sorting_seq nil) (restrict const-decl "R" restrict nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (insertCarPreservesPartialERforK subtype "ford_johnson.s`oddList" "(list_adt[fjnode_adt[ford_johnson.T].fjnode].cons?)"))) (insertCarPreservesPartialERforK_TCC6 0 (insertCarPreservesPartialERforK_TCC6-1 nil 3764062305 ("" (subtype-tcc) nil nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (insert? const-decl "finseq" seq_extras structures)) nil (insertCarPreservesPartialERforK subtype "ford_johnson.indx`length" "posnat"))) (insertCarPreservesPartialERforK_TCC7 0 (insertCarPreservesPartialERforK_TCC7-1 nil 3764062305 ("" (skeep) (("" (skeep) (("" (skeep) (("" (replaces) (("" (expand "insert?") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (insert? const-decl "finseq" seq_extras structures)) nil (insertCarPreservesPartialERforK subtype "ford_johnson.sk" "{s: firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].finseqfj | reals.>(length(s`seqfj), 0)}"))) (insertCarPreservesPartialERforK_TCC8 0 (insertCarPreservesPartialERforK_TCC8-1 nil 3767433234 ("" (skeep) (("" (skeep) (("" (skeep) (("" (split) (("1" (expand "upToOne") (("1" (assert) nil nil)) nil) ("2" (lemma "upToOnePreservesIndx") (("2" (inst -1 "s`seqfj" "indx" "car(s`oddList)" "bsearch") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (finseq type-eq-decl nil finite_sequences nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (is_indx? const-decl "bool" ford_johnson nil) (posnat nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (PartialERforK? const-decl "bool" ford_johnson nil) (above nonempty-type-eq-decl nil integers nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (upto nonempty-type-eq-decl nil nat_types nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil) (upToOnePreservesIndx formula-decl nil ford_johnson nil)) nil (insertCarPreservesPartialERforK subtype "ford_johnson.upToOne(ford_johnson.indx, ford_johnson.bsearch)" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), ford_johnson.is_indx?(ford_johnson.sk`seqfj, indx))}"))) (insertCarPreservesPartialERforK_TCC9 0 (insertCarPreservesPartialERforK_TCC9-1 nil 3772298290 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (skeep) (("" (expand "upToOne") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((upToOne const-decl "finseq[nat]" ford_johnson nil)) nil (insertCarPreservesPartialERforK subtype "(number_fields.-)(length(ford_johnson.indx), 1)" "{pos: nat_types[length(ford_johnson.upToOne(ford_johnson.indx, ford_johnson.bsearch))].below | booleans.AND((booleans.OR(ford_johnson.k = 1, reals.<=(ford_johnson.t((number_fields.-)(ford_johnson.k, 1)), pos))), reals.<=(pos, ford_johnson.t(ford_johnson.k)))}"))) (insertCarPreservesPartialERforK 0 (insertCarPreservesPartialERforK-1 nil 3767431837 ("" (skeep) (("" (beta) (("" (flatten) (("" (auto-rewrite "finseq_appl") (("" (name-replace "b" "bin_search
                                       (s`seqfj)
                                       (car(s`oddList))
                                       (0, length(s`seqfj) - 1)") (("" (name-replace "c" "car(s`oddList)") (("" (expand "PartialERforK?" 1) (("" (assert) (("" (prop) (("1" (typepred "indx") (("1" (hide -1 -2) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -2 -3 -4) (("1" (skeep) (("1" (expand "insert?" 2) (("1" (expand "insert?") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (inst -3 "j") (("1" (assert) nil nil)) nil) ("2" (inst -3 "j") (("2" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (expand "upToOne") (("2" (expand "finseq_appl") (("2" (skeep) (("2" (inst 1 "i") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (expand "upToOne") (("2" (flatten) (("2" (typepred "i") (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -1 "j-1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("4" (inst -1 "j-1") (("1" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (skeep) (("2" (inst 1 "i") (("1" (expand "upToOne") (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "upToOne") (("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (split) (("1" (flatten) (("1" (hide-all-but (-1)) (("1" (typepred "maxk(indx`length)") (("1" (expand "upToOne") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "upToOne") (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (typepred "indx") (("1" (hide -1 -2) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -1 -3) (("1" (inst -1 "j") (("1" (assert) (("1" (expand "insert?") (("1" (expand "finseq_appl") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "indx") (("2" (hide -1 -2) (("2" (expand "min") (("2" (expand "insert?") (("2" (prop) (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (inst -3 "j") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "PartialERforK?") (("2" (flatten) (("2" (inst -2 "j-1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (prop) (("1" (expand "upToOne") (("1" (prop) (("1" (expand "insert?") (("1" (assert) (("1" (typepred "indx") (("1" (hide -1 -2) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -1 -2 -4) (("1" (inst -1 "i") (("1" (prop) (("1" (assert) nil nil) ("2" (expand "min") (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (expand "finseq_appl") (("4" (typepred "i") (("4" (grind) nil nil)) nil)) nil) ("5" (grind) nil nil) ("6" (grind) nil nil)) nil) ("2" (flatten) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "insert?") (("2" (assert) (("2" (typepred "indx") (("2" (hide -1 -2) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -1 -2 -4) (("2" (inst -1 "i") (("1" (prop) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (expand "min") (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("3" (grind) nil nil) ("4" (grind) nil nil) ("5" (grind) nil nil) ("6" (typepred "i") (("6" (grind) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (lemma "b_search_preserves_sorting") (("4" (expand "b") (("4" (inst?) (("4" (split) (("1" (expand "c") (("1" (propax) nil nil)) nil) ("2" (typepred "indx") (("2" (expand "PartialERforK?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (b_search_preserves_sorting formula-decl nil ford_johnson nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (i skolem-const-decl "{i: below[length(upToOne(indx, b))] |
   (maxk(indx`length) = 1 OR t(maxk(indx`length) - 1) < i) AND
    i <= t(maxk(indx`length))}" ford_johnson nil) (j skolem-const-decl "below[length(insert?(c, s`seqfj, b))]" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (above nonempty-type-eq-decl nil integers nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (posnat nonempty-type-eq-decl nil integers nil) (is_indx? const-decl "bool" ford_johnson nil) (NOT const-decl "[bool -> bool]" booleans nil) (insert? const-decl "finseq" seq_extras structures) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (b skolem-const-decl "upto[length(s`seqfj)]" ford_johnson nil) (i skolem-const-decl "{i: below[length(indx)] |
   (i <= min(t(maxk(indx`length)), indx`length - 1) OR
     i > t(maxk(indx`length)))
    AND (i > t(maxk(indx`length) - 1) OR maxk(indx`length) = 1)}" ford_johnson nil) (indx skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    is_indx?(s`seqfj, indx) AND
     PartialERforK?(s, indx, maxk(indx`length),
                    min(t(maxk(indx`length)), indx`length - 1), n)}" ford_johnson nil) (n skolem-const-decl "posnat" ford_johnson nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0 AND length(s`oddList) > 0}" ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (j skolem-const-decl "below[length(insert?(c, s`seqfj, b))]" ford_johnson nil) (c skolem-const-decl "fjnode[T]" ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (i skolem-const-decl "{i: below[length(indx)] |
   (i <= min(t(maxk(indx`length)), indx`length - 1) OR
     i > t(maxk(indx`length)))
    AND (i > t(maxk(indx`length) - 1) OR maxk(indx`length) = 1)}" ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (finseq type-eq-decl nil finite_sequences nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (binsert_tk_interval_TCC1 0 (binsert_tk_interval_TCC1-1 nil 3730784519 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (is_sorted? const-decl "bool" sorting_seq nil) (is_indx? const-decl "bool" ford_johnson nil)) shostak (binsert_tk_interval subtype "ford_johnson.indx" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), ford_johnson.is_indx?(ford_johnson.s`seqfj, indx))}"))) (binsert_tk_interval_TCC2 0 (binsert_tk_interval_TCC2-1 nil 3730784519 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (assert) (("" (typepred "pos") (("" (propax) nil nil)) nil)) nil)) nil)) nil) ((AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak (binsert_tk_interval subtype "ford_johnson.pos" "{pos: nat_types[length(ford_johnson.indx)].below | booleans.AND((booleans.OR(ford_johnson.k = 1, reals.<=(ford_johnson.t((number_fields.-)(ford_johnson.k, 1)), pos))), reals.<=(pos, ford_johnson.t(ford_johnson.k)))}"))) (binsert_tk_interval_TCC3 0 (binsert_tk_interval_TCC3-1 nil 3730784519 ("" (skeep) (("" (assert) nil nil)) nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil)) shostak (binsert_tk_interval subtype "0" "below[length(indx)]"))) (binsert_tk_interval_TCC4 0 (binsert_tk_interval_TCC4-1 nil 3730784519 ("" (skeep) (("" (typepred "indx") (("" (expand "finseq_appl") (("" (hide-all-but (-2 1)) (("" (expand "is_indx?") (("" (flatten) (("" (inst?) (("" (expand "finseq_appl") (("" (assert) (("" (skeep) (("" (expand "removeSon") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PartialERforK? const-decl "bool" ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) shostak (binsert_tk_interval subtype "0" "upto[length(removeSon(s`seqfj, finseq_appl[nat](indx)(0)))]"))) (binsert_tk_interval_TCC5 0 (binsert_tk_interval_TCC5-1 nil 3730784519 ("" (skeep) (("" (expand "finseq_appl") (("" (typepred "indx") (("" (typepred "n") (("" (expand "PartialERforK?") (("" (flatten) (("" (expand "finseq_appl") (("" (hide -5 -6) (("" (inst -5 "0") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (expand "length" -5) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((PartialERforK? const-decl "bool" ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (k skolem-const-decl "posnat" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (binsert_tk_interval subtype "0" "below[length(indx)]"))) (binsert_tk_interval_TCC6 0 (binsert_tk_interval_TCC6-1 nil 3730784519 ("" (skeep* :preds? t) (("" (expand "finseq_appl") (("" (expand "is_indx?") (("" (flatten) (("" (inst -8 0) (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (is_sorted? const-decl "bool" sorting_seq nil) (restrict const-decl "R" restrict nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (PartialERforK? const-decl "bool" ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (is_indx? const-decl "bool" ford_johnson nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) shostak (binsert_tk_interval subtype "finite_sequences[nat].finseq_appl(ford_johnson.indx)(0)" "below[s`seqfj`length]"))) (binsert_tk_interval_TCC7 0 (binsert_tk_interval_TCC7-1 nil 3730784519 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (typepred "indx") (("" (typepred "n") (("" (hide -2 -3 -4) (("" (expand "PartialERforK?") (("" (flatten) (("" (hide -2 -3) (("" (inst -2 "0") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (int_plus_int_is_int application-judgement "int" integers nil) (k skolem-const-decl "posnat" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (< const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (PartialERforK? const-decl "bool" ford_johnson nil)) shostak (binsert_tk_interval subtype "fjnode_adt[ford_johnson.T].smallerones(ford_johnson.s`seqfj`seq(finite_sequences[nat].finseq_appl(ford_johnson.indx)(0)))" "(list_adt[fjnode_adt[ford_johnson.T].fjnode].cons?)"))) (binsert_tk_interval_TCC8 0 (binsert_tk_interval_TCC8-1 nil 3730784519 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (skeep) (("" (skeep) (("" (assert) (("" (lemma "b_search_bound") (("" (inst?) (("1" (assert) (("1" (hide-all-but (-1 4)) (("1" (typepred "indx") (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -3 "pos") (("1" (flatten) (("1" (expand "removeSon") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "pos=0") (("1" (assert) nil nil) ("2" (typepred "indx") (("2" (hide -1 -3 -4 -5 -6 -7 3 4 5 6) (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -2 "pos") (("2" (flatten) (("2" (inst -3 "0") (("1" (lemma "is_sorted_equiv") (("1" (inst -1 "indx") (("1" (assert) (("1" (inst -1 "0" "pos") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (binsert_tk_interval subtype "ford_johnson.indx`length" "posnat"))) (binsert_tk_interval_TCC9 0 (binsert_tk_interval_TCC9-1 nil 3735562407 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (skeep) (("" (skeep) (("" (expand "insert?") (("" (expand "removeSon") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (binsert_tk_interval subtype "0" "below[length(s`seqfj)]"))) (binsert_tk_interval_TCC10 0 (binsert_tk_interval_TCC10-1 nil 3762843526 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (skeep) (("" (skeep) (("" (typepred "pos") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (binsert_tk_interval subtype "ford_johnson.pos" "below[length(indx)]"))) (binsert_tk_interval_TCC11 0 (binsert_tk_interval_TCC11-3 nil 3797760945 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (skeep) (("" (assert) (("" (typepred "indx") (("" (hide -1 -4 -6) (("" (expand "is_indx?") (("" (flatten) (("" (inst -2 "pos") (("" (flatten) (("" (inst -3 "0") (("1" (assert) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst -1 "indx") (("1" (assert) (("1" (inst -1 "0" "pos") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (finite_sequence type-eq-decl nil finite_sequences nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (restrict const-decl "R" restrict nil) (is_sorted_equiv formula-decl nil sorting_seq nil) (pos skolem-const-decl "{pos: nat | (k = 1 OR t(k - 1) <= pos) AND pos <= t(k)}" ford_johnson nil) (k skolem-const-decl "posnat" ford_johnson nil) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (< const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (PartialERforK? const-decl "bool" ford_johnson nil)) nil (binsert_tk_interval subtype "(number_fields.-)(finite_sequences[nat].finseq_appl(ford_johnson.indx)(ford_johnson.pos), 1)" "{j: nat_types[length(ford_johnson.s`seqfj)].below | reals.<=(0, j)}")) (binsert_tk_interval_TCC11-2 nil 3797586910 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (skeep) (("" (assert) (("" (typepred "indx") (("" (hide -1 -4 -6) (("" (expand "is_indx?") (("" (flatten) (("" (inst -2 "pos") (("" (flatten) (("" (inst -3 "0") (("1" (assert) (("1" (lemma "is_sorted_equiv[nat, <=, <, >]") (("1" (inst -1 "indx") (("1" (assert) (("1" (inst -1 "0" "pos") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (finite_sequence type-eq-decl nil finite_sequences nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (restrict const-decl "R" restrict nil) (is_sorted_equiv formula-decl nil sorting_seq nil) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (pred type-eq-decl nil defined_types nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (< const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (PartialERforK? const-decl "bool" ford_johnson nil)) nil (binsert_tk_interval subtype "(number_fields.-)(finite_sequences[nat].finseq_appl(ford_johnson.indx)(ford_johnson.pos), 1)" "{j: nat_types[length(ford_johnson.s`seqfj)].below | reals.<=(0, j)}")) (binsert_tk_interval_TCC11-1 nil 3762854295 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (skeep) (("" (assert) (("" (typepred "indx") (("" (hide -1 -4 -6) (("" (expand "is_indx?") (("" (flatten) (("" (inst -2 "pos") (("" (flatten) (("" (inst -3 "0") (("1" (assert) (("1" (lemma "is_sorted_equiv") (("1" (inst -1 "indx") (("1" (assert) (("1" (inst -1 "0" "pos") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (finite_sequence type-eq-decl nil finite_sequences nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (is_sorted? const-decl "bool" sorting_seq nil) (restrict const-decl "R" restrict nil) (is_sorted_equiv formula-decl nil sorting_seq nil) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (< const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (PartialERforK? const-decl "bool" ford_johnson nil)) nil (binsert_tk_interval subtype "(number_fields.-)(finite_sequences[nat].finseq_appl(ford_johnson.indx)(ford_johnson.pos), 1)" "{j: nat_types[length(ford_johnson.s`seqfj)].below | reals.<=(0, j)}"))) (binsert_tk_interval_TCC12 0 (binsert_tk_interval_TCC12-1 nil 3762854295 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (is_indx? const-decl "bool" ford_johnson nil) (< const-decl "bool" reals nil) (PartialERforK? const-decl "bool" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_exp application-judgement "int" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (rat_exp application-judgement "rat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (restrict const-decl "R" restrict nil) (is_sorted? const-decl "bool" sorting_seq nil) (/= const-decl "boolean" notequal nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (upto nonempty-type-eq-decl nil nat_types nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)) nil (binsert_tk_interval subtype "ford_johnson.searchIndx" "upto[length(removeSon(s`seqfj, finseq_appl[nat](indx)(pos)))]"))) (binsert_tk_interval_TCC13 0 (binsert_tk_interval_TCC13-1 nil 3762854295 ("" (subtype-tcc) nil nil) ((^ const-decl "real" exponentiation nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (insert? const-decl "finseq" seq_extras structures) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil)) nil (binsert_tk_interval subtype "(# seqfj := seq_extras[fjnode_adt[ford_johnson.T].fjnode].insert?(ford_johnson.b, ford_johnson.removeSon(ford_johnson.s`seqfj, finite_sequences[nat].finseq_appl(ford_johnson.indx)(ford_johnson.pos)), ford_johnson.searchIndx), oddList := ford_johnson.s`oddList #)" "{s: firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].finseqfj | reals.>(length(s`seqfj), 0)}"))) (binsert_tk_interval_TCC14 0 (binsert_tk_interval_TCC14-1 nil 3762854295 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (skeep) (("" (skeep) (("" (hide -2 -3) (("" (typepred "indx") (("" (hide -1 -4) (("" (expand "is_indx?") (("" (flatten) (("" (inst -2 "pos") (("" (flatten) (("" (inst -3 "0") (("1" (lemma "is_sorted_equiv") (("1" (inst -1 "indx") (("1" (assert) (("1" (inst -1 "0" "pos") (("1" (typepred "pos") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (pos skolem-const-decl "{pos: nat | (k = 1 OR t(k - 1) <= pos) AND pos <= t(k)}" ford_johnson nil) (k skolem-const-decl "posnat" ford_johnson nil) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (< const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (PartialERforK? const-decl "bool" ford_johnson nil)) nil (binsert_tk_interval subtype "(number_fields.-)(ford_johnson.pos, 1)" "{pos: naturalnumbers.nat | booleans.AND((booleans.OR(ford_johnson.k = 1, reals.<=(ford_johnson.t((number_fields.-)(ford_johnson.k, 1)), pos))), reals.<=(pos, ford_johnson.t(ford_johnson.k)))}"))) (binsert_tk_interval_TCC15 0 (binsert_tk_interval_TCC15-1 nil 3796574531 ("" (skeep) (("" (skeep) (("" (skeep) (("" (split) (("1" (hide-all-but (-1 1)) (("1" (expand "upToOne") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "upToOnePreservesIndx") (("2" (expand "finseq_appl") (("2" (inst -1 "s`seqfj" "indx" "b" "searchIndx") (("1" (assert) (("1" (hide-all-but (-1 -2 1)) (("1" (expand "is_indx?") (("1" (split) (("1" (flatten) nil nil) ("2" (expand "finseq_appl") (("2" (flatten) (("2" (skeep) (("2" (hide -1) (("2" (inst?) (("2" (split) (("1" (flatten) (("1" (expand "insert?") (("1" (hide -2) (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (expand "removeSon") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "searchIndx") (("2" (expand "finseq_appl") (("2" (hide 2) (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "pos") (("2" (expand "finseq_appl") (("2" (flatten) (("2" (hide-all-but (-1 -3 -7 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "upToOne") (("3" (assert) nil nil)) nil) ("4" (lemma "insertSonPreservesPartialERforK") (("4" (expand "finseq_appl") (("4" (inst?) (("1" (assert) nil nil) ("2" (typepred "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((insertSonPreservesPartialERforK formula-decl nil ford_johnson nil) (upToOnePreservesIndx formula-decl nil ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (searchIndx skolem-const-decl "upto[finseq_appl[nat](indx)(pos)]" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (indx skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    is_indx?(s`seqfj, indx) AND
     pos < length(indx) AND PartialERforK?(s, indx, k, pos, n)}" ford_johnson nil) (n skolem-const-decl "posnat" ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (pos skolem-const-decl "{pos: nat | (k = 1 OR t(k - 1) <= pos) AND pos <= t(k)}" ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (k skolem-const-decl "posnat" ford_johnson nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (< const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (insert? const-decl "finseq" seq_extras structures) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (upToOne const-decl "finseq[nat]" ford_johnson nil)) nil (binsert_tk_interval subtype "ford_johnson.upToOne(ford_johnson.indx, ford_johnson.searchIndx)" "{indx_1: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx_1), 0), booleans.AND(ford_johnson.is_indx?(seq_extras[fjnode_adt[ford_johnson.T].fjnode].insert?(ford_johnson.b, ford_johnson.removeSon(ford_johnson.s`seqfj, finite_sequences[nat].finseq_appl(ford_johnson.indx)(ford_johnson.pos)), ford_johnson.searchIndx), indx_1), booleans.AND(reals.<((number_fields.-)(ford_johnson.pos, 1), length(indx_1)), ford_johnson.PartialERforK?((# seqfj := seq_extras[fjnode_adt[ford_johnson.T].fjnode].insert?(ford_johnson.b, ford_johnson.removeSon(ford_johnson.s`seqfj, finite_sequences[nat].finseq_appl(ford_johnson.indx)(ford_johnson.pos)), ford_johnson.searchIndx), oddList := ford_johnson.s`oddList #), indx_1, ford_johnson.k, (number_fields.-)(ford_johnson.pos, 1), ford_johnson.n))))}"))) (binsert_tk_interval_TCC16 0 (binsert_tk_interval_TCC16-1 nil 3796574531 ("" (termination-tcc) nil nil) ((posnat_expt application-judgement "posnat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil)) nil (binsert_tk_interval termination "ford_johnson.binsert_tk_interval((# seqfj := seq_extras[fjnode_adt[ford_johnson.T].fjnode].insert?(ford_johnson.b, ford_johnson.removeSon(ford_johnson.s`seqfj, finite_sequences[nat].finseq_appl(ford_johnson.indx)(ford_johnson.pos)), ford_johnson.searchIndx), oddList := ford_johnson.s`oddList #), ford_johnson.k, (number_fields.-)(ford_johnson.pos, 1), ford_johnson.n, ford_johnson.upToOne(ford_johnson.indx, ford_johnson.searchIndx))" "nil"))) (binsert_tk_interval_TCC17 0 (binsert_tk_interval_TCC17-1 nil 3796574531 ("" (subtype-tcc) nil nil) ((posnat_expt application-judgement "posnat" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (^ const-decl "real" exponentiation nil)) nil (binsert_tk_interval subtype "ford_johnson.pos" "below[length(indx)]"))) (binsert_tk_interval_TCC18 0 (binsert_tk_interval_TCC18-1 nil 3796574531 ("" (skeep) (("" (expand "finseq_appl") (("" (typepred "indx") (("" (expand "is_indx?") (("" (flatten) (("" (inst -3 "pos") (("" (expand "finseq_appl") (("" (flatten) (("" (hide-all-but (-3 4)) (("" (rewrite "<") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (< const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (PartialERforK? const-decl "bool" ford_johnson nil)) nil (binsert_tk_interval subtype "finite_sequences[nat].finseq_appl(ford_johnson.indx)(ford_johnson.pos)" "below[s`seqfj`length]"))) (binsert_tk_interval_TCC19 0 (binsert_tk_interval_TCC19-1 nil 3796574531 ("" (skeep) (("" (expand "finseq_appl") (("" (typepred "indx") (("" (typepred "n") (("" (expand "PartialERforK?") (("" (flatten) (("" (hide -5 -6) (("" (inst -5 "pos") (("1" (assert) (("1" (expand "finseq_appl") (("1" (expand "nstruct?") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "pos") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (k skolem-const-decl "posnat" ford_johnson nil) (pos skolem-const-decl "{pos: nat | (k = 1 OR t(k - 1) <= pos) AND pos <= t(k)}" ford_johnson nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (int_plus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (< const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (PartialERforK? const-decl "bool" ford_johnson nil)) nil (binsert_tk_interval subtype "fjnode_adt[ford_johnson.T].smallerones(ford_johnson.s`seqfj`seq(finite_sequences[nat].finseq_appl(ford_johnson.indx)(ford_johnson.pos)))" "(list_adt[fjnode_adt[ford_johnson.T].fjnode].cons?)"))) (binsert_tk_interval_length 0 (binsert_tk_interval_length-1 nil 3751817511 ("" (auto-rewrite "finseq_appl") (("" (measure-induct "pos" ("k" "pos")) (("1" (skeep) (("1" (skeep) (("1" (split) (("1" (expand "binsert_tk_interval" 1) (("1" (lift-if) (("1" (prop) (("1" (hide -3) (("1" (expand "insert?") (("1" (expand "removeSon") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil) ("5" (assert) (("5" (inst -3 "x_1" "x_2-1") (("1" (split -3) (("1" (inst? -1) (("1" (flatten) nil nil) ("2" (hide -2) (("2" (typepred "indx") (("2" (hide -4) (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "x_2") (("2" (flatten) (("2" (assert) (("2" (inst -4 "0") (("1" (lemma "sorting_seq
       [nat,
        restrict[[real, real], [nat, nat], boolean](<=)].is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "0" "x_2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (grind) nil nil)) nil)) nil) ("2" (hide -2) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "binsert_tk_interval" 1) (("2" (lift-if) (("2" (prop) (("1" (hide -2) (("1" (expand "upToOne") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) (("2" (inst -2 "x_1" "x_2 -1") (("1" (split -2) (("1" (inst?) (("1" (flatten) (("1" (replaces) (("1" (hide 1) (("1" (expand "upToOne") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "x_2") (("2" (assert) (("2" (hide 4) (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "x_2") (("2" (flatten) (("2" (assert) (("2" (inst -4 "0") (("2" (lemma "sorting_seq
       [nat,
        restrict[[real, real], [nat, nat], boolean](<=)].is_sorted_equiv") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "0" "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil) ("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2) (("2" (skeep) (("2" (skeep) (("2" (typepred "y_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (hide -1) (("4" (typepred "x`2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (typepred "y`2") (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (assert) nil nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (typepred "pos") (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (assert) nil nil)) nil)) nil) ("10" (hide 2) (("10" (expand "well_founded?") (("10" (skeep* :preds? t) (("10" (inst -2 "p") (("10" (prop) (("1" (skeep) (("1" (inst 1 "y!1") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (measure_induction formula-decl nil measure_induction nil) (posnat nonempty-type-eq-decl nil integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (is_indx? const-decl "bool" ford_johnson nil) (below type-eq-decl nil nat_types nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (/= const-decl "boolean" notequal nil) (binsert_tk_interval def-decl "[finseqfj, finseq[nat]]" ford_johnson nil) (TRUE const-decl "bool" booleans nil) (insert? const-decl "finseq" seq_extras structures) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (x_1 skolem-const-decl "posnat" ford_johnson nil) (x_2 skolem-const-decl "{pos: nat | (x_1 = 1 OR t(x_1 - 1) <= pos) AND pos <= t(x_1)}" ford_johnson nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (n skolem-const-decl "posnat" ford_johnson nil) (indx skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    is_indx?(s`seqfj, indx) AND
     x_2 < length(indx) AND PartialERforK?(s, indx, x_1, x_2, n)}" ford_johnson nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (upto nonempty-type-eq-decl nil nat_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (is_sorted_equiv formula-decl nil sorting_seq nil) (restrict const-decl "R" restrict nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (finite_sequence type-eq-decl nil finite_sequences nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil)) shostak)) (binsert_tk_interval_preserves_indx_TCC1 0 (binsert_tk_interval_preserves_indx_TCC1-1 nil 3751817098 ("" (skeep) (("" (lemma "binsert_tk_interval_length") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((binsert_tk_interval_length formula-decl nil ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (PartialERforK? const-decl "bool" ford_johnson nil) (< const-decl "bool" reals nil) (is_indx? const-decl "bool" ford_johnson nil) (below type-eq-decl nil nat_types nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (binsert_tk_interval_preserves_indx subtype "ford_johnson.binsert_tk_interval(ford_johnson.s, ford_johnson.k, ford_johnson.pos, ford_johnson.n, ford_johnson.indx)`1`seqfj" "{s: finite_sequences[fjnode_adt[ford_johnson.T].fjnode].finseq | reals.>(length(s), 0)}"))) (binsert_tk_interval_preserves_indx_TCC2 0 (binsert_tk_interval_preserves_indx_TCC2-1 nil 3751817098 ("" (skeep) (("" (lemma "binsert_tk_interval_length") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((binsert_tk_interval_length formula-decl nil ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (PartialERforK? const-decl "bool" ford_johnson nil) (< const-decl "bool" reals nil) (is_indx? const-decl "bool" ford_johnson nil) (below type-eq-decl nil nat_types nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (binsert_tk_interval_preserves_indx subtype "ford_johnson.binsert_tk_interval(ford_johnson.s, ford_johnson.k, ford_johnson.pos, ford_johnson.n, ford_johnson.indx)`2" "{indx: finite_sequences[nat].finseq | reals.>(length(indx), 0)}"))) (binsert_tk_interval_preserves_indx 0 (binsert_tk_interval_preserves_indx-4 "" 3804611038 ("" (auto-rewrite "finseq_appl") (("" (measure-induct "pos" ("k" "pos")) (("1" (skeep) (("1" (skeep) (("1" (expand "binsert_tk_interval" 1) (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (hide -2) (("1" (lemma "upToOnePreservesIndx") (("1" (inst -1 " removeSon(s`seqfj, indx`seq(0))" "indx" "car(smallerones(s`seqfj`seq(indx`seq(0))))" " indx`seq(0)") (("1" (split) (("1" (expand "is_indx?") (("1" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (skeep) (("2" (assert) (("2" (inst -2 "i") (("2" (split) (("1" (expand "insert?") (("1" (assert) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "indx") (("2" (hide -4) (("2" (expand "is_indx?") (("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (inst?) (("2" (expand "removeSon") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "removeSon") (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "0") (("2" (flatten) (("2" (hide -4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "removeSon") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (typepred "indx") (("2" (propax) nil nil)) nil)) nil) ("3" (assert) nil nil) ("4" (hide -1) (("4" (assert) nil nil)) nil) ("5" (inst -2 "x_1" "x_2-1") (("1" (assert) (("1" (inst?) (("1" (hide 4) (("1" (typepred "indx") (("1" (hide -4) (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -3 "x_2") (("1" (flatten) (("1" (inst -4 "0") (("1" (assert) (("1" (lemma " sorting_seq[nat, restrict[[real, real], [nat, nat], boolean](<=)].is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "0" "x_2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (skeep) (("2" (lemma "binsert_tk_interval_length") (("2" (inst -1 "y_1" "y_2" "s" "n" "indx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (lemma "binsert_tk_interval_length") (("3" (inst -1 "y_1" "y_2" "s" "n" "indx") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (typepred "y_2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (hide -1) (("6" (lemma "binsert_tk_interval_length") (("6" (assert) (("6" (inst -1 "x`1" "x`2" "s" "n" "indx") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (hide -1) (("7" (lemma "binsert_tk_interval_length") (("7" (assert) (("7" (inst -1 "x`1" "x`2" "s" "n" "indx") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (skeep) (("8" (hide -1) (("8" (typepred "x`2") (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (skeep) (("9" (assert) nil nil)) nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (skeep) (("10" (lemma "binsert_tk_interval_length") (("10" (inst -1 "y`1" "y`2" "s" "n" "indx") (("10" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("11" (hide 2) (("11" (skeep) (("11" (skeep) (("11" (lemma "binsert_tk_interval_length") (("11" (inst -1 "y`1" "y`2" "s" "n" "indx") (("11" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (skeep) (("12" (typepred "y`2") (("12" (assert) nil nil)) nil)) nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (skeep) (("13" (assert) nil nil)) nil)) nil)) nil) ("14" (hide 2) (("14" (skeep) (("14" (lemma "binsert_tk_interval_length") (("14" (inst -1 "k" "pos" "s" "n" "indx") (("14" (assert) nil nil)) nil)) nil)) nil)) nil) ("15" (hide 2) (("15" (skeep) (("15" (lemma "binsert_tk_interval_length") (("15" (inst -1 "k" "pos" "s" "n" "indx") (("15" (assert) nil nil)) nil)) nil)) nil)) nil) ("16" (hide 2) (("16" (skeep) (("16" (typepred "pos") (("16" (assert) nil nil)) nil)) nil)) nil) ("17" (hide 2) (("17" (skeep) (("17" (assert) nil nil)) nil)) nil)) nil)) nil) nil shostak) (binsert_tk_interval_preserves_indx-3 nil 3752934578 ("" (auto-rewrite "finseq_appl") (("" (measure-induct "pos" ("k" "pos")) (("1" (skeep) (("1" (skeep) (("1" (expand "binsert_tk_interval" 1) (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (hide -2) (("1" (lemma "upToOnePreservesIndx") (("1" (inst -1 " removeSon(s`seqfj, indx`seq(0))" "indx" "car(smallerones(s`seqfj`seq(indx`seq(0))))" " indx`seq(0)") (("1" (split) (("1" (expand "is_indx?") (("1" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (skeep) (("2" (assert) (("2" (inst -2 "i") (("2" (split) (("1" (expand "insert?") (("1" (assert) nil nil)) nil) ("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "indx") (("2" (hide -4) (("2" (expand "is_indx?") (("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (inst?) (("2" (expand "removeSon") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "removeSon") (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "0") (("2" (flatten) (("2" (hide -4) (("2" (assert) (("2" (hide -5) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (expand "removeSon") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (typepred "indx") (("2" (propax) nil nil)) nil)) nil) ("3" (assert) nil nil) ("4" (hide -1) (("4" (assert) nil nil)) nil) ("5" (inst -2 "x_1" "x_2-1") (("1" (assert) (("1" (split -2) (("1" (inst?) (("1" (hide 4) (("1" (typepred "indx") (("1" (hide -4) (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -3 "x_2") (("1" (flatten) (("1" (inst -4 "0") (("1" (assert) (("1" (lemma " sorting_seq[nat, restrict[[real, real], [nat, nat], boolean](<=)].is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "0" "x_2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (hide 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (skeep) (("2" (lemma "binsert_tk_interval_length") (("2" (inst -1 "y_1" "y_2" "s" "n" "indx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (lemma "binsert_tk_interval_length") (("3" (inst -1 "y_1" "y_2" "s" "n" "indx") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (typepred "y_2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (hide -1) (("6" (lemma "binsert_tk_interval_length") (("6" (inst -1 "x`1" "x`2" "s1" "n1" "indx1") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (hide -1) (("7" (lemma "binsert_tk_interval_length") (("7" (inst -1 "x`1" "x`2" "s1" "n1" "indx1") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (skeep) (("8" (hide -1) (("8" (typepred "x`2") (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (skeep) (("9" (assert) nil nil)) nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (skeep) (("10" (lemma "binsert_tk_interval_length") (("10" (inst -1 "y`1" "y`2" "s" "n" "indx") (("10" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("11" (hide 2) (("11" (skeep) (("11" (skeep) (("11" (lemma "binsert_tk_interval_length") (("11" (inst -1 "y`1" "y`2" "s" "n" "indx") (("11" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (skeep) (("12" (typepred "y`2") (("12" (assert) nil nil)) nil)) nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (skeep) (("13" (assert) nil nil)) nil)) nil)) nil) ("14" (hide 2) (("14" (skeep) (("14" (lemma "binsert_tk_interval_length") (("14" (inst -1 "k" "pos" "s" "n" "indx") (("14" (assert) nil nil)) nil)) nil)) nil)) nil) ("15" (hide 2) (("15" (skeep) (("15" (lemma "binsert_tk_interval_length") (("15" (inst -1 "k" "pos" "s" "n" "indx") (("15" (assert) nil nil)) nil)) nil)) nil)) nil) ("16" (hide 2) (("16" (skeep) (("16" (typepred "pos") (("16" (assert) nil nil)) nil)) nil)) nil) ("17" (hide 2) (("17" (skeep) (("17" (assert) nil nil)) nil)) nil) ("18" (hide 2) (("18" (expand "well_founded?") (("18" (skeep* :preds? t) (("18" (inst -2 "p") (("18" (prop) (("1" (skeep) (("1" (inst 1 "y!1") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((binsert_tk_interval_length formula-decl nil ford_johnson nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (/= const-decl "boolean" notequal nil) (is_sorted_equiv formula-decl nil sorting_seq nil) (restrict const-decl "R" restrict nil) (finite_sequence type-eq-decl nil finite_sequences nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (x_1 skolem-const-decl "posnat" ford_johnson nil) (x_2 skolem-const-decl "{pos: nat | (x_1 = 1 OR t(x_1 - 1) <= pos) AND pos <= t(x_1)}" ford_johnson nil) (n skolem-const-decl "posnat" ford_johnson nil) (indx skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    is_indx?(s`seqfj, indx) AND
     x_2 < length(indx) AND PartialERforK?(s, indx, x_1, x_2, n)}" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (insert? const-decl "finseq" seq_extras structures) (upToOne const-decl "finseq[nat]" ford_johnson nil) (upToOnePreservesIndx formula-decl nil ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (PartialERforK? const-decl "bool" ford_johnson nil) (binsert_tk_interval def-decl "[finseqfj, finseq[nat]]" ford_johnson nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (below type-eq-decl nil nat_types nil) (is_indx? const-decl "bool" ford_johnson nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posnat nonempty-type-eq-decl nil integers nil) (measure_induction formula-decl nil measure_induction nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil) (binsert_tk_interval_preserves_indx-2 nil 3752930445 ("" (measure-induct "pos" ("k" "pos")) (("1" (skeep) (("1" (skeep) (("1" (case "x_2=0 OR x_1=1 OR x_2=t(x_1-1)") (("1" (hide -2) (("1" (expand "binsert_tk_interval") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (split 1) (("1" (flatten) (("1" (expand "is_indx?") (("1" (split) (("1" (expand "is_sorted?") (("1" (skeep) (("1" (expand "finseq_appl") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (case "indx`seq(k) > indx`seq(0)") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (typepred "indx") (("1" (expand "is_indx?") (("1" (flatten) (("1" (hide -3) (("1" (expand "is_sorted?") (("1" (inst -2 "k") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (hide -1 -3 -4 -5) (("2" (expand "is_sorted?") (("2" (inst -1 "k") (("2" (expand "finseq_appl") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "indx") (("3" (expand "is_indx?") (("3" (flatten) (("3" (hide -1 -3 -4 -5 -6) (("3" (expand "is_sorted?") (("3" (inst -1 "k") (("3" (expand "finseq_appl") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (typepred "indx") (("4" (expand "is_indx?") (("4" (flatten) (("4" (hide -1 -3 -4 -5 -6) (("4" (expand "is_sorted?") (("4" (inst -1 "k") (("4" (expand "finseq_appl") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (hide -4 -5) (("2" (lemma "is_sorted_equiv") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "0" "k") (("2" (inst -4 "0") (("2" (flatten) (("2" (inst -5 "k") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (split 2) (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (flatten) (("2" (assert) (("2" (hide 3) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "binsert_tk_interval" 2 1) (("2" (lift-if) (("2" (split) (("1" (flatten) nil nil) ("2" (prop) (("1" (hide -2) (("1" (expand "binsert_tk_interval") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "binsert_tk_interval") (("2" (assert) nil nil)) nil) ("3" (expand "finseq_appl") (("3" (inst -2 "x_1" "x_2-1") (("1" (assert) (("1" (inst -2 "(# seqfj
                                                  := insert?
                                                     (car
                                                      (smallerones
                                                       (s`seqfj`seq(indx`seq(x_2)))),
                                                      removeSon
                                                      (s`seqfj, indx`seq(x_2)),
                                                      bin_search
                                                      (s`seqfj)
                                                      (car
                                                       (smallerones
                                                        (s`seqfj`seq(indx`seq(x_2)))))
                                                      (0, indx`seq(x_2) - 1)),
                                                  oddList := s`oddList #)" "n" "upToOne(indx,
                                                       bin_search
                                                       (s`seqfj)
                                                       (car
                                                        (smallerones
                                                         (s`seqfj`seq(indx`seq(x_2)))))
                                                       (0,
                                                        indx`seq(x_2) - 1))") (("1" (expand "binsert_tk_interval" 3 2) (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil) ("2" (hide 2 3 4 5 7 8) (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (hide -1 -5) (("2" (lemma "is_sorted_equiv") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "0" "x_2") (("2" (inst -3 "0") (("2" (flatten) (("2" (inst -4 "x_2") (("2" (expand "finseq_appl") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 6)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (skeep) (("2" (lemma "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
     binsert_tk_interval_length") (("2" (inst -1 "y_1" "y_2" "s" "n" "indx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (lemma "binsert_tk_interval_length") (("3" (inst -1 "y_1" "y_2" "s" "n" "indx") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (typepred "y_2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (hide -1) (("6" (lemma "binsert_tk_interval_length") (("6" (inst -1 "x`1" "x`2" "s1" "n1" "indx1") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (hide -1) (("7" (lemma "binsert_tk_interval_length") (("7" (inst -1 "x`1" "x`2" "s1" "n1" "indx1") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (skeep) (("8" (hide -1) (("8" (typepred "x`2") (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (skeep) (("9" (assert) nil nil)) nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (skeep) (("10" (lemma "binsert_tk_interval_length") (("10" (inst -1 "y`1" "y`2" "s" "n" "indx") (("10" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("11" (hide 2) (("11" (skeep) (("11" (skeep) (("11" (lemma "binsert_tk_interval_length") (("11" (inst -1 "y`1" "y`2" "s" "n" "indx") (("11" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (skeep) (("12" (typepred "y`2") (("12" (assert) nil nil)) nil)) nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (skeep) (("13" (assert) nil nil)) nil)) nil)) nil) ("14" (hide 2) (("14" (skeep) (("14" (lemma "binsert_tk_interval_length") (("14" (inst -1 "k" "pos" "s" "n" "indx") (("14" (assert) nil nil)) nil)) nil)) nil)) nil) ("15" (hide 2) (("15" (skeep) (("15" (lemma "binsert_tk_interval_length") (("15" (inst -1 "k" "pos" "s" "n" "indx") (("15" (assert) nil nil)) nil)) nil)) nil)) nil) ("16" (hide 2) (("16" (skeep) (("16" (typepred "pos") (("16" (assert) nil nil)) nil)) nil)) nil) ("17" (hide 2) (("17" (skeep) (("17" (assert) nil nil)) nil)) nil)) nil) nil nil) (binsert_tk_interval_preserves_indx-1 nil 3751817102 ("" (measure-induct "pos" ("k" "pos")) (("1" (skeep) (("1" (skeep) (("1" (case "x_2=0 OR x_1=1 OR x_2=t(x_2-1)") (("1" (hide -2) (("1" (split) (("1" (postpone) nil nil) ("2" (expand "binsert_tk_interval") (("2" (assert) (("2" (expand "finseq_appl") (("2" (postpone) nil nil)) nil)) nil)) nil) ("3" (postpone) nil nil)) nil)) nil) ("2" (expand "binsert_tk_interval" 2 1) (("2" (lift-if) (("2" (split) (("1" (flatten) nil nil) ("2" (prop) (("1" (hide -2) (("1" (expand "binsert_tk_interval") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "binsert_tk_interval") (("2" (assert) nil nil)) nil) ("3" (expand "binsert_tk_interval") (("3" (assert) nil nil)) nil) ("4" (expand "finseq_appl") (("4" (inst -2 "x_1" "x_2-1") (("1" (assert) (("1" (inst -2 "(# seqfj
                                      := insert?
                                         (car
                                          (smallerones
                                           (s`seqfj`seq(indx`seq(x_2)))),
                                          removeSon
                                          (s`seqfj, indx`seq(x_2)),
                                          bin_search
                                          (s`seqfj)
                                          (car
                                           (smallerones
                                            (s`seqfj`seq(indx`seq(x_2)))))
                                          (0, indx`seq(x_2) - 1)),
                                      oddList := s`oddList #)" "n" "upToOne(indx,
                                           bin_search
                                           (s`seqfj)
                                           (car
                                            (smallerones
                                             (s`seqfj`seq(indx`seq(x_2)))))
                                           (0,
                                            indx`seq(x_2) - 1))") (("1" (expand "binsert_tk_interval" 3 2) (("1" (expand "finseq_appl") (("1" (propax) nil nil)) nil)) nil) ("2" (hide 2 3 4 5 7 8) (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (hide -1 -5) (("2" (lemma "is_sorted_equiv") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "0" "x_2") (("2" (inst -3 "0") (("2" (flatten) (("2" (inst -4 "x_2") (("2" (expand "finseq_appl") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 6)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -1 2) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (skeep) (("2" (lemma "%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
binsert_tk_interval_length") (("2" (inst -1 "y_1" "y_2" "s" "n" "indx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (lemma "binsert_tk_interval_length") (("3" (inst -1 "y_1" "y_2" "s" "n" "indx") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (typepred "y_2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (hide -1) (("6" (lemma "binsert_tk_interval_length") (("6" (inst -1 "x`1" "x`2" "s1" "n1" "indx1") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (hide -1) (("7" (lemma "binsert_tk_interval_length") (("7" (inst -1 "x`1" "x`2" "s1" "n1" "indx1") (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (skeep) (("8" (hide -1) (("8" (typepred "x`2") (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (skeep) (("9" (assert) nil nil)) nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (skeep) (("10" (lemma "binsert_tk_interval_length") (("10" (inst -1 "y`1" "y`2" "s" "n" "indx") (("10" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("11" (hide 2) (("11" (skeep) (("11" (skeep) (("11" (lemma "binsert_tk_interval_length") (("11" (inst -1 "y`1" "y`2" "s" "n" "indx") (("11" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (skeep) (("12" (typepred "y`2") (("12" (assert) nil nil)) nil)) nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (skeep) (("13" (assert) nil nil)) nil)) nil)) nil) ("14" (hide 2) (("14" (skeep) (("14" (lemma "binsert_tk_interval_length") (("14" (inst -1 "k" "pos" "s" "n" "indx") (("14" (assert) nil nil)) nil)) nil)) nil)) nil) ("15" (hide 2) (("15" (skeep) (("15" (lemma "binsert_tk_interval_length") (("15" (inst -1 "k" "pos" "s" "n" "indx") (("15" (assert) nil nil)) nil)) nil)) nil)) nil) ("16" (hide 2) (("16" (skeep) (("16" (typepred "pos") (("16" (assert) nil nil)) nil)) nil)) nil) ("17" (hide 2) (("17" (skeep) (("17" (assert) nil nil)) nil)) nil)) nil) nil shostak)) (up_partialER_TCC1 0 (up_partialER_TCC1-1 nil 3751813493 ("" (skeep) (("" (lemma "binsert_tk_interval_length") (("" (inst?) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((binsert_tk_interval_length formula-decl nil ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (indx skolem-const-decl "finseq[nat]" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (up_partialER subtype "ford_johnson.indx" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), ford_johnson.is_indx?(ford_johnson.s`seqfj, indx))}"))) (up_partialER_TCC2 0 (up_partialER_TCC2-1 nil 3751813493 ("" (skeep) (("" (typepred "pos") (("" (assert) nil nil)) nil)) nil) ((AND const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (above nonempty-type-eq-decl nil int_types nil) (> const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (number nonempty-type-decl nil numbers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil (up_partialER subtype "ford_johnson.pos" "{pos: nat_types[length(ford_johnson.indx)].below | booleans.AND((booleans.OR(ford_johnson.k = 1, reals.<=(ford_johnson.t((number_fields.-)(ford_johnson.k, 1)), pos))), reals.<=(pos, ford_johnson.t(ford_johnson.k)))}"))) (up_partialER_TCC3 0 (up_partialER_TCC3-1 nil 3751813493 ("" (skeep) (("" (lemma "binsert_tk_interval_length") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil) ((binsert_tk_interval_length formula-decl nil ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (PartialERforK? const-decl "bool" ford_johnson nil) (< const-decl "bool" reals nil) (is_indx? const-decl "bool" ford_johnson nil) (below type-eq-decl nil nat_types nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil int_types nil) (posnat nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil)) nil (up_partialER subtype "ford_johnson.sk`1" "{s: firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].finseqfj | reals.>(length(s`seqfj), 0)}"))) (up_partialER_TCC4 0 (up_partialER_TCC4-1 nil 3773138580 ("" (skeep) (("" (lemma "binsert_tk_interval_length") (("" (replaces) (("" (inst?) (("" (flatten) (("" (assert) (("" (lemma "binsert_tk_interval_preserves_indx") (("" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((binsert_tk_interval_length formula-decl nil ford_johnson nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil int_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (below type-eq-decl nil nat_types nil) (is_indx? const-decl "bool" ford_johnson nil) (< const-decl "bool" reals nil) (PartialERforK? const-decl "bool" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (binsert_tk_interval_preserves_indx formula-decl nil ford_johnson nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (up_partialER subtype "ford_johnson.sk`2" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), ford_johnson.is_indx?(ford_johnson.sk`1`seqfj, indx))}"))) (up_partialER_TCC5 0 (up_partialER_TCC5-1 nil 3773138580 ("" (skeep) (("" (replaces) (("" (lemma "binsert_tk_interval_length") (("" (inst?) (("" (flatten) (("" (replaces) (("" (typepred "pos") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil int_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (below type-eq-decl nil nat_types nil) (is_indx? const-decl "bool" ford_johnson nil) (< const-decl "bool" reals nil) (PartialERforK? const-decl "bool" ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (binsert_tk_interval_length formula-decl nil ford_johnson nil)) nil (up_partialER subtype "ford_johnson.t((number_fields.-)(ford_johnson.k, 1))" "{pos: nat_types[length(ford_johnson.sk`2)].below | booleans.AND((booleans.OR(ford_johnson.k = 1, reals.<=(ford_johnson.t((number_fields.-)(ford_johnson.k, 1)), pos))), reals.<=(pos, ford_johnson.t(ford_johnson.k)))}"))) (up_partialER 0 (up_partialER-3 "" 3804611934 ("" (measure-induct "pos" ("k" "pos")) (("1" (skeep) (("1" (skeep) (("1" (expand "binsert_tk_interval" 1) (("1" (auto-rewrite "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (hide -2) (("1" (typepred "indx") (("1" (replaces) nil nil)) nil)) nil) ("2" (typepred "indx") (("2" (hide -6) (("2" (typepred "x_2") (("2" (typepred " maxk(indx`length)") (("2" (case-replace "maxk(indx`length) = x_1") (("1" (assert) nil nil) ("2" (hide -9) (("2" (assert) (("2" (lemma "t_is_increasing") (("2" (inst -1 " maxk(indx`length)" "x_1-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case-replace "indx`length = 1") (("1" (typepred "indx") (("1" (hide -6) (("1" (typepred "x_2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("4" (inst -2 "x_1" "x_2-1") (("1" (assert) (("1" (name-replace "sk" "(# seqfj
                                                                    := insert?
                                                                       (car
                                                                        (smallerones
                                                                         (s`seqfj`seq
                                                                          (indx`seq(x_2)))),
                                                                        removeSon
                                                                        (s`seqfj, indx`seq(x_2)),
                                                                        bin_search
                                                                        (s`seqfj)
                                                                        (car
                                                                         (smallerones
                                                                          (s`seqfj`seq
                                                                           (indx`seq(x_2)))))
                                                                        (0, indx`seq(x_2) - 1)),
                                                                    oddList := s`oddList #)") (("1" (typepred "indx") (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -3 "x_2") (("1" (flatten) (("1" (inst -4 "0") (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst -1 "indx") (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "0" "x_2") (("1" (assert) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 4) (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "x_2") (("2" (flatten) (("2" (inst -4 "0") (("1" (expand "finseq_appl") (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst -1 "indx") (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "0" "x_2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (skeep) (("2" (typepred "indx") (("2" (typepred "y_2") (("2" (lemma "binsert_tk_interval_length") (("2" (inst -1 "y_1" "y_2" "s" "n" "indx") (("2" (flatten) (("2" (replaces) (("2" (split) (("1" (replaces) (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (lemma "binsert_tk_interval_length") (("3" (inst -1 "y_1" "y_2" "s" "n" "indx") (("3" (lemma "binsert_tk_interval_preserves_indx") (("3" (inst -1 "y_1" "y_2" "s" "n" "indx") (("3" (assert) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (lemma "binsert_tk_interval_length") (("4" (inst -1 "y_1" "y_2" "s" "n" "indx") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (skeep) (("5" (typepred "y_2") (("5" (assert) nil nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (assert) nil nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (hide -1) (("7" (lemma "binsert_tk_interval_length") (("7" (inst -1 "x`1" "x`2" "s" "n" "indx") (("7" (flatten) (("7" (replaces) (("7" (typepred "indx") (("7" (hide -2 -4) (("7" (typepred "x`2") (("7" (split) (("1" (replaces) (("1" (hide 1) (("1" (grind) nil nil)) nil)) nil) ("2" (hide 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (skeep) (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (skeep) (("9" (hide -1) (("9" (lemma "binsert_tk_interval_length") (("9" (inst -1 "x`1" "x`2" "s" "n" "indx") (("9" (lemma "binsert_tk_interval_preserves_indx") (("9" (inst -1 "x`1" "x`2" "s" "n" "indx") (("9" (assert) (("9" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (skeep) (("10" (hide -1) (("10" (lemma "binsert_tk_interval_length") (("10" (inst -1 "x`1" "x`2" "s" "n" "indx") (("10" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("11" (hide 2) (("11" (skeep) (("11" (skeep) (("11" (typepred "x`2") (("11" (assert) nil nil)) nil)) nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (skeep) (("12" (assert) nil nil)) nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (skeep) (("13" (lemma "binsert_tk_interval_length") (("13" (inst -1 "y`1" "y`2" "s" "n" "indx") (("13" (flatten) (("13" (replaces) (("13" (hide 1) (("13" (typepred "indx") (("13" (typepred "y`2") (("13" (hide -2 -4 -6) (("13" (split) (("1" (replaces) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("14" (hide 2) (("14" (skeep) (("14" (skeep) (("14" (assert) nil nil)) nil)) nil)) nil) ("15" (hide 2) (("15" (skeep) (("15" (skeep) (("15" (lemma "binsert_tk_interval_length") (("15" (inst -1 "y`1" "y`2" "s" "n" "indx") (("15" (lemma "binsert_tk_interval_preserves_indx") (("15" (inst -1 "y`1" "y`2" "s" "n" "indx") (("15" (assert) (("15" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("16" (hide 2) (("16" (skeep) (("16" (skeep) (("16" (lemma "binsert_tk_interval_length") (("16" (inst -1 "y`1" "y`2" "s" "n" "indx") (("16" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("17" (hide 2) (("17" (skeep) (("17" (skeep) (("17" (typepred "y`2") (("17" (assert) nil nil)) nil)) nil)) nil)) nil) ("18" (hide 2) (("18" (skeep) (("18" (skeep) (("18" (assert) nil nil)) nil)) nil)) nil) ("19" (hide 2) (("19" (skeep) (("19" (split) (("1" (lemma "binsert_tk_interval_length") (("1" (inst -1 "k" "pos" "s" "n" "indx") (("1" (flatten) (("1" (replaces) (("1" (replaces) (("1" (typepred "indx") (("1" (typepred "pos") (("1" (hide -4 -6 1) (("1" (split) (("1" (replaces) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (case "k-1=0") (("1" (grind) nil nil) ("2" (inst -1 "k-1" "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("20" (assert) (("20" (hide 2) (("20" (skeep) (("20" (lemma "binsert_tk_interval_length") (("20" (inst -1 "k" "pos" "s" "n" "indx") (("20" (lemma "binsert_tk_interval_preserves_indx") (("20" (inst -1 "k" "pos" "s" "n" "indx") (("20" (assert) (("20" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("21" (hide 2) (("21" (skeep) (("21" (lemma "binsert_tk_interval_length") (("21" (inst -1 "k" "pos" "s" "n" "indx") (("21" (assert) nil nil)) nil)) nil)) nil)) nil) ("22" (hide 2) (("22" (skeep) (("22" (typepred "pos") (("22" (assert) nil nil)) nil)) nil)) nil) ("23" (hide 2) (("23" (skeep) (("23" (assert) nil nil)) nil)) nil)) nil) nil shostak) (up_partialER-2 nil 3797365434 ("" (measure-induct "pos" ("k" "pos")) (("1" (skeep) (("1" (skeep) (("1" (expand "binsert_tk_interval" 1) (("1" (auto-rewrite "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (hide -2) (("1" (typepred "indx") (("1" (replaces) nil nil)) nil)) nil) ("2" (typepred "indx") (("2" (hide -6) (("2" (typepred "x_2") (("2" (typepred " maxk(indx`length)") (("2" (case-replace "maxk(indx`length) = x_1") (("1" (assert) nil nil) ("2" (hide -9) (("2" (assert) (("2" (lemma "t_is_increasing") (("2" (inst -1 " maxk(indx`length)" "x_1-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case-replace "indx`length = 1") (("1" (typepred "indx") (("1" (hide -6) (("1" (typepred "x_2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("4" (inst -2 "x_1" "x_2-1") (("1" (assert) (("1" (name-replace "sk" "(# seqfj
                                                                    := insert?
                                                                       (car
                                                                        (smallerones
                                                                         (s`seqfj`seq
                                                                          (indx`seq(x_2)))),
                                                                        removeSon
                                                                        (s`seqfj, indx`seq(x_2)),
                                                                        bin_search
                                                                        (s`seqfj)
                                                                        (car
                                                                         (smallerones
                                                                          (s`seqfj`seq
                                                                           (indx`seq(x_2)))))
                                                                        (0, indx`seq(x_2) - 1)),
                                                                    oddList := s`oddList #)") (("1" (typepred "indx") (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -3 "x_2") (("1" (flatten) (("1" (inst -4 "0") (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst -1 "indx") (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "0" "x_2") (("1" (assert) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 4) (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "x_2") (("2" (flatten) (("2" (inst -4 "0") (("1" (expand "finseq_appl") (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst -1 "indx") (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (inst -1 "0" "x_2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (skeep) (("2" (typepred "indx") (("2" (typepred "y_2") (("2" (lemma "binsert_tk_interval_length") (("2" (inst -1 "y_1" "y_2" "s" "n" "indx") (("2" (flatten) (("2" (replaces) (("2" (split) (("1" (replaces) (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (lemma "binsert_tk_interval_length") (("3" (inst -1 "y_1" "y_2" "s" "n" "indx") (("3" (lemma "binsert_tk_interval_preserves_indx") (("3" (inst -1 "y_1" "y_2" "s" "n" "indx") (("3" (assert) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (lemma "binsert_tk_interval_length") (("4" (inst -1 "y_1" "y_2" "s" "n" "indx") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (skeep) (("5" (typepred "y_2") (("5" (assert) nil nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (assert) nil nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (hide -1) (("7" (lemma "binsert_tk_interval_length") (("7" (inst -1 "x`1" "x`2" "s1" "n1" "indx1") (("7" (flatten) (("7" (replaces) (("7" (typepred "indx1") (("7" (hide -2 -4) (("7" (typepred "x`2") (("7" (split) (("1" (replaces) (("1" (hide 1) (("1" (grind) nil nil)) nil)) nil) ("2" (hide 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (skeep) (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (skeep) (("9" (hide -1) (("9" (lemma "binsert_tk_interval_length") (("9" (inst -1 "x`1" "x`2" "s1" "n1" "indx1") (("9" (lemma "binsert_tk_interval_preserves_indx") (("9" (inst -1 "x`1" "x`2" "s1" "n1" "indx1") (("9" (assert) (("9" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (skeep) (("10" (hide -1) (("10" (lemma "binsert_tk_interval_length") (("10" (inst -1 "x`1" "x`2" "s1" "n1" "indx1") (("10" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("11" (hide 2) (("11" (skeep) (("11" (skeep) (("11" (typepred "x`2") (("11" (assert) nil nil)) nil)) nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (skeep) (("12" (assert) nil nil)) nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (skeep) (("13" (lemma "binsert_tk_interval_length") (("13" (inst -1 "y`1" "y`2" "s" "n" "indx") (("13" (flatten) (("13" (replaces) (("13" (hide 1) (("13" (typepred "indx") (("13" (typepred "y`2") (("13" (hide -2 -4 -6) (("13" (split) (("1" (replaces) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("14" (hide 2) (("14" (skeep) (("14" (skeep) (("14" (assert) nil nil)) nil)) nil)) nil) ("15" (hide 2) (("15" (skeep) (("15" (skeep) (("15" (lemma "binsert_tk_interval_length") (("15" (inst -1 "y`1" "y`2" "s" "n" "indx") (("15" (lemma "binsert_tk_interval_preserves_indx") (("15" (inst -1 "y`1" "y`2" "s" "n" "indx") (("15" (assert) (("15" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("16" (hide 2) (("16" (skeep) (("16" (skeep) (("16" (lemma "binsert_tk_interval_length") (("16" (inst -1 "y`1" "y`2" "s" "n" "indx") (("16" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("17" (hide 2) (("17" (skeep) (("17" (skeep) (("17" (typepred "y`2") (("17" (assert) nil nil)) nil)) nil)) nil)) nil) ("18" (hide 2) (("18" (skeep) (("18" (skeep) (("18" (assert) nil nil)) nil)) nil)) nil) ("19" (hide 2) (("19" (skeep) (("19" (split) (("1" (lemma "binsert_tk_interval_length") (("1" (inst -1 "k" "pos" "s" "n" "indx") (("1" (flatten) (("1" (replaces) (("1" (replaces) (("1" (typepred "indx") (("1" (typepred "pos") (("1" (hide -4 -6 1) (("1" (split) (("1" (replaces) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (case "k-1=0") (("1" (grind) nil nil) ("2" (inst -1 "k-1" "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("20" (assert) (("20" (hide 2) (("20" (skeep) (("20" (lemma "binsert_tk_interval_length") (("20" (inst -1 "k" "pos" "s" "n" "indx") (("20" (lemma "binsert_tk_interval_preserves_indx") (("20" (inst -1 "k" "pos" "s" "n" "indx") (("20" (assert) (("20" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("21" (hide 2) (("21" (skeep) (("21" (lemma "binsert_tk_interval_length") (("21" (inst -1 "k" "pos" "s" "n" "indx") (("21" (assert) nil nil)) nil)) nil)) nil)) nil) ("22" (hide 2) (("22" (skeep) (("22" (typepred "pos") (("22" (assert) nil nil)) nil)) nil)) nil) ("23" (hide 2) (("23" (skeep) (("23" (assert) nil nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (measure_induction formula-decl nil measure_induction nil) (above nonempty-type-eq-decl nil int_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (is_indx? const-decl "bool" ford_johnson nil) (below type-eq-decl nil nat_types nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (binsert_tk_interval def-decl "[finseqfj, finseq[nat]]" ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (t_is_increasing formula-decl nil ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (is_sorted_equiv formula-decl nil sorting_seq nil) (restrict const-decl "R" restrict nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (finite_sequence type-eq-decl nil finite_sequences nil) (/= const-decl "boolean" notequal nil) (upto nonempty-type-eq-decl nil nat_types nil) (insert? const-decl "finseq" seq_extras structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (x_2 skolem-const-decl "{pos: nat | (x_1 = 1 OR t(x_1 - 1) <= pos) AND pos <= t(x_1)}" ford_johnson nil) (x_1 skolem-const-decl "above[1]" ford_johnson nil) (binsert_tk_interval_length formula-decl nil ford_johnson nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (TRUE const-decl "bool" booleans nil) (binsert_tk_interval_preserves_indx formula-decl nil ford_johnson nil)) nil) (up_partialER-1 nil 3751813509 ("" (measure-induct "pos" ("k" "pos")) (("1" (skeep) (("1" (skeep) (("1" (expand "binsert_tk_interval" 1) (("1" (auto-rewrite "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (hide -2) (("1" (typepred "indx") (("1" (replaces) nil nil)) nil)) nil) ("2" (typepred "indx") (("2" (hide -6) (("2" (typepred "x_2") (("2" (typepred " maxk(indx`length)") (("2" (case-replace "maxk(indx`length) = x_1") (("1" (assert) nil nil) ("2" (hide -9) (("2" (assert) (("2" (lemma "t_is_increasing") (("2" (inst -1 " maxk(indx`length)" "x_1-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case-replace "indx`length = 1") (("1" (typepred "indx") (("1" (hide -6) (("1" (typepred "x_2") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("4" (inst -2 "x_1" "x_2-1") (("1" (assert) (("1" (name-replace "sk" "(# seqfj
                                                    := insert?
                                                       (car
                                                        (smallerones
                                                         (s`seqfj`seq
                                                          (indx`seq(x_2)))),
                                                        removeSon
                                                        (s`seqfj, indx`seq(x_2)),
                                                        bin_search
                                                        (s`seqfj)
                                                        (car
                                                         (smallerones
                                                          (s`seqfj`seq
                                                           (indx`seq(x_2)))))
                                                        (0, indx`seq(x_2) - 1)),
                                                    oddList := s`oddList #)") (("1" (typepred "indx") (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -3 "x_2") (("1" (flatten) (("1" (inst -4 "0") (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (assert) (("1" (typepred "x_1") (("1" (typepred "x_2") (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 4) (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "x_2") (("2" (flatten) (("2" (inst -4 "0") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (hide -2) (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2 -3 -4 -5) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (skeep) (("2" (typepred "indx") (("2" (typepred "y_2") (("2" (lemma "binsert_tk_interval_length") (("2" (inst -1 "y_1" "y_2" "s" "n" "indx") (("2" (flatten) (("2" (replaces) (("2" (split) (("1" (replaces) (("1" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (lemma "binsert_tk_interval_length") (("3" (inst -1 "y_1" "y_2" "s" "n" "indx") (("3" (lemma "binsert_tk_interval_preserves_indx") (("3" (inst -1 "y_1" "y_2" "s" "n" "indx") (("3" (assert) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (lemma "binsert_tk_interval_length") (("4" (inst -1 "y_1" "y_2" "s" "n" "indx") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (skeep) (("5" (typepred "y_2") (("5" (assert) nil nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (assert) nil nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (hide -1) (("7" (lemma "binsert_tk_interval_length") (("7" (inst -1 "x`1" "x`2" "s1" "n1" "indx1") (("7" (flatten) (("7" (replaces) (("7" (typepred "indx1") (("7" (hide -2 -4) (("7" (typepred "x`2") (("7" (split) (("1" (replaces) (("1" (hide 1) (("1" (grind) nil nil)) nil)) nil) ("2" (hide 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (skeep) (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (skeep) (("9" (hide -1) (("9" (lemma "binsert_tk_interval_length") (("9" (inst -1 "x`1" "x`2" "s1" "n1" "indx1") (("9" (lemma "binsert_tk_interval_preserves_indx") (("9" (inst -1 "x`1" "x`2" "s1" "n1" "indx1") (("9" (assert) (("9" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (skeep) (("10" (hide -1) (("10" (lemma "binsert_tk_interval_length") (("10" (inst -1 "x`1" "x`2" "s1" "n1" "indx1") (("10" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("11" (hide 2) (("11" (skeep) (("11" (skeep) (("11" (typepred "x`2") (("11" (assert) nil nil)) nil)) nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (skeep) (("12" (assert) nil nil)) nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (skeep) (("13" (lemma "binsert_tk_interval_length") (("13" (inst -1 "y`1" "y`2" "s" "n" "indx") (("13" (flatten) (("13" (replaces) (("13" (hide 1) (("13" (typepred "indx") (("13" (typepred "y`2") (("13" (hide -2 -4 -6) (("13" (split) (("1" (replaces) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("14" (hide 2) (("14" (skeep) (("14" (skeep) (("14" (assert) nil nil)) nil)) nil)) nil) ("15" (hide 2) (("15" (skeep) (("15" (skeep) (("15" (lemma "binsert_tk_interval_length") (("15" (inst -1 "y`1" "y`2" "s" "n" "indx") (("15" (lemma "binsert_tk_interval_preserves_indx") (("15" (inst -1 "y`1" "y`2" "s" "n" "indx") (("15" (assert) (("15" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("16" (hide 2) (("16" (skeep) (("16" (skeep) (("16" (lemma "binsert_tk_interval_length") (("16" (inst -1 "y`1" "y`2" "s" "n" "indx") (("16" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("17" (hide 2) (("17" (skeep) (("17" (skeep) (("17" (typepred "y`2") (("17" (assert) nil nil)) nil)) nil)) nil)) nil) ("18" (hide 2) (("18" (skeep) (("18" (skeep) (("18" (assert) nil nil)) nil)) nil)) nil) ("19" (hide 2) (("19" (skeep) (("19" (split) (("1" (lemma "binsert_tk_interval_length") (("1" (inst -1 "k" "pos" "s" "n" "indx") (("1" (flatten) (("1" (replaces) (("1" (replaces) (("1" (typepred "indx") (("1" (typepred "pos") (("1" (hide -4 -6 1) (("1" (split) (("1" (replaces) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (case "k-1=0") (("1" (grind) nil nil) ("2" (inst -1 "k-1" "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("20" (assert) (("20" (hide 2) (("20" (skeep) (("20" (lemma "binsert_tk_interval_length") (("20" (inst -1 "k" "pos" "s" "n" "indx") (("20" (lemma "binsert_tk_interval_preserves_indx") (("20" (inst -1 "k" "pos" "s" "n" "indx") (("20" (assert) (("20" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("21" (hide 2) (("21" (skeep) (("21" (lemma "binsert_tk_interval_length") (("21" (inst -1 "k" "pos" "s" "n" "indx") (("21" (assert) nil nil)) nil)) nil)) nil)) nil) ("22" (hide 2) (("22" (skeep) (("22" (typepred "pos") (("22" (assert) nil nil)) nil)) nil)) nil) ("23" (hide 2) (("23" (skeep) (("23" (assert) nil nil)) nil)) nil) ("24" (hide 2) (("24" (expand "well_founded?") (("24" (skeep* :preds? t) (("24" (inst -2 "p") (("24" (prop) (("1" (skeep) (("1" (inst 1 "y!1") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((binsert_tk_interval_preserves_indx formula-decl nil ford_johnson nil) (TRUE const-decl "bool" booleans nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (binsert_tk_interval_length formula-decl nil ford_johnson nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (insert? const-decl "finseq" seq_extras structures) (upto nonempty-type-eq-decl nil nat_types nil) (/= const-decl "boolean" notequal nil) (finite_sequence type-eq-decl nil finite_sequences nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (t_is_increasing formula-decl nil ford_johnson nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (above nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (PartialERforK? const-decl "bool" ford_johnson nil) (binsert_tk_interval def-decl "[finseqfj, finseq[nat]]" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (below type-eq-decl nil nat_types nil) (is_indx? const-decl "bool" ford_johnson nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (above nonempty-type-eq-decl nil int_types nil) (measure_induction formula-decl nil measure_induction nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (binsert_tk_interval_preserves_oddList 0 (binsert_tk_interval_preserves_oddList-1 nil 3754138995 ("" (auto-rewrite "finseq_appl") (("" (measure-induct "pos" ("k" "pos")) (("1" (skeep) (("1" (skeep) (("1" (expand "binsert_tk_interval" 1) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (inst -2 "x_1" "x_2 - 1") (("1" (split -2) (("1" (inst?) (("1" (hide 4) (("1" (typepred "indx") (("1" (hide -1 -3 -4) (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -2 "0") (("1" (flatten) (("1" (inst -3 "x_2") (("1" (assert) (("1" (lemma " sorting_seq [nat, restrict[[real, real], [nat, nat], boolean](<=)].is_sorted_equiv") (("1" (inst?) (("1" (assert) (("1" (inst -1 "0" "x_2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (skeep) (("2" (typepred "y_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (hide -1) (("4" (typepred "x`2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (typepred "y`2") (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (assert) nil nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (typepred "pos") (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (assert) nil nil)) nil)) nil) ("10" (hide 2) (("10" (expand "well_founded?") (("10" (skeep* :preds? t) (("10" (inst -2 "p") (("10" (prop) (("1" (skeep) (("1" (inst 1 "y!1") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (measure_induction formula-decl nil measure_induction nil) (posnat nonempty-type-eq-decl nil integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (is_indx? const-decl "bool" ford_johnson nil) (below type-eq-decl nil nat_types nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (binsert_tk_interval def-decl "[finseqfj, finseq[nat]]" ford_johnson nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (finite_sequence type-eq-decl nil finite_sequences nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (restrict const-decl "R" restrict nil) (is_sorted_equiv formula-decl nil sorting_seq nil) (/= const-decl "boolean" notequal nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (indx skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    is_indx?(s`seqfj, indx) AND
     x_2 < length(indx) AND PartialERforK?(s, indx, x_1, x_2, n)}" ford_johnson nil) (n skolem-const-decl "posnat" ford_johnson nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (insert? const-decl "finseq" seq_extras structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (x_2 skolem-const-decl "{pos: nat | (x_1 = 1 OR t(x_1 - 1) <= pos) AND pos <= t(x_1)}" ford_johnson nil) (x_1 skolem-const-decl "posnat" ford_johnson nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) shostak)) (binsert_tk_interval_gives_permutation 0 (binsert_tk_interval_gives_permutation-2 nil 3797366184 ("" (measure-induct "pos" ("k" "pos")) (("1" (skeep) (("1" (skeep) (("1" (expand "permutation" 1) (("1" (skeep) (("1" (case-replace " occurrences(binsert_tk_interval(s, x_1, x_2, n, indx)`1`oddList)(x) = occurrences(s`oddList)(x)") (("1" (assert) (("1" (hide -1) (("1" (expand "binsert_tk_interval" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "finseq_appl") (("1" (hide -2) (("1" (lemma "insert_removeson_permutation") (("1" (inst -1 "s" "indx`seq(0)" "0") (("1" (expand "permutation") (("1" (assert) (("1" (split) (("1" (inst -1 "x") nil nil) ("2" (typepred "indx") (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (inst -6 "0") (("2" (assert) (("2" (hide -4 -5) (("2" (expand "finseq_appl") (("2" (expand "nstruct?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (inst -2 "x_1" "x_2-1") (("1" (assert) (("1" (expand "permutation") (("1" (case "      occurrences(binsert_tk_interval((# seqfj
                                                                            := insert?
                                                                               (car
                                                                                (smallerones
                                                                                 (s`seqfj`seq
                                                                                  (indx`seq(x_2)))),
                                                                                removeSon
                                                                                (s`seqfj, indx`seq(x_2)),
                                                                                bin_search
                                                                                (s`seqfj)
                                                                                (car
                                                                                 (smallerones
                                                                                  (s`seqfj`seq
                                                                                   (indx`seq(x_2)))))
                                                                                (0, indx`seq(x_2) - 1)),
                                                                            oddList := s`oddList #),
                                                                         x_1,
                                                                         x_2 - 1,
                                                                         n,
                                                                         upToOne
                                                                         (indx,
                                                                          bin_search
                                                                          (s`seqfj)
                                                                          (car
                                                                           (smallerones
                                                                            (s`seqfj`seq(indx`seq(x_2)))))
                                                                          (0, indx`seq(x_2) - 1)))`1`oddList)
                                                    (x) =occurrences(s`oddList)(x) ") (("1" (replaces) (("1" (assert) (("1" (swap-rel -2) (("1" (replaces) (("1" (lemma "insert_removeson_permutation") (("1" (inst -1 "s" "indx`seq(x_2)" "bin_search(s`seqfj)
                                                                 (car
                                                                  (smallerones
                                                                   (s`seqfj`seq(indx`seq(x_2)))))
                                                                 (0, indx`seq(x_2) - 1)") (("1" (split) (("1" (expand "permutation") (("1" (inst -1 "x") (("1" (split -4) (("1" (inst?) (("1" (assert) nil nil) ("2" (hide -1 -2 4) (("2" (typepred "x_2" "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (expand "finseq_appl") (("2" (inst -5 "x_2") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "0" "x_2") (("2" (expand "finseq_appl") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2 5)) (("2" (typepred "indx") (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (inst -6 "x_2") (("1" (assert) (("1" (expand "finseq_appl") (("1" (hide -4 -5) (("1" (expand "nstruct?") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4 -5) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -3 4) (("2" (use "b_search_bound") (("1" (flatten) (("1" (assert) (("1" (typepred "indx") (("1" (expand "is_indx?") (("1" (flatten) (("1" (expand "finseq_appl") (("1" (inst -3 "x_2") (("1" (flatten) (("1" (assert) (("1" (name-replace "ss" "bin_search(s`seqfj)
                (car[fjnode[T]](smallerones[T](s`seqfj`seq(indx`seq(x_2)))))
                (0, indx`seq(x_2) - 1)") (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (expand "finseq_appl") (("2" (inst -3 "x_2") (("2" (flatten) (("2" (inst -4 0) (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst -1 "indx") (("1" (flatten) (("1" (assert) (("1" (hide -2) (("1" (expand "finseq_appl") (("1" (inst -1 "0" "x_2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 4) (("3" (typepred "indx") (("3" (expand "is_indx?") (("3" (flatten) (("3" (inst -3 "0") (("3" (flatten) (("3" (inst -4 "x_2") (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst -1 "indx") (("1" (assert) (("1" (expand "finseq_appl") (("1" (inst -1 "0" "x_2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (inst -1 "x_1" "x_2 - 1" "(# seqfj
                                                                     := insert?
                                                                        (car
                                                                         (smallerones
                                                                          (s`seqfj`seq
                                                                           (indx`seq(x_2)))),
                                                                         removeSon
                                                                         (s`seqfj, indx`seq(x_2)),
                                                                         bin_search
                                                                         (s`seqfj)
                                                                         (car
                                                                          (smallerones
                                                                           (s`seqfj`seq
                                                                            (indx`seq(x_2)))))
                                                                         (0, indx`seq(x_2) - 1)),
                                                                     oddList := s`oddList #)" "n" "upToOne
                                                                  (indx,
                                                                   bin_search
                                                                   (s`seqfj)
                                                                   (car
                                                                    (smallerones
                                                                     (s`seqfj`seq(indx`seq(x_2)))))
                                                                   (0, indx`seq(x_2) - 1))") (("1" (replaces) nil nil) ("2" (typepred "x_2") (("2" (reveal 1 4) (("2" (assert) (("2" (hide 4) (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "0" "x_2") (("2" (expand "finseq_appl") (("2" (inst -4 "0") (("2" (flatten) (("2" (inst -5 "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (reveal 2 5) (("3" (typepred "x_2") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -2 4) (("3" (typepred "x_2") (("3" (assert) nil nil)) nil)) nil) ("4" (hide -2 4) (("4" (typepred "indx") (("4" (expand "is_indx?") (("4" (flatten) (("4" (inst -3 "0") (("4" (flatten) (("4" (inst -4 "x_2") (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst -1 "indx") (("1" (assert) (("1" (inst -1 "0" "x_2") (("1" (expand "finseq_appl") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (inst -1 "x_1" "x_2" "s" "n" "indx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (hide 3) (("2" (typepred "y_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (typepred "x`2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (typepred "y`2") (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (assert) nil nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (typepred "pos") (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (assert) nil nil)) nil)) nil) ("10" (hide 2) (("10" (expand "well_founded?") (("10" (skeep* :preds? t) (("10" (inst -2 "p") (("10" (prop) (("1" (skeep) (("1" (inst 1 "y!1") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((occurrences const-decl "nat" firt_phase_ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (insert? const-decl "finseq" seq_extras structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (n skolem-const-decl "posnat" ford_johnson nil) (indx skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    is_indx?(s`seqfj, indx) AND
     x_2 < length(indx) AND PartialERforK?(s, indx, x_1, x_2, n)}" ford_johnson nil) (is_sorted_equiv formula-decl nil sorting_seq nil) (restrict const-decl "R" restrict nil) (/= const-decl "boolean" notequal nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (is_sorted? const-decl "bool" sorting_seq nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (rat_exp application-judgement "rat" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_exp application-judgement "int" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (finite_sequence type-eq-decl nil finite_sequences nil) (b_search_bound formula-decl nil ford_johnson nil) (binsert_tk_interval_preserves_oddList formula-decl nil ford_johnson nil) (x_2 skolem-const-decl "{pos: nat | (x_1 = 1 OR t(x_1 - 1) <= pos) AND pos <= t(x_1)}" ford_johnson nil) (x_1 skolem-const-decl "posnat" ford_johnson nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (insert_removeson_permutation formula-decl nil ford_johnson nil) (permutation const-decl "bool" firt_phase_ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (binsert_tk_interval def-decl "[finseqfj, finseq[nat]]" ford_johnson nil) (permutation const-decl "bool" firt_phase_ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (below type-eq-decl nil nat_types nil) (is_indx? const-decl "bool" ford_johnson nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posnat nonempty-type-eq-decl nil integers nil) (measure_induction formula-decl nil measure_induction nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil) (binsert_tk_interval_gives_permutation-1 nil 3754136880 ("" (measure-induct "pos" ("k" "pos")) (("1" (skeep) (("1" (skeep) (("1" (expand "permutation" 1) (("1" (skeep) (("1" (case-replace " occurrences(binsert_tk_interval(s, x_1, x_2, n, indx)`1`oddList)(x) = occurrences(s`oddList)(x)") (("1" (assert) (("1" (hide -1) (("1" (expand "binsert_tk_interval" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "finseq_appl") (("1" (hide -2) (("1" (lemma "insert_removeson_permutation") (("1" (inst -1 "s" "indx`seq(0)" "0") (("1" (expand "permutation") (("1" (assert) (("1" (split) (("1" (inst -1 "x") nil nil) ("2" (typepred "indx") (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (inst -6 "0") (("2" (assert) (("2" (hide -4 -5) (("2" (expand "finseq_appl") (("2" (expand "nstruct?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (inst -2 "x_1" "x_2-1") (("1" (assert) (("1" (expand "permutation") (("1" (case "      occurrences(binsert_tk_interval((# seqfj
                                                           := insert?
                                                              (car
                                                               (smallerones
                                                                (s`seqfj`seq
                                                                 (indx`seq(x_2)))),
                                                               removeSon
                                                               (s`seqfj, indx`seq(x_2)),
                                                               bin_search
                                                               (s`seqfj)
                                                               (car
                                                                (smallerones
                                                                 (s`seqfj`seq
                                                                  (indx`seq(x_2)))))
                                                               (0, indx`seq(x_2) - 1)),
                                                           oddList := s`oddList #),
                                                        x_1,
                                                        x_2 - 1,
                                                        n,
                                                        upToOne
                                                        (indx,
                                                         bin_search
                                                         (s`seqfj)
                                                         (car
                                                          (smallerones
                                                           (s`seqfj`seq(indx`seq(x_2)))))
                                                         (0, indx`seq(x_2) - 1)))`1`oddList)
                                   (x) =occurrences(s`oddList)(x) ") (("1" (replaces) (("1" (assert) (("1" (swap-rel -2) (("1" (replaces) (("1" (lemma "insert_removeson_permutation") (("1" (inst -1 "s" "indx`seq(x_2)" "bin_search(s`seqfj)
                                                   (car
                                                    (smallerones
                                                     (s`seqfj`seq(indx`seq(x_2)))))
                                                   (0, indx`seq(x_2) - 1)") (("1" (split) (("1" (expand "permutation") (("1" (inst -1 "x") (("1" (postpone) nil nil)) nil)) nil) ("2" (hide-all-but (1 2 5)) (("2" (typepred "indx") (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (inst -6 "x_2") (("1" (assert) (("1" (expand "finseq_appl") (("1" (hide -4 -5) (("1" (expand "nstruct?") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4 -5) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil) ("3" (hide 4) (("3" (typepred "indx") (("3" (expand "is_indx?") (("3" (flatten) (("3" (inst -3 "0") (("3" (flatten) (("3" (inst -4 "x_2") (("1" (assert) (("1" (expand "finseq_appl") (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (inst -1 "x_1" "x_2 - 1" "(# seqfj
                                                       := insert?
                                                          (car
                                                           (smallerones
                                                            (s`seqfj`seq
                                                             (indx`seq(x_2)))),
                                                           removeSon
                                                           (s`seqfj, indx`seq(x_2)),
                                                           bin_search
                                                           (s`seqfj)
                                                           (car
                                                            (smallerones
                                                             (s`seqfj`seq
                                                              (indx`seq(x_2)))))
                                                           (0, indx`seq(x_2) - 1)),
                                                       oddList := s`oddList #)" "n" "upToOne
                                                    (indx,
                                                     bin_search
                                                     (s`seqfj)
                                                     (car
                                                      (smallerones
                                                       (s`seqfj`seq(indx`seq(x_2)))))
                                                     (0, indx`seq(x_2) - 1))") (("1" (replaces) nil nil) ("2" (typepred "x_2") (("2" (reveal 1 4) (("2" (assert) (("2" (hide 4) (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (assert) (("2" (expand "finseq_appl") (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (reveal 2 5) (("3" (typepred "x_2") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -2 4) (("3" (typepred "x_2") (("3" (assert) nil nil)) nil)) nil) ("4" (hide -2 4) (("4" (typepred "indx") (("4" (expand "is_indx?") (("4" (flatten) (("4" (inst -3 "0") (("4" (flatten) (("4" (inst -4 "x_2") (("1" (assert) (("1" (expand "finseq_appl") (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil) ("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (inst -1 "x_1" "x_2" "s" "n" "indx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (skeep) (("2" (hide 3) (("2" (typepred "y_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) (("4" (typepred "x`2") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (typepred "y`2") (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (assert) nil nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (typepred "pos") (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (assert) nil nil)) nil)) nil) ("10" (hide 2) (("10" (expand "well_founded?") (("10" (skeep* :preds? t) (("10" (inst -2 "p") (("10" (prop) (("1" (skeep) (("1" (inst 1 "y!1") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finite_sequence type-eq-decl nil finite_sequences nil) (/= const-decl "boolean" notequal nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (binsert_tk_interval_preserves_oddList formula-decl nil ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (insert? const-decl "finseq" seq_extras structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (insert_removeson_permutation formula-decl nil ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (binsert_tk_interval def-decl "[finseqfj, finseq[nat]]" ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (below type-eq-decl nil nat_types nil) (is_indx? const-decl "bool" ford_johnson nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (posnat nonempty-type-eq-decl nil integers nil) (measure_induction formula-decl nil measure_induction nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (PartialERforK_equiv_TCC1 0 (PartialERforK_equiv_TCC1-1 nil 3754225289 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (typepred "indx") (("" (assert) (("" (typepred "maxk(indx`length)") (("" (lemma "t_is_increasing") (("" (inst -1 "k-1" "maxk(indx`length) -1 ") (("" (assert) (("" (hide-all-but (1)) (("" (lemma "t_is_increasing") (("" (inst -1 "k-1" "k") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (t_is_increasing formula-decl nil ford_johnson nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (above nonempty-type-eq-decl nil int_types nil) (posnat nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil)) nil (PartialERforK_equiv subtype "ford_johnson.t((number_fields.-)(ford_johnson.k, 1))" "{pos: nat_types[length(ford_johnson.indx)].below | booleans.AND((booleans.OR(ford_johnson.k = 1, reals.<=(ford_johnson.t((number_fields.-)(ford_johnson.k, 1)), pos))), reals.<=(pos, ford_johnson.t(ford_johnson.k)))}"))) (PartialERforK_equiv_TCC2 0 (PartialERforK_equiv_TCC2-1 nil 3754225289 ("" (skeep) (("" (typepred "indx") (("" (hide -4) (("" (case "t(1+k) > length(indx)-1") (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (hide -1 -2 -4) (("3" (typepred "maxk(indx`length)") (("3" (lemma "t_is_increasing") (("3" (inst -1 "k" "maxk(indx`length)-1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (assert) (("2" (hide-all-but (2)) (("2" (lemma "t_is_increasing") (("2" (inst -1 "k" "k+1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil int_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (t_is_increasing formula-decl nil ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)) nil (PartialERforK_equiv subtype "real_defs.min(ford_johnson.t((number_fields.+)(1, ford_johnson.k)), (number_fields.-)(length(ford_johnson.indx), 1))" "{pos: nat_types[length(ford_johnson.indx)].below | booleans.AND((booleans.OR(ford_johnson.k = 0, reals.<=(ford_johnson.t(ford_johnson.k), pos))), reals.<=(pos, ford_johnson.t((number_fields.+)(1, ford_johnson.k))))}"))) (PartialERforK_equiv 0 (PartialERforK_equiv-2 nil 3797365798 ("" (skeep) (("" (auto-rewrite "finseq_appl") (("" (expand "PartialERforK?" 1) (("" (split) (("1" (skeep) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -2 -3 -4) (("1" (case "t(k) < length(indx)") (("1" (case "j<=indx(t(k))") (("1" (inst -3 "j") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (skeep) (("1" (inst 2 "i") (("1" (typepred "i") (("1" (assert) (("1" (split -2) (("1" (assert) nil nil) ("2" (expand "min") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (reveal -2) (("2" (assert) (("2" (inst -1 "j") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (inst 4 "i") (("2" (typepred "i") (("2" (expand "min") (("2" (assert) (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil) ("2" (hide -1 2 3) (("2" (typepred "indx") (("2" (hide -2) (("2" (typepred " maxk(indx`length)") (("2" (lemma "t_is_increasing") (("2" (inst -1 "k" " maxk(indx`length) - 1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -3 -5) (("1" (inst -3 "j") (("1" (flatten) (("1" (split -3) (("1" (flatten) (("1" (assert) (("1" (skeep) (("1" (inst 1 "i") (("1" (typepred "i") (("1" (expand "min") (("1" (split) (("1" (assert) nil nil) ("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (lemma "t_is_increasing") (("2" (inst -1 "k" "k+1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) (("3" (hide-all-but (-1 -2 1)) (("3" (typepred "indx") (("3" (expand "is_indx?") (("3" (flatten) (("3" (hide -3) (("3" (lemma "is_sorted_equiv[nat, <=]") (("3" (inst -1 "indx") (("3" (assert) (("3" (inst -1 "t(k)" "t(k+1)") (("1" (assert) nil nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "k" "k+1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -3 "j") (("2" (assert) (("2" (flatten) (("2" (skeep) (("2" (typepred "i") (("2" (assert) (("2" (split) (("1" (assert) nil nil) ("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (hide -3) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "t(k)" "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (case "t(1 + k)<length(indx)") (("1" (expand "min") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -2 -4) (("1" (inst -2 "indx`seq(i)") (("1" (assert) (("1" (flatten) (("1" (hide-all-but 2) (("1" (typepred "indx") (("1" (typepred "i") (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -6 "t(k)") (("1" (assert) (("1" (flatten) (("1" (inst -7 "i") (("1" (lemma "is_sorted_equiv[nat, <=]") (("1" (inst -1 "indx") (("1" (assert) (("1" (inst -1 "t(k)" "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (assert) (("2" (expand "min") (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -6) (("2" (inst -4 "indx`seq(i)") (("2" (assert) (("2" (flatten) (("2" (hide-all-but (-1 -2 3)) (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "t(k)") (("2" (flatten) (("2" (inst -4 "i") (("2" (assert) (("2" (lemma "is_sorted_equiv[nat, <=]") (("2" (inst -1 "indx") (("2" (assert) (("2" (inst -1 "t(k)" "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "PartialERforK?") (("4" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ((t_is_increasing formula-decl nil ford_johnson nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (= const-decl "[T, T -> boolean]" equalities nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (k skolem-const-decl "above[1]" ford_johnson nil) (indx skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    (is_indx?(s`seqfj, indx) AND 1 + k <= maxk(indx`length))}" ford_johnson nil) (i skolem-const-decl "{i: below[length(indx)] |
   (i <= t(k - 1) OR i > t(k)) AND (i > t(k - 1) OR k = 1)}" ford_johnson nil) (NOT const-decl "[bool -> bool]" booleans nil) (i skolem-const-decl "{i: below[length(indx)] |
   (i <= t(k - 1) OR i > t(k)) AND (i > t(k - 1) OR k = 1)}" ford_johnson nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (above nonempty-type-eq-decl nil int_types nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posnat nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (i skolem-const-decl "{i: below[length(indx)] |
   (i <= t(k - 1) OR i > t(k)) AND (i > t(k - 1) OR k = 1)}" ford_johnson nil) (finite_sequence type-eq-decl nil finite_sequences nil) (restrict const-decl "R" restrict nil) (is_sorted_equiv formula-decl nil sorting_seq nil) (/= const-decl "boolean" notequal nil) (PartialERforK? const-decl "bool" ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil)) nil) (PartialERforK_equiv-1 nil 3754225296 ("" (skeep) (("" (auto-rewrite "finseq_appl") (("" (expand "PartialERforK?" 1) (("" (split) (("1" (skeep) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -2 -3 -4) (("1" (case "t(k) < length(indx)") (("1" (case "j<=indx(t(k))") (("1" (inst -3 "j") (("1" (assert) (("1" (flatten) (("1" (assert) (("1" (skeep) (("1" (inst 2 "i") (("1" (typepred "i") (("1" (assert) (("1" (split -2) (("1" (assert) nil nil) ("2" (expand "min") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (reveal -2) (("2" (assert) (("2" (inst -1 "j") (("2" (assert) (("2" (flatten) (("2" (assert) (("2" (skeep) (("2" (inst 4 "i") (("2" (typepred "i") (("2" (expand "min") (("2" (assert) (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (propax) nil nil)) nil) ("2" (hide -1 2 3) (("2" (typepred "indx") (("2" (hide -2) (("2" (typepred " maxk(indx`length)") (("2" (lemma "t_is_increasing") (("2" (inst -1 "k" " maxk(indx`length) - 1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (assert) (("2" (split) (("1" (flatten) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -3 -5) (("1" (inst -3 "j") (("1" (flatten) (("1" (split -3) (("1" (flatten) (("1" (assert) (("1" (skeep) (("1" (inst 1 "i") (("1" (typepred "i") (("1" (expand "min") (("1" (split) (("1" (assert) nil nil) ("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (lemma "t_is_increasing") (("2" (inst -1 "k" "k+1") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) (("3" (hide-all-but (-1 -2 1)) (("3" (typepred "indx") (("3" (expand "is_indx?") (("3" (flatten) (("3" (hide -3) (("3" (assert) (("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -5) (("2" (inst -3 "j") (("2" (assert) (("2" (flatten) (("2" (skeep) (("2" (typepred "i") (("2" (assert) (("2" (split) (("1" (assert) nil nil) ("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (hide -3) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (case "t(1 + k)<length(indx)") (("1" (expand "min") (("1" (assert) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -2 -4) (("1" (inst -2 "indx`seq(i)") (("1" (assert) (("1" (flatten) (("1" (hide-all-but 2) (("1" (typepred "indx") (("1" (typepred "i") (("1" (assert) (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -6 "t(k)") (("1" (assert) (("1" (flatten) (("1" (inst -7 "i") (("1" (assert) (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (assert) (("2" (expand "min") (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -4 -6) (("2" (inst -4 "indx`seq(i)") (("2" (assert) (("2" (flatten) (("2" (hide-all-but (-1 -2 3)) (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "t(k)") (("2" (flatten) (("2" (inst -4 "i") (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "PartialERforK?") (("4" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil) ((t_is_increasing formula-decl nil ford_johnson nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (= const-decl "[T, T -> boolean]" equalities nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (above nonempty-type-eq-decl nil int_types nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (fjnode type-decl nil fjnode_adt nil) (PRED type-eq-decl nil defined_types nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (finite_sequence type-eq-decl nil finite_sequences nil) (/= const-decl "boolean" notequal nil) (PartialERforK? const-decl "bool" ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (basis_PartialERforK_equiv_TCC1 0 (basis_PartialERforK_equiv_TCC1-1 nil 3762253863 ("" (skeep) (("" (grind) nil nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (is_indx? const-decl "bool" ford_johnson nil) (is_sorted? const-decl "bool" sorting_seq nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (<= const-decl "bool" reals nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil)) nil (basis_PartialERforK_equiv subtype "0" "below[indx`length]"))) (basis_PartialERforK_equiv_TCC2 0 (basis_PartialERforK_equiv_TCC2-1 nil 3762253863 ("" (skeep) (("" (grind) nil nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (basis_PartialERforK_equiv subtype "ford_johnson.t(1)" "{pos: nat_types[length(ford_johnson.indx)].below | reals.<=(pos, ford_johnson.t(1))}"))) (basis_PartialERforK_equiv_TCC3 0 (basis_PartialERforK_equiv_TCC3-1 nil 3762253863 ("" (skeep) (("" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (grind) nil nil) ("4" (propax) nil nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (basis_PartialERforK_equiv subtype "ford_johnson.t(1)" "{pos: naturalnumbers.nat | reals.<=(pos, ford_johnson.t(1))}"))) (basis_PartialERforK_equiv_TCC4 0 (basis_PartialERforK_equiv_TCC4-1 nil 3762253863 ("" (skeep) (("" (assert) (("" (hide -) (("" (grind) nil nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (basis_PartialERforK_equiv subtype "ford_johnson.indx" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), booleans.AND(ford_johnson.is_indx?(ford_johnson.s`seqfj, indx), booleans.AND(reals.<(ford_johnson.t(1), length(indx)), ford_johnson.PartialERforK?(ford_johnson.s, indx, 1, ford_johnson.t(1), ford_johnson.n))))}"))) (basis_PartialERforK_equiv_TCC5 0 (basis_PartialERforK_equiv_TCC5-1 nil 3762253863 ("" (skeep) (("" (skeep) (("" (split) (("1" (lemma "binsert_tk_interval_length") (("1" (inst?) (("1" (typepred "indx") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (typepred "indx") (("2" (lemma "binsert_tk_interval_preserves_indx") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (below type-eq-decl nil nat_types nil) (is_indx? const-decl "bool" ford_johnson nil) (< const-decl "bool" reals nil) (PartialERforK? const-decl "bool" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (binsert_tk_interval_length formula-decl nil ford_johnson nil)) nil (basis_PartialERforK_equiv subtype "ford_johnson.sk`1" "{s: firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].finseqfj | reals.>(length(s`seqfj), 0)}"))) (basis_PartialERforK_equiv_TCC6 0 (basis_PartialERforK_equiv_TCC6-1 nil 3762253863 ("" (skeep) (("" (skeep) (("" (typepred "indx") (("" (hide -4) (("" (lemma "binsert_tk_interval_length") (("" (inst?) (("" (assert) (("" (flatten) (("" (replaces) (("" (replaces) (("" (hide 1) (("" (expand "binsert_tk_interval") (("" (expand "finseq_appl") (("" (lemma "upToOnePreservesIndx") (("" (inst?) (("1" (assert) (("1" (hide 2) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (PartialERforK? const-decl "bool" ford_johnson nil) (binsert_tk_interval def-decl "[finseqfj, finseq[nat]]" ford_johnson nil) (upToOnePreservesIndx formula-decl nil ford_johnson nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (is_sorted? const-decl "bool" sorting_seq nil) (restrict const-decl "R" restrict nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (upto nonempty-type-eq-decl nil nat_types nil) (indx skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND (is_indx?(s`seqfj, indx)) AND indx`seq(0) = 0}" ford_johnson nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (TRUE const-decl "bool" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (binsert_tk_interval_length formula-decl nil ford_johnson nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (= const-decl "[T, T -> boolean]" equalities nil)) nil (basis_PartialERforK_equiv subtype "ford_johnson.sk`2" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), ford_johnson.is_indx?(ford_johnson.sk`1`seqfj, indx))}"))) (basis_PartialERforK_equiv_TCC7 0 (basis_PartialERforK_equiv_TCC7-1 nil 3782728808 ("" (skeep) (("" (skeep) (("" (grind) nil nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil ford_johnson nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (insert? const-decl "finseq" seq_extras structures) (upToOne const-decl "finseq[nat]" ford_johnson nil) (binsert_tk_interval def-decl "[finseqfj, finseq[nat]]" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (is_indx? const-decl "bool" ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (> const-decl "bool" reals nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil)) nil (basis_PartialERforK_equiv subtype "real_defs.min(ford_johnson.t(2), (number_fields.-)(length(ford_johnson.sk`2), 1))" "{pos: nat_types[length(ford_johnson.sk`2)].below | booleans.AND(reals.<=(ford_johnson.t(1), pos), reals.<=(pos, ford_johnson.t(2)))}"))) (basis_PartialERforK_equiv 0 (basis_PartialERforK_equiv-1 nil 3773134543 ("" (skeep) (("" (beta) (("" (auto-rewrite "finseq_appl") (("" (expand "PartialERforK?" 1) (("" (prop) (("1" (skeep) (("1" (expand "binsert_tk_interval") (("1" (assert) (("1" (assert) (("1" (case-replace "j=0") (("1" (expand "insert?") (("1" (hide 2) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (inst -2 "0") (("1" (hide -2 -3 -5) (("1" (inst -2 "0") (("1" (expand "nstruct?" -2) (("1" (flatten) (("1" (inst -3 "0") (("1" (flatten) (("1" (expand "nth") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "insert?") (("2" (assert) (("2" (case-replace "j=1") (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -3 -5) (("1" (hide 3) (("1" (hide -2) (("1" (typepred "indx") (("1" (expand "finseq_appl") (("1" (assert) (("1" (expand "nstruct?") (("1" (assert) (("1" (prop) (("1" (expand "removeSon") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (inst -7 "0") (("1" (flatten) (("1" (inst -8 "0") (("1" (expand "nth") (("1" (hide -8) (("1" (expand "length" -) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -6 "0") (("2" (flatten) (("2" (hide -7) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "removeSon") (("2" (assert) (("2" (lift-if) (("2" (split) (("1" (flatten) (("1" (inst -7 "0") (("1" (flatten) (("1" (inst -8 "i+1") (("1" (expand "nth" -) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (hide-all-but (-1 -2 1)) (("2" (expand "removeSon") (("2" (assert) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (inst -6 "0") (("2" (flatten) (("2" (hide -7) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (inst -5 "0") (("3" (flatten) (("3" (expand "removeSon") (("3" (assert) (("3" (expand "length" -5) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "removeSon") (("2" (prop) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (hide -2 -3) (("3" (inst -1 "j-1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) (("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -2 -3) (("4" (inst -1 "j-1") (("4" (assert) (("4" (flatten) (("4" (skeep) (("4" (inst 1 "i") (("1" (expand "upToOne") (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "binsert_tk_interval") (("2" (expand "upToOne") (("2" (expand "min") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (expand "t") (("2" (expand "^") (("2" (expand "expt") (("2" (expand "expt") (("2" (expand "expt") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (expand "t") (("4" (expand "^") (("4" (expand "expt") (("4" (expand "expt") (("4" (expand "expt") (("4" (expand "expt") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (assert) nil nil) ("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (split) (("1" (flatten) (("1" (assert) (("1" (expand "binsert_tk_interval") (("1" (expand "upToOne") (("1" (expand "finseq_appl") (("1" (lift-if) (("1" (prop) (("1" (typepred "indx") (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (typepred "indx") (("2" (assert) (("2" (grind) nil nil)) nil)) nil) ("3" (expand "insert?") (("3" (assert) (("3" (expand "removeSon") (("3" (assert) (("3" (expand "PartialERforK?") (("3" (flatten) (("3" (inst -4 "j-1") (("3" (assert) (("3" (hide -3 -4 -5 1 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "PartialERforK?") (("4" (flatten) (("4" (inst -4 "j-1") (("1" (hide -3 -5 2) (("1" (assert) (("1" (split) (("1" (flatten) (("1" (skeep) (("1" (inst 1 "i") (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (split) (("1" (expand "binsert_tk_interval") (("1" (expand "upToOne") (("1" (assert) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil) ("3" (hide -1) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 2) (("2" (grind) nil nil)) nil) ("3" (hide -3 2) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide -3 -4 -5 2) (("2" (typepred "j") (("2" (expand "binsert_tk_interval") (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "finseq_appl") (("2" (expand "binsert_tk_interval") (("2" (expand "upToOne") (("2" (expand "finseq_appl") (("2" (lift-if) (("2" (prop) (("1" (hide -4 1) (("1" (typepred "indx") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (expand "insert?") (("2" (expand "finseq_appl") (("2" (prop) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (inst -6 "0") (("1" (expand "finseq_appl") (("1" (hide -4 -5) (("1" (expand "nstruct?" -) (("1" (flatten) (("1" (inst -5 "0") (("1" (flatten) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "removeSon") (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (replaces) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -4 -5) (("1" (inst -4 "0") (("1" (assert) (("1" (expand "nstruct?") (("1" (flatten) (("1" (prop) (("1" (expand "length" -) (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (inst -6 "i+1") (("1" (expand "nth" -) (("1" (propax) nil nil)) nil) ("2" (typepred "i") (("2" (expand "length" +) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (expand "length" -) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (hide 2) (("2" (expand "PartialERforK?") (("2" (flatten) (("2" (hide -3 -4) (("2" (inst -3 "0") (("2" (assert) (("2" (expand "nstruct?") (("2" (flatten) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (inst -3 "j-1") (("3" (assert) (("3" (flatten) (("3" (skeep) (("3" (both-sides "-" "1" -1) (("3" (swap-rel -4) (("3" (replaces) (("3" (assert) (("3" (case-replace "t(1)=0") (("1" (assert) nil nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (prop) (("1" (expand "binsert_tk_interval") (("1" (assert) (("1" (expand "upToOne") (("1" (assert) (("1" (prop) (("1" (expand "insert?") (("1" (assert) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "insert?") (("2" (assert) (("2" (expand "removeSon") (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (typepred "i") (("1" (case-replace "t(1)=0") (("1" (typepred "indx") (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -3 "0") (("1" (flatten) (("1" (inst -4 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (case-replace "t(1)=0") (("1" (typepred "indx") (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -3 "0") (("1" (flatten) (("1" (inst -4 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) (("3" (inst -3 "indx`seq(i)") (("3" (assert) (("3" (case-replace "t(1)=0") (("1" (assert) nil nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "binsert_tk_interval") (("2" (expand "upToOne") (("2" (assert) (("2" (expand "insert?") (("2" (expand "removeSon") (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (hide +) (("1" (typepred "indx") (("1" (expand "is_indx?") (("1" (flatten) (("1" (inst -3 "0") (("1" (flatten) (("1" (inst -4 "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide +) (("2" (typepred "indx") (("2" (expand "is_indx?") (("2" (flatten) (("2" (inst -3 "0") (("2" (flatten) (("2" (inst -4 "i") (("2" (assert) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "i") (("3" (expand "min") (("3" (lift-if) (("3" (prop) (("3" (typepred "i") (("3" (expand "binsert_tk_interval") (("3" (expand "upToOne") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (grind) nil nil) ("5" (hide 1) (("5" (typepred "i") (("5" (use "binsert_tk_interval_length") (("5" (flatten) (("5" (replaces -1) (("5" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("6" (typepred "i") (("6" (use "binsert_tk_interval_length") (("6" (flatten) (("6" (replaces -1) (("6" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) (("4" (expand "PartialERforK?") (("4" (flatten) (("4" (hide -1 -2 -3) (("4" (expand "binsert_tk_interval") (("4" (expand "finseq_appl") (("4" (expand "is_sorted?") (("4" (skeep) (("4" (assert) (("4" (expand "insert?") (("4" (lift-if) (("4" (prop) (("1" (expand "finseq_appl") (("1" (reveal -3) (("1" (inst -1 "0") (("1" (expand "finseq_appl") (("1" (expand "nstruct?") (("1" (flatten) (("1" (inst -2 "0") (("1" (expand "nth") (("1" (flatten) (("1" (expand "removeSon") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "removeSon") (("2" (assert) (("2" (inst -2 "i-1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (PartialERforK? const-decl "bool" ford_johnson nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (upto nonempty-type-eq-decl nil nat_types nil) (/= const-decl "boolean" notequal nil) (odd? const-decl "bool" integers nil) (both_sides_minus_lt1 formula-decl nil real_props nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (i skolem-const-decl "below[length(cdr(smallerones(s`seqfj`seq(indx`seq(0)))))]" ford_johnson nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (i skolem-const-decl "{i: below[length(indx)] | (i <= t(1) OR i > t(1))}" ford_johnson nil) (j skolem-const-decl "below[length(binsert_tk_interval(s, 1, t(1), n, indx)`1`seqfj)]" ford_johnson nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil nat_types nil) (is_indx? const-decl "bool" ford_johnson nil) (int_plus_int_is_int application-judgement "int" integers nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (length def-decl "nat" list_props nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (indx skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND (is_indx?(s`seqfj, indx)) AND indx`seq(0) = 0}" ford_johnson nil) (nth def-decl "T" list_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (insert? const-decl "finseq" seq_extras structures) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (i skolem-const-decl "{i: below[length(indx)] | (i <= t(1) OR i > t(1))}" ford_johnson nil) (n skolem-const-decl "posnat" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (posnat_expt application-judgement "posnat" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (^ const-decl "real" exponentiation nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (expt def-decl "real" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (i skolem-const-decl "below[length(smallerones(removeSon(s`seqfj, indx`seq(0))`seq(0)))]" ford_johnson nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (binsert_tk_interval def-decl "[finseqfj, finseq[nat]]" ford_johnson nil)) shostak)) (binsert_one_level_TCC1 0 (binsert_one_level_TCC1-1 nil 3730784519 ("" (subtype-tcc) nil nil) ((NOT const-decl "[bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (is_sorted? const-decl "bool" sorting_seq nil) (is_indx? const-decl "bool" ford_johnson nil)) shostak (binsert_one_level subtype "ford_johnson.indx" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), ford_johnson.is_indx?(ford_johnson.s`seqfj, indx))}"))) (binsert_one_level_TCC2 0 (binsert_one_level_TCC2-1 nil 3730784519 ("" (skeep) (("" (split) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (expand "min") (("3" (prop) (("3" (lift-if) (("3" (prop) (("1" (typepred "maxk(indx`length)") (("1" (lemma "t_is_increasing") (("1" (case-replace " k = maxk(indx`length)") (("1" (assert) nil nil) ("2" (inst -1 "k-1" "maxk(indx`length) - 1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "k-1" "k") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "min") (("4" (lift-if) (("4" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (t_is_increasing formula-decl nil ford_johnson nil) (k skolem-const-decl "posnat" ford_johnson nil) (indx skolem-const-decl "finseq[nat]" ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil)) shostak (binsert_one_level subtype "real_defs.min(ford_johnson.t(ford_johnson.k), (number_fields.-)(length(ford_johnson.indx), 1))" "{pos: nat_types[length(ford_johnson.indx)].below | booleans.AND((booleans.OR(ford_johnson.k = 1, reals.<=(ford_johnson.t((number_fields.-)(ford_johnson.k, 1)), pos))), reals.<=(pos, ford_johnson.t(ford_johnson.k)))}"))) (binsert_one_level_TCC3 0 (binsert_one_level_TCC3-1 nil 3730784519 ("" (termination-tcc) nil nil) nil shostak (binsert_one_level subtype "ford_johnson.indx`length" "posnat"))) (binsert_one_level_TCC4 0 (binsert_one_level_TCC4-1 nil 3730784519 ("" (subtype-tcc) nil nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil)) shostak (binsert_one_level subtype "(number_fields.-)((number_fields.+)(ford_johnson.maxk(ford_johnson.indx`length), 1), ford_johnson.k)" "naturalnumber"))) (binsert_one_level_TCC5 0 (binsert_one_level_TCC5-1 nil 3730784519 ("" (termination-tcc) nil nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (binsert_one_level subtype "ford_johnson.z`4`length" "posnat"))) (binsert_one_level_TCC6 0 (binsert_one_level_TCC6-1 nil 3730784519 ("" (skeep) (("" (skeep) (("" (lemma "binsert_tk_interval_length") (("" (inst -1 "k" "t(k)" "s" "ncycles" "indx") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (below type-eq-decl nil nat_types nil) (is_indx? const-decl "bool" ford_johnson nil) (< const-decl "bool" reals nil) (PartialERforK? const-decl "bool" ford_johnson nil) (above nonempty-type-eq-decl nil integers nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (binsert_tk_interval_length formula-decl nil ford_johnson nil)) shostak (binsert_one_level subtype "ford_johnson.sk`1" "{s: firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].finseqfj | reals.>(length(s`seqfj), 0)}"))) (binsert_one_level_TCC7 0 (binsert_one_level_TCC7-1 nil 3730784519 ("" (skeep) (("" (skeep) (("" (split) (("1" (typepred "indx") (("1" (hide -2 -3 -4 -5 -6) (("1" (lemma "binsert_tk_interval_length") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "binsert_tk_interval_preserves_indx") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil) ("3" (typepred "indx") (("3" (hide -1 -2 -4 -5) (("3" (lemma "binsert_tk_interval_length") (("3" (inst?) (("3" (flatten) (("3" (assert) (("3" (prop) (("1" (postpone) nil nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (lemma "PartialERforK_equiv") (("4" (inst?) (("1" (split) (("1" (propax) nil nil) ("2" (lemma "up_partialER") (("2" (inst?) (("1" (assert) nil nil) ("2" (case-replace "k=1") (("1" (assert) (("1" (lemma "basis_PartialERforK_equiv") (("1" (inst?) (("1" (assert) (("1" (typepred "indx") (("1" (replaces -7) (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "indx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (hide -1 2 3 4) (("1" (typepred "indx") (("1" (hide -2 -3 -4 -5) (("1" (lemma "binsert_tk_interval_length") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 4) (("2" (typepred "indx") (("2" (hide -1 -3 -4 -5 -7) (("2" (lemma "binsert_tk_interval_preserves_indx") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2 3 4) (("3" (typepred "indx") (("3" (hide -1 -2 -4 -5) (("3" (lemma "binsert_tk_interval_length") (("3" (inst?) (("3" (assert) (("3" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case-replace "k=1") (("1" (assert) (("1" (hide -2 1 3 4) (("1" (lemma "basis_PartialERforK_equiv") (("1" (inst?) (("1" (split) (("1" (beta) (("1" (replaces) nil nil)) nil) ("2" (typepred "indx") (("2" (hide -1 -2 -3 -5 2) (("2" (replaces) (("2" (expand "min") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "indx") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("5" (lemma "binsert_tk_interval_preserves_oddList") (("5" (inst?) (("5" (replaces) (("5" (typepred "indx") (("5" (hide-all-but (-5 -7 1)) (("5" (expand "oddNstructPreservation?") (("5" (replace -2) (("5" (flatten) (("5" (split) (("1" (skeep) (("1" (inst? -1) (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (inst? -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (assert) nil nil)) nil)) nil)) nil) ((binsert_tk_interval_preserves_oddList formula-decl nil ford_johnson nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (binsert_tk_interval def-decl "[finseqfj, finseq[nat]]" ford_johnson nil) (length def-decl "nat" list_props nil) (i skolem-const-decl "below[length(binsert_tk_interval(s, k, t(k), ncycles, indx)`1`oddList)]" ford_johnson nil) (PartialERforK_equiv formula-decl nil ford_johnson nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (ncycles skolem-const-decl "posnat" ford_johnson nil) (indx skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    (is_indx?(s`seqfj, indx) AND
      k <= maxk(indx`length) AND
       PartialERforK?(s, indx, k, min(t(k), length(indx) - 1), ncycles) AND
        oddNstructPreservation?(s, ncycles) AND (k = 1 => indx`seq(0) = 0))}" ford_johnson nil) (TRUE const-decl "bool" booleans nil) (basis_PartialERforK_equiv formula-decl nil ford_johnson nil) (up_partialER formula-decl nil ford_johnson nil) (above nonempty-type-eq-decl nil int_types nil) (sk skolem-const-decl "[finseqfj[T, leq], finseq[nat]]" ford_johnson nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (k skolem-const-decl "posnat" ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (binsert_tk_interval_preserves_indx formula-decl nil ford_johnson nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (PartialERforK? const-decl "bool" ford_johnson nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (binsert_tk_interval_length formula-decl nil ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (binsert_one_level subtype "ford_johnson.sk`2" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), (booleans.AND(ford_johnson.is_indx?(ford_johnson.sk`1`seqfj, indx), booleans.AND(reals.<=((number_fields.+)(1, ford_johnson.k), ford_johnson.maxk(indx`length)), booleans.AND(ford_johnson.PartialERforK?(ford_johnson.sk`1, indx, (number_fields.+)(1, ford_johnson.k), real_defs.min(ford_johnson.t((number_fields.+)(1, ford_johnson.k)), (number_fields.-)(length(indx), 1)), ford_johnson.ncycles), booleans.AND(ford_johnson.oddNstructPreservation?(ford_johnson.sk`1, ford_johnson.ncycles), (booleans.=>(ford_johnson.k = 0, indx`seq(0) = 0))))))))}"))) (binsert_one_level_TCC8 0 (binsert_one_level_TCC8-1 nil 3730784519 ("" (skeep) (("" (skeep) (("" (lemma "binsert_tk_interval_length") (("" (inst -1 "k" "t(k)" "s" "ncycles" "indx") (("" (flatten) (("" (replaces) (("" (replaces) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (<= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (below type-eq-decl nil nat_types nil) (is_indx? const-decl "bool" ford_johnson nil) (< const-decl "bool" reals nil) (PartialERforK? const-decl "bool" ford_johnson nil) (above nonempty-type-eq-decl nil integers nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (binsert_tk_interval_length formula-decl nil ford_johnson nil)) shostak (binsert_one_level termination "ford_johnson.binsert_one_level(ford_johnson.sk`1, (number_fields.+)(ford_johnson.k, 1), ford_johnson.ncycles, ford_johnson.sk`2)" "nil"))) (binsert_one_level_TCC9 0 (binsert_one_level_TCC9-1 nil 3731959656 ("" (skeep) (("" (assert) (("" (flatten) (("" (lemma "t_is_increasing") (("" (inst -1 "k-1" "k") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (t_is_increasing formula-decl nil ford_johnson nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (k skolem-const-decl "posnat" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (binsert_one_level subtype "ford_johnson.t(ford_johnson.k)" "{pos: naturalnumbers.nat | booleans.AND((booleans.OR(ford_johnson.k = 1, reals.<=(ford_johnson.t((number_fields.-)(ford_johnson.k, 1)), pos))), reals.<=(pos, ford_johnson.t(ford_johnson.k)))}"))) (binsert_one_level_TCC10 0 (binsert_one_level_TCC10-1 nil 3734997215 ("" (skeep) (("" (split) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (propax) nil nil) ("4" (typepred "indx") (("4" (expand "min") (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (<= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (PartialERforK? const-decl "bool" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil)) nil (binsert_one_level subtype "ford_johnson.indx" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), booleans.AND(ford_johnson.is_indx?(ford_johnson.s`seqfj, indx), booleans.AND(reals.<(ford_johnson.t(ford_johnson.k), length(indx)), ford_johnson.PartialERforK?(ford_johnson.s, indx, ford_johnson.k, ford_johnson.t(ford_johnson.k), ford_johnson.ncycles))))}"))) (binsert_one_level_TCC11 0 (binsert_one_level_TCC11-1 nil 3734997215 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (is_indx? const-decl "bool" ford_johnson nil) (<= const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (PartialERforK? const-decl "bool" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (restrict const-decl "R" restrict nil) (is_sorted? const-decl "bool" sorting_seq nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (/= const-decl "boolean" notequal nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)) nil (binsert_one_level subtype "ford_johnson.s`oddList" "(list_adt[fjnode_adt[ford_johnson.T].fjnode].cons?)"))) (binsert_one_level_TCC12 0 (binsert_one_level_TCC12-1 nil 3734997215 ("" (subtype-tcc) nil nil) ((posnat_expt application-judgement "posnat" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (/= const-decl "boolean" notequal nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (^ const-decl "real" exponentiation nil)) nil (binsert_one_level subtype "0" "below[length(s`seqfj)]"))) (binsert_one_level_TCC13 0 (binsert_one_level_TCC13-1 nil 3734997215 ("" (termination-tcc) nil nil) ((posnat_expt application-judgement "posnat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (/= const-decl "boolean" notequal nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil)) nil (binsert_one_level subtype "(number_fields.-)(length(ford_johnson.s`seqfj), 1)" "{j: nat_types[length(ford_johnson.s`seqfj)].below | reals.<=(0, j)}"))) (binsert_one_level_TCC14 0 (binsert_one_level_TCC14-1 nil 3735562407 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (is_indx? const-decl "bool" ford_johnson nil) (<= const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (PartialERforK? const-decl "bool" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (restrict const-decl "R" restrict nil) (is_sorted? const-decl "bool" sorting_seq nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (upto nonempty-type-eq-decl nil nat_types nil) (^ const-decl "real" exponentiation nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (/= const-decl "boolean" notequal nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (insert? const-decl "finseq" seq_extras structures) (upToOne const-decl "finseq[nat]" ford_johnson nil) (posnat_expt application-judgement "posnat" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)) nil (binsert_one_level subtype "ford_johnson.s1" "{s: firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].finseqfj | reals.>(length(s`seqfj), 0)}"))) (binsert_one_level_TCC15 0 (binsert_one_level_TCC15-1 nil 3735562407 ("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (split) (("1" (replaces -5) (("1" (expand "upToOne") (("1" (assert) nil nil)) nil)) nil) ("2" (replaces -5) (("2" (expand "upToOne") (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil) ("3" (assert) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (rat_plus_rat_is_rat application-judgement "rat" rationals nil) (posrat_exp application-judgement "posrat" exponentiation nil) (rat_exp application-judgement "rat" exponentiation nil) (insert? const-decl "finseq" seq_extras structures) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (length def-decl "nat" list_props nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (upToOne const-decl "finseq[nat]" ford_johnson nil)) nil (binsert_one_level subtype "(number_fields.-)(length(ford_johnson.indx), 1)" "{pos: naturalnumbers.nat | booleans.AND((booleans.OR(ford_johnson.k = 1, reals.<=(ford_johnson.t((number_fields.-)(ford_johnson.k, 1)), pos))), reals.<=(pos, ford_johnson.t(ford_johnson.k)))}"))) (binsert_one_level_TCC16 0 (binsert_one_level_TCC16-1 nil 3735562407 ("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (skeep) (("" (assert) (("" (split) (("1" (typepred "indx") (("1" (hide-all-but (-1 -11 1)) (("1" (replaces) (("1" (expand "upToOne") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "upToOnePreservesIndx") (("2" (inst -1 "s`seqfj" "indx" "b" "searchIndx") (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "insertCarPreservesPartialERforK") (("3" (inst -1 "s" "ncycles" "indx") (("1" (beta) (("1" (split) (("1" (replaces) (("1" (case "k = maxk(indx`length) and length
                                    (upToOne(indx,
                                             bin_search(s`seqfj)
                                                       (car(s`oddList))
                                                       (0, length(s`seqfj) - 1))) = length(indx)") (("1" (flatten) (("1" (replaces) nil nil)) nil) ("2" (hide -1 2) (("2" (split) (("1" (typepred "maxk(indx`length)") (("1" (lemma "t_is_increasing") (("1" (inst -1 "k" "maxk(indx`length)-1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3 -4 -5 2) (("2" (typepred "indx") (("2" (hide -1 -2 -3 -4) (("2" (expand "oddNstructPreservation?") (("2" (flatten) (("2" (inst -1 "0") (("2" (hide -2) (("2" (skeep) (("2" (expand "nth") (("2" (typepred "m") (("2" (case-replace "m =  ncycles -1") (("2" (assert) (("2" (expand "nstruct?") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "k = maxk(indx`length)") (("1" (typepred "indx") (("1" (replaces) nil nil)) nil) ("2" (hide -1 -2 -3 -4 -5 3) (("2" (typepred "maxk(indx`length)") (("2" (lemma "t_is_increasing") (("2" (inst -1 "k" "maxk(indx`length)-1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((upToOne const-decl "finseq[nat]" ford_johnson nil) (TRUE const-decl "bool" booleans nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (<= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (PartialERforK? const-decl "bool" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (upToOnePreservesIndx formula-decl nil ford_johnson nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (indx skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    (is_indx?(s`seqfj, indx) AND
      k <= maxk(indx`length) AND
       PartialERforK?(s, indx, k, min(t(k), length(indx) - 1), ncycles) AND
        oddNstructPreservation?(s, ncycles) AND (k = 1 => indx`seq(0) = 0))}" ford_johnson nil) (ncycles skolem-const-decl "posnat" ford_johnson nil) (k skolem-const-decl "posnat" ford_johnson nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (t_is_increasing formula-decl nil ford_johnson nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (int_plus_int_is_int application-judgement "int" integers nil) (nth def-decl "T" list_props nil) (insertCarPreservesPartialERforK formula-decl nil ford_johnson nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (binsert_one_level subtype "ford_johnson.indx" "{indx_1: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx_1), 0), booleans.AND(ford_johnson.is_indx?(ford_johnson.s1`seqfj, indx_1), booleans.AND(reals.<((number_fields.-)(length(ford_johnson.indx), 1), length(indx_1)), ford_johnson.PartialERforK?(ford_johnson.s1, indx_1, ford_johnson.k, (number_fields.-)(length(ford_johnson.indx), 1), ford_johnson.ncycles))))}"))) (binsert_one_level_TCC17 0 (binsert_one_level_TCC17-1 nil 3735624353 ("" (skeep) (("" (assert) nil nil)) nil) ((listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (binsert_one_level subtype "(number_fields.-)(length(ford_johnson.indx), 1)" "{pos: naturalnumbers.nat | booleans.AND((booleans.OR(ford_johnson.k = 1, reals.<=(ford_johnson.t((number_fields.-)(ford_johnson.k, 1)), pos))), reals.<=(pos, ford_johnson.t(ford_johnson.k)))}"))) (binsert_one_level_TCC18 0 (binsert_one_level_TCC18-1 nil 3735630921 ("" (skeep) (("" (split) (("1" (assert) (("1" (typepred "indx") (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "indx") (("2" (expand "min") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((oddNstructPreservation? const-decl "bool" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (PartialERforK? const-decl "bool" ford_johnson nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (is_indx? const-decl "bool" ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (binsert_one_level subtype "ford_johnson.indx" "{indx_1: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx_1), 0), booleans.AND(ford_johnson.is_indx?(ford_johnson.s`seqfj, indx_1), booleans.AND(reals.<((number_fields.-)(length(ford_johnson.indx), 1), length(indx_1)), ford_johnson.PartialERforK?(ford_johnson.s, indx_1, ford_johnson.k, (number_fields.-)(length(ford_johnson.indx), 1), ford_johnson.ncycles))))}"))) (binsert_one_level_length_TCC1 0 (binsert_one_level_length_TCC1-1 nil 3772380276 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (binsert_one_level_length subtype "0" "below[indx`length]"))) (binsert_one_level_length_TCC2 0 (binsert_one_level_length_TCC2-1 nil 3772380276 ("" (subtype-tcc) nil nil) nil nil (binsert_one_level_length subtype "ford_johnson.s`seqfj" "{s: finite_sequences[fjnode_adt[ford_johnson.T].fjnode].finseq | reals.>(length(s), 0)}"))) (binsert_one_level_length_TCC3 0 (binsert_one_level_length_TCC3-1 nil 3772380276 ("" (skeep) (("" (case "t(k)> length(indx) - 1") (("1" (expand "min") (("1" (assert) (("1" (typepred "indx") (("1" (typepred "maxk(indx`length)") (("1" (lemma "t_is_increasing") (("1" (inst -1 "k-1" "maxk(indx`length)-1") (("1" (flatten) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (assert) (("2" (hide -1 1) (("2" (lemma "t_is_increasing") (("2" (inst -1 "k-1" "k") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((= const-decl "[T, T -> boolean]" equalities nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (< const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (binsert_one_level_length subtype "ford_johnson.indx" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), ford_johnson.is_indx?(ford_johnson.s`seqfj, indx))}"))) (binsert_one_level_length_TCC4 0 (binsert_one_level_length_TCC4-1 nil 3772380276 ("" (skeep) (("" (ground) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (lift-if) (("2" (prop) (("1" (typepred "indx") (("1" (typepred "maxk(indx`length)") (("1" (lemma "t_is_increasing") (("1" (inst -1 "k-1" "maxk(indx`length) -1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "k-1" "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (= const-decl "[T, T -> boolean]" equalities nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (t_is_increasing formula-decl nil ford_johnson nil)) nil (binsert_one_level_length subtype "real_defs.min(ford_johnson.t(ford_johnson.k), (number_fields.-)(length(ford_johnson.indx), 1))" "{pos: nat_types[length(ford_johnson.indx)].below | booleans.AND((booleans.OR(ford_johnson.k = 1, reals.<=(ford_johnson.t((number_fields.-)(ford_johnson.k, 1)), pos))), reals.<=(pos, ford_johnson.t(ford_johnson.k)))}"))) (binsert_one_level_length_TCC5 0 (binsert_one_level_length_TCC5-1 nil 3782770002 ("" (skeep* :preds? t) (("" (expand "min") (("" (typepred " maxk(indx`length)") (("" (lemma "t_is_increasing") (("" (lift-if) (("" (split 1) (("1" (flatten) (("1" (assert) (("1" (flatten) (("1" (inst -2 "k-1" "maxk(indx`length) - 1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (assert) (("2" (flatten) (("2" (inst -1 "k-1" "k") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (t_is_increasing formula-decl nil ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (k skolem-const-decl "posnat" ford_johnson nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (<= const-decl "bool" reals nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (binsert_one_level_length subtype "ford_johnson.indx" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), (booleans.AND(ford_johnson.is_indx?(ford_johnson.s`seqfj, indx), booleans.AND(reals.<=(ford_johnson.k, ford_johnson.maxk(indx`length)), booleans.AND(ford_johnson.PartialERforK?(ford_johnson.s, indx, ford_johnson.k, real_defs.min(ford_johnson.t(ford_johnson.k), (number_fields.-)(length(indx), 1)), ford_johnson.n), booleans.AND(ford_johnson.oddNstructPreservation?(ford_johnson.s, ford_johnson.n), (booleans.=>(ford_johnson.k = 1, indx`seq(0) = 0))))))))}"))) (binsert_one_level_length 0 (binsert_one_level_length-1 nil 3765049782 ("" (auto-rewrite "finseq_appl") (("" (measure-induct "maxk(indx`length) + 1 - k" ("k" "indx")) (("1" (skeep) (("1" (skeep) (("1" (expand "binsert_one_level" -2) (("1" (lift-if) (("1" (prop) (("1" (hide -3) (("1" (assert) nil nil)) nil) ("2" (inst -3 "1 + x_1" "binsert_tk_interval(s,
                                            x_1,
                                            t(x_1),
                                            n,
                                            x_2)`2") (("1" (split -3) (("1" (inst -1 "binsert_tk_interval(s, x_1, t(x_1), n, x_2)`1" "n") (("1" (assert) nil nil) ("2" (hide -2) (("2" (lemma "binsert_tk_interval_preserves_indx") (("2" (inst?) (("1" (assert) (("1" (lemma "up_partialER") (("1" (inst?) (("1" (beta) (("1" (lemma "PartialERforK_equiv") (("1" (inst?) (("1" (assert) (("1" (hide -1 -2 -3) (("1" (lemma "binsert_tk_interval_preserves_oddList") (("1" (inst?) (("1" (typepred "n") (("1" (hide -3) (("1" (expand "oddNstructPreservation?" 1) (("1" (split) (("1" (skeep) (("1" (replace -4) (("1" (expand "oddNstructPreservation?") (("1" (flatten) (("1" (inst? -3) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (replace -5) (("2" (expand "oddNstructPreservation?") (("2" (flatten) (("2" (inst? -5) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "binsert_tk_interval_length") (("2" (inst?) (("2" (flatten) (("2" (assert) (("2" (replace -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (case-replace "x_1=1") (("1" (lemma "basis_PartialERforK_equiv") (("1" (inst?) (("1" (split -1) (("1" (beta) (("1" (assert) (("1" (lemma "binsert_tk_interval_preserves_oddList") (("1" (inst?) (("1" (hide -2 -4 -5) (("1" (typepred "n") (("1" (hide -2 -3) (("1" (expand "oddNstructPreservation?" 2) (("1" (split) (("1" (skeep) (("1" (replace -3) (("1" (expand "oddNstructPreservation?") (("1" (flatten) (("1" (inst?) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (replace -4) (("2" (expand "oddNstructPreservation?") (("2" (flatten) (("2" (inst? -4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (hide -2) (("2" (typepred "n") (("2" (replace -5) (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (case-replace "x_1=1") (("1" (typepred "n") (("1" (hide -1 -2) (("1" (lemma "basis_PartialERforK_equiv") (("1" (inst?) (("1" (split) (("1" (beta) (("1" (assert) (("1" (hide -1) (("1" (lemma "binsert_tk_interval_preserves_oddList") (("1" (inst?) (("1" (hide -2) (("1" (hide -4) (("1" (expand "oddNstructPreservation?" 2) (("1" (replace -1) (("1" (split) (("1" (skeep) (("1" (expand "oddNstructPreservation?") (("1" (flatten) (("1" (inst? -2) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "oddNstructPreservation?") (("2" (flatten) (("2" (inst? -4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4 2 3) (("2" (typepred "n") (("2" (replace -7) (("2" (expand "min") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -4 3) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "n") (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "t_is_increasing") (("3" (inst -1 "x_1-1" "x_1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (lemma "binsert_tk_interval_length") (("2" (inst?) (("2" (flatten) (("2" (replaces) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2) (("2" (lemma "binsert_tk_interval_length") (("2" (inst?) (("1" (flatten) (("1" (replaces) (("1" (assert) (("1" (typepred "x_2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (typepred "n") (("2" (expand "min") (("2" (propax) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "t_is_increasing") (("3" (inst -1 "x_1-1" "x_1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -3) (("3" (lemma "binsert_tk_interval_length") (("3" (inst? -1) (("1" (flatten) nil nil) ("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide -3) (("4" (lemma "binsert_tk_interval_length") (("4" (inst?) (("4" (flatten) nil nil)) nil)) nil)) nil) ("5" (hide -2) (("5" (lemma "binsert_tk_interval_length") (("5" (inst?) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (skeep) (("2" (typepred "y_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (expand "min") (("3" (lift-if) (("3" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (typepred "maxk(y_2`length)") (("3" (lemma "t_is_increasing") (("3" (inst -1 "y_1 -1" "maxk(y_2`length) -1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil) ("7" (lemma "t_is_increasing") (("7" (inst -1 "y_1 -1" "y_1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (hide -) (("6" (typepred "x`2") (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (hide -) (("7" (ground) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (lift-if) (("2" (prop) (("1" (lemma "t_is_increasing") (("1" (inst -1 "x`1 -1" "maxk(x`2`length)-1") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "x`1 -1 " "x`1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (skeep) (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep* :preds? t) (("9" (typepred "y`2") (("9" (assert) nil nil)) nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (skeep) (("10" (hide -) (("10" (ground) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (lift-if) (("2" (prop) (("1" (lemma "t_is_increasing") (("1" (inst -1 "y`1 -1" "maxk(y`2`length)-1") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "y`1 -1 " "y`1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("11" (hide 2) (("11" (skeep* :preds? t) (("11" (assert) nil nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (assert) nil nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (assert) nil nil)) nil)) nil) ("14" (hide 2) (("14" (skeep) (("14" (assert) nil nil)) nil)) nil) ("15" (hide 2) (("15" (skeep* :preds? t) nil nil)) nil) ("16" (hide 2) (("16" (skeep) (("16" (expand "min") (("16" (lift-if) (("16" (assert) (("16" (assert) (("16" (prop) (("1" (lemma "t_is_increasing") (("1" (inst -1 "k -1" "maxk(length(indx))-1") (("1" (assert) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "k -1 " "k") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("17" (hide 2) (("17" (skeep* :preds? t) nil nil)) nil) ("18" (hide 2) (("18" (skeep* :preds? t) (("18" (assert) nil nil)) nil)) nil) ("19" (grind) nil nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (measure_induction formula-decl nil measure_induction nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (<= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (= const-decl "[T, T -> boolean]" equalities nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (wf_nat formula-decl nil naturalnumbers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (is_indx? const-decl "bool" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (/= const-decl "boolean" notequal nil) (binsert_one_level def-decl "finseqfj" ford_johnson nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (insert? const-decl "finseq" seq_extras structures) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (binsert_tk_interval def-decl "[finseqfj, finseq[nat]]" ford_johnson nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (x_1 skolem-const-decl "posnat" ford_johnson nil) (x_2 skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    x_1 <= maxk(indx`length) AND (x_1 = 1 => indx`seq(0) = 0)}" ford_johnson nil) (n skolem-const-decl "{n: posnat |
   (is_indx?(s`seqfj, x_2) AND
     PartialERforK?(s, x_2, x_1, min(t(x_1), length(x_2) - 1), n) AND
      oddNstructPreservation?(s, n))}" ford_johnson nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (binsert_tk_interval_preserves_indx formula-decl nil ford_johnson nil) (t_is_increasing formula-decl nil ford_johnson nil) (above nonempty-type-eq-decl nil int_types nil) (PartialERforK_equiv formula-decl nil ford_johnson nil) (i skolem-const-decl "below[length(binsert_tk_interval(s, 1, t(1), n, x_2)`1`oddList)]" ford_johnson nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (basis_PartialERforK_equiv formula-decl nil ford_johnson nil) (binsert_tk_interval_length formula-decl nil ford_johnson nil) (binsert_tk_interval_preserves_oddList formula-decl nil ford_johnson nil) (NOT const-decl "[bool -> bool]" booleans nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (length def-decl "nat" list_props nil) (i skolem-const-decl "below[length(binsert_tk_interval(s, x_1, t(x_1), n, x_2)`1`oddList)]" ford_johnson nil) (i skolem-const-decl "below[length(binsert_tk_interval(s, 1, t(1), n, x_2)`1`oddList)]" ford_johnson nil) (up_partialER formula-decl nil ford_johnson nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (y_2 skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    y_1 <= maxk(indx`length) AND (y_1 = 1 => indx`seq(0) = 0)}" ford_johnson nil) (y_1 skolem-const-decl "posnat" ford_johnson nil) (indx skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    k <= maxk(indx`length) AND (k = 1 => indx`seq(0) = 0)}" ford_johnson nil) (k skolem-const-decl "posnat" ford_johnson nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (is_sorted? const-decl "bool" sorting_seq nil) (restrict const-decl "R" restrict nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)) shostak)) (binsert_one_level_gives_permutation 0 (binsert_one_level_gives_permutation-1 nil 3754230491 ("" (measure-induct "maxk(indx`length) + 1 - k" ("k" "indx")) (("1" (skeep) (("1" (skeep) (("1" (expand "binsert_one_level" 1) (("1" (lift-if) (("1" (prop) (("1" (hide -2) (("1" (lemma "permutation_equiv") (("1" (flatten) (("1" (inst -1 "s") nil nil)) nil)) nil)) nil) ("2" (inst -2 "1 + x_1" " binsert_tk_interval
                                          (s, x_1, t(x_1), n, x_2)`2") (("1" (split) (("1" (inst -1 " binsert_tk_interval
                                              (s, x_1, t(x_1), n, x_2)`1" "n") (("1" (lemma "binsert_tk_interval_gives_permutation") (("1" (inst -1 "x_1" "t(x_1)" "s" "n" "x_2") (("1" (lemma "permutation_equiv") (("1" (flatten) (("1" (hide -1 -2) (("1" (inst -1 "s" " binsert_tk_interval(s, x_1, t(x_1), n, x_2)`1" "binsert_one_level(binsert_tk_interval
                                                (s, x_1, t(x_1), n, x_2)`1,
                                                1 + x_1,
                                                n,
                                                binsert_tk_interval
                                                (s, x_1, t(x_1), n, x_2)`2)") (("1" (split) (("1" (propax) nil nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "binsert_tk_interval_preserves_indx") (("2" (inst -1 "x_1" "t(x_1)" "s" "n" "x_2") (("1" (assert) (("1" (lemma "up_partialER") (("1" (inst -1 "x_1" "t(x_1)" "s" "n" "x_2") (("1" (beta) (("1" (lemma "binsert_tk_interval_length") (("1" (inst -1 "x_1" "t(x_1)" "s" "n" "x_2") (("1" (flatten) (("1" (lemma "PartialERforK_equiv") (("1" (inst -1 "binsert_tk_interval(s, x_1, t(x_1), n, x_2)`1" "x_1" "n" "binsert_tk_interval(s, x_1, t(x_1), n, x_2)`2") (("1" (assert) (("1" (lemma "binsert_tk_interval_preserves_oddList") (("1" (inst -1 "x_1" "t(x_1)" "s" "n" "x_2") (("1" (expand "oddNstructPreservation?" 2) (("1" (replace -1 2) (("1" (hide -2 -3 -4 -5) (("1" (typepred "n") (("1" (hide -1 -2 -3) (("1" (expand "oddNstructPreservation?") (("1" (flatten) (("1" (split) (("1" (skeep) (("1" (inst? -1) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst? -3) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lemma "binsert_tk_interval_length") (("2" (inst -1 "x_1" "t(x_1)" "s" "n" "x_2") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (case-replace "x_1 = 1") (("1" (hide-all-but (-1 -3 -5)) (("1" (typepred "n") (("1" (expand "min") (("1" (replaces) (("1" (case-replace " t(1 - 1)  =  t(1)") (("1" (expand "binsert_tk_interval") (("1" (expand "finseq_appl") (("1" (expand "PartialERforK?") (("1" (expand "finseq_appl") (("1" (prop) (("1" (hide-all-but (-7 -11)) (("1" (inst -2 "0") (("1" (auto-rewrite "finseq_appl") (("1" (expand "insert?") (("1" (assert) (("1" (expand "upToOne") (("1" (assert) (("1" (expand "removeSon") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (reveal -7) (("1" (inst -1 "0") (("1" (expand "nstruct?") (("1" (flatten) (("1" (hide -2 -5) (("1" (expand "length" -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (typepred "n") (("2" (hide -2 -3 -4) (("2" (expand "nstruct?") (("2" (flatten) (("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case-replace "x_1=1") (("1" (hide 1 3) (("1" (lemma "basis_PartialERforK_equiv") (("1" (inst?) (("1" (split) (("1" (beta) (("1" (assert) (("1" (typepred "n") (("1" (hide-all-but (-4 1)) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "n") (("2" (replaces) (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (typepred "n") (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "t_is_increasing") (("3" (inst -1 "x_1-1" "x_1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "binsert_tk_interval_length") (("2" (inst -1 "x_1" "t(x_1)" "s" "n" "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "binsert_tk_interval_length") (("2" (inst -1 "x_1" "t(x_1)" "s" "n" "x_2") (("1" (flatten) (("1" (assert) (("1" (replaces) (("1" (typepred "x_2") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (hide 2 3) (("2" (typepred "n") (("2" (expand "min") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (lemma "t_is_increasing") (("3" (inst -1 "x_1-1" "x_1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -2) (("3" (lemma "binsert_tk_interval_gives_permutation") (("3" (inst -1 "x_1" "length(upToOne(x_2, bin_search (s`seqfj) (car(s`oddList))(0, length(s`seqfj) - 1))) - 1" "(# seqfj
                                               := insert?
                                                  (car(s`oddList),
                                                   s`seqfj,
                                                   bin_search
                                                   (s`seqfj)
                                                   (car(s`oddList))
                                                   (0, length(s`seqfj) - 1)),
                                               oddList := cdr(s`oddList) #)" "n" "upToOne(x_2,
                                             bin_search
                                             (s`seqfj)
                                             (car(s`oddList))
                                             (0, length(s`seqfj) - 1))") (("1" (lemma "permutation_equiv") (("1" (flatten) (("1" (hide -1 -2) (("1" (inst -1 "s" "(# seqfj
                               := insert?(car(s`oddList), s`seqfj,
                                          bin_search(s`seqfj)
                                                    (car(s`oddList))
                                                    (0, length(s`seqfj) - 1)),
                             oddList := cdr(s`oddList) #)" " binsert_tk_interval((# seqfj
                                                 := insert?
                                                    (car(s`oddList),
                                                     s`seqfj,
                                                     bin_search
                                                     (s`seqfj)
                                                     (car(s`oddList))
                                                     (0, length(s`seqfj) - 1)),
                                                 oddList := cdr(s`oddList) #),
                                              x_1,
                                              length
                                              (upToOne
                                               (x_2,
                                                bin_search
                                                (s`seqfj)
                                                (car(s`oddList))
                                                (0, length(s`seqfj) - 1)))
                                              -
                                              1,
                                              n,
                                              upToOne
                                              (x_2,
                                               bin_search
                                               (s`seqfj)
                                               (car(s`oddList))
                                               (0, length(s`seqfj) - 1)))`1") (("1" (assert) (("1" (hide -1 3) (("1" (expand "permutation") (("1" (skeep) (("1" (lemma "occ_in_insert") (("1" (inst -1 "s`seqfj" "car(s`oddList)" "bin_search(s`seqfj)
                                                (car(s`oddList))
                                                (0, length(s`seqfj) - 1)" "x") (("1" (replaces) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "occurrences" 1 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -2) (("4" (lemma "binsert_tk_interval_gives_permutation") (("4" (inst -1 "x_1" "length(x_2)-1" "s" "n" "x_2") nil nil)) nil)) nil) ("5" (hide -1) (("5" (lemma "binsert_tk_interval_gives_permutation") (("5" (inst -1 "x_1" "length(x_2)-1" "s" "n" "x_2") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (skeep) (("2" (typepred "y_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (ground) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (lift-if) (("2" (prop) (("1" (typepred "y_2") (("1" (typepred "maxk(y_2`length)") (("1" (lemma "t_is_increasing") (("1" (inst -1 "y_1-1" "maxk(y_2`length)-1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "y_1-1" "y_1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (skeep) nil nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (assert) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (skeep) (("6" (typepred "x`2") (("6" (assert) nil nil)) nil)) nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (ground) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (lift-if) (("2" (prop) (("1" (typepred "x`2") (("1" (typepred "maxk(x`2`length)") (("1" (lemma "t_is_increasing") (("1" (inst -1 "x`1-1" "maxk(x`2`length)-1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -) (("2" (lemma "t_is_increasing") (("2" (inst -1 "x`1 -1" "x`1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (skeep) (("8" (assert) nil nil)) nil)) nil)) nil) ("9" (skeep) (("9" (hide 2) (("9" (skeep) (("9" (typepred "y`2") (("9" (assert) nil nil)) nil)) nil)) nil)) nil) ("10" (hide 2) (("10" (skeep* :preds? t) (("10" (hide -) (("10" (ground) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (lift-if) (("2" (prop) (("1" (lemma "t_is_increasing") (("1" (inst -1 "y`1 -1" "maxk(y`2`length)-1") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "y`1 -1 " "y`1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("11" (hide 2) (("11" (skeep* :preds? t) (("11" (assert) nil nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (assert) nil nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (assert) nil nil)) nil)) nil) ("14" (hide 2) (("14" (skeep) (("14" (assert) nil nil)) nil)) nil) ("15" (hide 2) (("15" (skeep* :preds? t) nil nil)) nil) ("16" (hide 2) (("16" (skeep) (("16" (assert) (("16" (ground) (("1" (expand "min") (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (expand "min") (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (lemma "t_is_increasing") (("1" (inst -1 "k -1" "maxk(indx`length)-1") (("1" (assert) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "k -1 " "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("17" (hide 2) (("17" (skeep* :preds? t) nil nil)) nil) ("18" (hide 2) (("18" (skeep* :preds? t) (("18" (assert) nil nil)) nil)) nil) ("19" (hide 2) (("19" (grind) nil nil)) nil)) nil) ((permutation_equiv formula-decl nil firt_phase_ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (up_partialER formula-decl nil ford_johnson nil) (basis_PartialERforK_equiv formula-decl nil ford_johnson nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (PartialERforK_equiv formula-decl nil ford_johnson nil) (TRUE const-decl "bool" booleans nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (insert? const-decl "finseq" seq_extras structures) (removeSon const-decl "finseq[fjnode[T]]" ford_johnson nil) (int_plus_int_is_int application-judgement "int" integers nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (length def-decl "nat" list_props nil) (i skolem-const-decl "below[length(binsert_tk_interval(s, x_1, t(x_1), n, x_2)`1`oddList)]" ford_johnson nil) (binsert_tk_interval_preserves_oddList formula-decl nil ford_johnson nil) (binsert_tk_interval_length formula-decl nil ford_johnson nil) (above nonempty-type-eq-decl nil int_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (t_is_increasing formula-decl nil ford_johnson nil) (binsert_tk_interval_preserves_indx formula-decl nil ford_johnson nil) (binsert_tk_interval_gives_permutation formula-decl nil ford_johnson nil) (n skolem-const-decl "{n: posnat |
   (is_indx?(s`seqfj, x_2) AND
     PartialERforK?(s, x_2, x_1, min(t(x_1), length(x_2) - 1), n) AND
      oddNstructPreservation?(s, n))}" ford_johnson nil) (x_2 skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    x_1 <= maxk(indx`length) AND (x_1 = 1 => indx`seq(0) = 0)}" ford_johnson nil) (x_1 skolem-const-decl "posnat" ford_johnson nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (binsert_tk_interval def-decl "[finseqfj, finseq[nat]]" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (occ_in_insert formula-decl nil ford_johnson nil) (map def-decl "nat" firt_phase_ford_johnson nil) (occurrences const-decl "nat" firt_phase_ford_johnson nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (upto nonempty-type-eq-decl nil nat_types nil) (binsert_one_level def-decl "finseqfj" ford_johnson nil) (permutation const-decl "bool" firt_phase_ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (is_indx? const-decl "bool" ford_johnson nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (wf_nat formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (measure_induction formula-decl nil measure_induction nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (binsert_one_level_go_to_nstruct_TCC1 0 (binsert_one_level_go_to_nstruct_TCC1-1 nil 3759013780 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (lemma "binsert_one_level_length") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (finseq type-eq-decl nil finite_sequences nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (< const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (is_indx? const-decl "bool" ford_johnson nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (PartialERforK? const-decl "bool" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (binsert_one_level_length formula-decl nil ford_johnson nil)) nil (binsert_one_level_go_to_nstruct subtype "ford_johnson.sk" "{s: firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].finseqfj | reals.>(length(s`seqfj), 0)}"))) (binsert_one_level_go_to_nstruct_TCC2 0 (binsert_one_level_go_to_nstruct_TCC2-1 nil 3772220942 ("" (subtype-tcc) nil nil) nil nil (binsert_one_level_go_to_nstruct subtype "(number_fields.-)(ford_johnson.n, 1)" "nat"))) (binsert_one_level_go_to_nstruct 0 (binsert_one_level_go_to_nstruct-2 nil 3797365604 ("" (measure-induct "maxk(indx`length) - k + 1" ("k" "indx")) (("1" (skeep) (("1" (skeep) (("1" (expand "binsert_one_level" 1) (("1" (lift-if) (("1" (prop) (("1" (hide -2) (("1" (case "x_1 = 1") (("1" (replaces) (("1" (hide 1) (("1" (typepred "x_2") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "x_2") (("2" (typepred "maxk(x_2`length)") (("2" (lemma "t_is_increasing") (("2" (inst -1 "x_1 - 1" "maxk(x_2`length)-1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "x_1 + 1" "binsert_tk_interval
                                                           (s, x_1, t(x_1), n, x_2)`2") (("1" (case "binsert_tk_interval(s, x_1, t(x_1), n, x_2)`2`length = length(x_2)") (("1" (assert) (("1" (inst?) (("1" (prop) (("1" (lemma "binsert_tk_interval_preserves_indx") (("1" (inst -1 "x_1" "t(x_1)" "s" "n" "x_2") nil nil)) nil) ("2" (case-replace "x_1=1") (("1" (lemma "basis_PartialERforK_equiv") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (typepred "n") (("1" (replaces) (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "up_partialER") (("2" (inst?) (("1" (lemma "PartialERforK_equiv") (("1" (inst?) (("1" (assert) nil nil) ("2" (hide 3) (("2" (lemma "binsert_tk_interval_preserves_indx") (("2" (inst?) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "binsert_tk_interval_preserves_oddList") (("3" (inst?) (("3" (typepred "n") (("3" (hide -2 -3) (("3" (expand "oddNstructPreservation?" +) (("3" (replace -3) (("3" (expand "oddNstructPreservation?") (("3" (flatten) (("3" (split +) (("1" (skeep) (("1" (inst?) (("1" (typepred "i") (("1" (replaces) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide -3) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "binsert_tk_interval_length") (("2" (inst -1 "x_1" "t(x_1)" "s" "n" "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "binsert_tk_interval_length") (("2" (inst -1 "x_1" "t(x_1)" "s" "n" "x_2") (("2" (flatten) (("2" (replaces) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (name-replace "sk" "(# seqfj
                                                              := insert?
                                                                 (car(s`oddList),
                                                                  s`seqfj,
                                                                  bin_search
                                                                  (s`seqfj)
                                                                  (car(s`oddList))
                                                                  (0, length(s`seqfj) - 1)),
                                                              oddList := cdr(s`oddList) #)") (("3" (hide -2) (("3" (lemma "up_partialER") (("3" (inst -1 "x_1" " length
                                                             (upToOne
                                                              (x_2,
                                                               bin_search
                                                               (s`seqfj)
                                                               (car(s`oddList))
                                                               (0, length(s`seqfj) - 1))) - 1" "sk" "n" "upToOne
                                                             (x_2,
                                                              bin_search
                                                              (s`seqfj)
                                                              (car(s`oddList))
                                                              (0, length(s`seqfj) - 1))") (("1" (case-replace "x_1=1") (("1" (hide-all-but (3 4)) (("1" (grind) nil nil)) nil) ("2" (lemma "PartialERforK_equiv") (("2" (beta) (("2" (name-replace "sk_1" " binsert_tk_interval(sk, x_1,
                                                              length
                                                                (upToOne(x_2,
                                                                         bin_search
                                                                         (s`seqfj)
                                                                         (car(s`oddList))
                                                                         (0, length(s`seqfj) - 1)))
                                                               - 1,
                                                              n,
                                                              upToOne(x_2,
                                                                      bin_search
                                                                      (s`seqfj)
                                                                      (car(s`oddList))
                                                                      (0, length(s`seqfj) - 1)))
                                     ") (("1" (inst -1 "sk_1`1" "x_1" "n" "sk_1`2") (("1" (assert) (("1" (hide -2) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (expand "nstructER_basic?") (("1" (split) (("1" (skeep) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -3 -4) (("1" (assert) (("1" (inst -2 "i") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (skeep) (("1" (typepred "i_1") (("1" (hide-all-but (-1 -2 4)) (("1" (case-replace "length(sk_1`2) = length(x_2) - 1") (("1" (assert) nil nil) ("2" (lemma "binsert_tk_interval_length") (("2" (expand "sk_1") (("2" (inst? -1) (("1" (flatten) (("1" (replaces) (("1" (expand "upToOne") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (hide -2 -3 -6) (("2" (expand "sk_1" 1) (("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (inst?) (("1" (expand "oddNstructPreservation?") (("1" (replaces) (("1" (prop) (("1" (skeep) (("1" (expand "sk") (("1" (inst -2 "i+1") (("1" (skeep) (("1" (inst 1 "m") (("1" (expand "nth" -2) (("1" (propax) nil nil)) nil) ("2" (typepred "m") (("2" (expand "nth" -3) (("2" (inst -4 "i+1" "0") (("1" (assert) (("1" (expand "nth" -4) (("1" (replaces) (("1" (expand "nstruct?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (reveal -3) (("2" (replaces) (("2" (expand "sk") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (reveal -2) (("2" (replaces) (("2" (expand "sk") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "sk") (("2" (hide -3) (("2" (inst -3 " i+1" "j+1") (("1" (expand "nth" -3) (("1" (assert) nil nil)) nil) ("2" (typepred "j") (("2" (reveal -3) (("2" (replaces) (("2" (expand "sk") (("2" (hide-all-but (-1 1 4)) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "i") (("3" (hide-all-but (-1 1 4)) (("3" (reveal -7) (("3" (replaces) (("3" (expand "sk") (("3" (expand "length" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) nil nil)) nil)) nil)) nil) ("2" (case-replace "length(sk_1`2)  = length(x_2) ") (("1" (lemma "t_is_increasing") (("1" (inst -1 "x_1" "x_1 + 1") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "binsert_tk_interval_length") (("2" (expand "sk_1" 1) (("2" (inst? -1) (("1" (flatten) (("1" (replaces) (("1" (expand "upToOne") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (hide -1 4) (("1" (lemma "binsert_tk_interval_length") (("1" (expand "sk_1") (("1" (inst? -1) (("1" (flatten) (("1" (replaces) (("1" (expand "upToOne") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "binsert_tk_interval_preserves_indx") (("2" (hide -2 4) (("2" (expand "sk_1" 1) (("2" (inst? -1) (("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "length(sk_1`2) = length(x_2)") (("1" (replace -1) (("1" (expand "nstructER_basic?") (("1" (split) (("1" (skeep) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -3 -4 -5) (("1" (expand "finseq_appl") (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (typepred "i_1") (("1" (replace -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (expand "sk_1" 1) (("2" (inst? -1) (("1" (typepred "n") (("1" (hide -1 -2 -3) (("1" (expand "oddNstructPreservation?") (("1" (replaces) (("1" (prop) (("1" (skeep) (("1" (expand "sk") (("1" (inst -1 "i+1") (("1" (skeep) (("1" (inst 1 "m") (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil) ("2" (inst -2 "i+1" "0") (("1" (expand "nth") (("1" (replaces) (("1" (expand "nstruct?") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (hide -1 -2 2) (("2" (typepred "i") (("2" (reveal -5) (("2" (replaces) (("2" (expand "sk") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide -2) (("2" (inst -2 "i+1" "j+1") (("1" (assert) (("1" (expand "nth" -2) (("1" (expand "sk") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (hide-all-but (-1 1 5)) (("2" (reveal -7) (("2" (replaces) (("2" (expand "sk") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "i") (("3" (hide-all-but (-1 1 5)) (("3" (reveal -7) (("3" (replaces) (("3" (expand "sk") (("3" (expand "length" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 5) (("2" (hide 2) (("2" (expand "sk_1") (("2" (lemma "binsert_tk_interval_length") (("2" (inst? -1) (("1" (flatten) (("1" (replaces) (("1" (expand "upToOne") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil) ("3" (case-replace "x_1 =1") (("1" (assert) (("1" (hide -2 2 3) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -2) (("4" (case-replace "x_1 = 1") (("1" (hide-all-but (2 3)) (("1" (grind) nil nil)) nil) ("2" (lemma "up_partialER") (("2" (inst -1 "x_1" "length(x_2)-1" "s" "n" "x_2") (("1" (beta) (("1" (lemma "PartialERforK_equiv") (("1" (name-replace "sk" "binsert_tk_interval(s,
                                                                     x_1,
                                                                     length(x_2) - 1,
                                                                     n,
                                                                     x_2)") (("1" (inst -1 "sk`1" "x_1" "n" "sk`2") (("1" (assert) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (hide -3) (("1" (expand "nstructER_basic?") (("1" (prop) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -3 -4) (("1" (skeep) (("1" (inst -2 "i") (("1" (expand "finseq_appl") (("1" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (skeep) (("2" (typepred "i_1") (("2" (assert) (("2" (lemma "binsert_tk_interval_length") (("2" (expand "sk") (("2" (inst -1 "x_1" "length(x_2)-1" "s" "n" "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (expand "sk") (("2" (inst?) (("2" (expand "oddNstructPreservation?") (("2" (replace -1) (("2" (prop) (("1" (skeep) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (case "length(sk`2) = length(x_2)") (("1" (replaces) (("1" (lemma "t_is_increasing") (("1" (inst -1 "x_1" "x_1+1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "binsert_tk_interval_length") (("2" (hide 2 4 5 6) (("2" (expand "sk") (("2" (inst -1 "x_1" "length(x_2)-1" "s" "n" "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (lemma "binsert_tk_interval_length") (("1" (hide -2 3) (("1" (expand "sk") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (lemma "binsert_tk_interval_preserves_indx") (("2" (expand "sk") (("2" (inst?) nil nil)) nil)) nil)) nil) ("3" (case-replace "sk`2`length = length(x_2)") (("1" (case "x_1 =  maxk(length(x_2))") (("1" (expand "nstructER_basic?") (("1" (split) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -4 -5) (("1" (expand "finseq_appl") (("1" (skeep) (("1" (inst -3 "i") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (typepred "i_1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (expand "sk") (("2" (inst? -1) (("2" (hide-all-but (-1 -4 1)) (("2" (expand "oddNstructPreservation?") (("2" (prop) (("1" (skeep) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (lemma "binsert_tk_interval_length") (("2" (expand "sk") (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide -1) (("5" (case-replace "x_1=1") (("1" (hide-all-but (3 4)) (("1" (grind) nil nil)) nil) ("2" (lemma "up_partialER") (("2" (inst -1 "x_1" "length(x_2)-1" "s" "n" "x_2") (("1" (beta) (("1" (lemma "PartialERforK_equiv") (("1" (inst?) (("1" (assert) (("1" (hide -2) (("1" (name-replace "sk" "binsert_tk_interval(s,
                                                                 x_1,
                                                                 length(x_2) - 1,
                                                                 n,
                                                                 x_2)") (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (expand "nstructER_basic?") (("1" (prop) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -3 -4) (("1" (skeep) (("1" (expand "finseq_appl") (("1" (inst?) (("1" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (skeep) (("2" (typepred "i_1") (("2" (assert) (("2" (lemma "binsert_tk_interval_length") (("2" (hide -6 -7) (("2" (expand "sk") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (expand "sk") (("2" (inst?) (("2" (typepred "n") (("2" (hide -2 -3) (("2" (case "length(s`oddList) = 0") (("1" (expand "oddNstructPreservation?") (("1" (replace -4) (("1" (flatten) (("1" (split) (("1" (skeep) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "length(smallerones(car(s`oddList))) < n - 1") (("1" (expand "oddNstructPreservation?") (("1" (replace -4) (("1" (split) (("1" (flatten) (("1" (skeep) (("1" (inst -3 "i") (("1" (inst -4 "i" "0") (("1" (split) (("1" (skeep) (("1" (inst?) (("1" (typepred "m") (("1" (expand "nth" -2 2) (("1" (expand "nstruct?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst 2 "m") (("2" (case-replace "i=0") (("1" (expand "nth") (("1" (expand "nstruct?") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but (-1 -5 -6 1)) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "oddNstructPreservation?") (("2" (flatten) (("2" (inst -2 "0") (("1" (skeep) (("1" (expand "nth" -2) (("1" (typepred "m") (("1" (expand "nstruct?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "sk" 1) (("2" (lemma "binsert_tk_interval_length") (("2" (inst?) (("2" (flatten) (("2" (replaces) (("2" (lemma "t_is_increasing") (("2" (inst -1 "x_1" "x_1 + 1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (split) (("1" (lemma "binsert_tk_interval_length") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "binsert_tk_interval_preserves_indx") (("2" (inst?) nil nil)) nil) ("3" (lemma "binsert_tk_interval_length") (("3" (inst?) (("3" (flatten) (("3" (replaces) (("3" (hide 1) (("3" (expand "nstructER_basic?") (("3" (prop) (("1" (lemma "up_partialER") (("1" (inst?) (("1" (beta) (("1" (skeep) (("1" (reveal -1) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -4 -3) (("1" (expand "finseq_appl") (("1" (inst -2 "i") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (typepred "i_1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil) ("4" (case-replace "x_1=1") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (expand "min") (("2" (assert) (("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (inst?) (("2" (expand "oddNstructPreservation?") (("2" (replaces) (("2" (prop) (("1" (skeep) (("1" (case "length(s`oddList)=0") (("1" (reveal -1) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil) ("2" (case-replace "i=0") (("1" (inst -5 "0") (("1" (skeep) (("1" (inst 2 "m") (("1" (hide -4 -6) (("1" (expand "nth") (("1" (expand "nstruct?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (inst -4 "i") (("1" (inst -5 "i" "0") (("1" (skeep) (("1" (inst 3 "m") (("1" (assert) (("1" (expand "nth" -5 2) (("1" (expand "nstruct?") (("1" (prop) (("1" (hide -3) (("1" (replaces) (("1" (reveal -4) (("1" (inst -1 "0") (("1" (skeep) (("1" (expand "nth") (("1" (expand "nstruct?") (("1" (prop) (("1" (hide -3) (("1" (typepred "m!1") (("1" (assert) nil nil)) nil)) nil) ("2" (replaces) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (reveal -3) (("2" (inst -1 "0") (("2" (skeep) (("2" (expand "nstruct?") (("2" (assert) (("2" (expand "nth") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (typepred "i") (("3" (reveal -3) (("3" (replaces) nil nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (reveal -3) (("2" (reveal -2) (("2" (replaces) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -6 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "up_partialER") (("3" (inst?) (("1" (assert) (("1" (expand "PartialERforK?") (("1" (propax) nil nil)) nil)) nil) ("2" (case-replace "x_1=1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (skeep) (("2" (assert) (("2" (lemma "binsert_one_level_length") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (typepred "y_2") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (hide 2) (("4" (expand "min") (("4" (lift-if) (("4" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (typepred "y_2") (("3" (hide -4) (("3" (typepred "maxk(y_2`length)") (("3" (lemma "t_is_increasing") (("3" (inst -1 "y_1 - 1" "maxk(y_2`length) - 1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil) ("7" (lemma "t_is_increasing") (("7" (inst -1 "y_1-1" "y_1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (hide -) (("7" (lemma "binsert_one_level_length") (("7" (inst?) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (skeep) (("8" (hide -1 -2) (("8" (typepred "x`2") (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (skeep) (("9" (hide -1 -2) (("9" (expand "min") (("9" (lift-if) (("9" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (typepred "x`2") (("3" (typepred "maxk(x`2`length)") (("3" (lemma "t_is_increasing") (("3" (inst -1 "x`1 - 1" "maxk(x`2`length)-1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil) ("7" (lemma "t_is_increasing") (("7" (inst -1 "x`1 -1" "x`1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (skeep) (("10" (prop) (("10" (assert) nil nil)) nil)) nil)) nil)) nil) ("11" (hide 2) (("11" (skeep* :preds? t) (("11" (use "binsert_one_level_length") (("11" (assert) nil nil)) nil)) nil)) nil) ("12" (hide 2) (("12" (skeep* :preds? t) (("12" (assert) (("12" (typepred "y`2") (("12" (propax) nil nil)) nil)) nil)) nil)) nil) ("13" (hide 2) (("13" (skeep* :preds? t) (("13" (assert) (("13" (ground) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (lift-if) (("2" (prop) (("1" (lemma "t_is_increasing") (("1" (inst -1 "y`1 - 1" "maxk(y`2`length) - 1") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "y`1-1" "y`1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("14" (hide 2) (("14" (skeep) (("14" (skeep) (("14" (assert) nil nil)) nil)) nil)) nil) ("15" (hide 2) (("15" (skeep) (("15" (assert) nil nil)) nil)) nil) ("16" (hide 2) (("16" (skeep) (("16" (assert) nil nil)) nil)) nil) ("17" (hide 2) (("17" (skeep) (("17" (assert) nil nil)) nil)) nil) ("18" (hide 2) (("18" (skeep) (("18" (lemma "binsert_one_level_length") (("18" (inst?) (("18" (assert) nil nil)) nil)) nil)) nil)) nil) ("19" (hide 2) (("19" (skeep* :preds? t) nil nil)) nil) ("20" (hide 2) (("20" (skeep* :preds? t) (("20" (assert) (("20" (expand "min") (("20" (lift-if) (("20" (assert) (("20" (ground) (("1" (lemma "t_is_increasing") (("1" (inst -1 "k - 1" "maxk(indx`length) - 1") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "k - 1" "k") (("2" (assert) nil nil)) nil)) nil) ("3" (lemma "t_is_increasing") (("3" (inst -1 "k - 1" "maxk(indx`length) - 1") (("3" (assert) nil nil)) nil)) nil) ("4" (lemma "t_is_increasing") (("4" (inst -1 "k - 1" "k") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("21" (hide 2) (("21" (skeep* :preds? t) nil nil)) nil) ("22" (hide 2) (("22" (skeep* :preds? t) (("22" (assert) nil nil)) nil)) nil) ("23" (hide 2) (("23" (skeep) (("23" (assert) nil nil)) nil)) nil)) nil) ((x skolem-const-decl "[k: posnat,
 {indx: finseq[nat] |
    length(indx) > 0 AND
     k <= maxk(indx`length) AND (k = 1 => indx`seq(0) = 0)}]" ford_johnson nil) (y_1 skolem-const-decl "posnat" ford_johnson nil) (y_2 skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    y_1 <= maxk(indx`length) AND (y_1 = 1 => indx`seq(0) = 0)}" ford_johnson nil) (binsert_one_level_length formula-decl nil ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (x_1 skolem-const-decl "posnat" ford_johnson nil) (x_2 skolem-const-decl "{indx: finseq[nat] |
   length(indx) > 0 AND
    x_1 <= maxk(indx`length) AND (x_1 = 1 => indx`seq(0) = 0)}" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (t_is_increasing formula-decl nil ford_johnson nil) (binsert_tk_interval_preserves_oddList formula-decl nil ford_johnson nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (length def-decl "nat" list_props nil) (i skolem-const-decl "below[length(binsert_tk_interval(s, x_1, t(x_1), n, x_2)`1`oddList)]" ford_johnson nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (basis_PartialERforK_equiv formula-decl nil ford_johnson nil) (above nonempty-type-eq-decl nil int_types nil) (PartialERforK_equiv formula-decl nil ford_johnson nil) (up_partialER formula-decl nil ford_johnson nil) (binsert_tk_interval_preserves_indx formula-decl nil ford_johnson nil) (binsert_tk_interval_length formula-decl nil ford_johnson nil) (n skolem-const-decl "{n: posnat |
   (is_indx?(s`seqfj, x_2) AND
     PartialERforK?(s, x_2, x_1, min(t(x_1), length(x_2) - 1), n) AND
      oddNstructPreservation?(s, n))}" ford_johnson nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (binsert_tk_interval def-decl "[finseqfj, finseq[nat]]" ford_johnson nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (m skolem-const-decl "below[n]" ford_johnson nil) (i skolem-const-decl "below[length(binsert_tk_interval(sk, x_1,
                                 length
                                   (upToOne
                                    (x_2,
                                     bin_search
                                     (s`seqfj)
                                     (car(s`oddList))
                                     (0, length(s`seqfj) - 1)))
                                  - 1,
                                 n,
                                 upToOne(x_2,
                                         bin_search
                                         (s`seqfj)
                                         (car(s`oddList))
                                         (0,
                                          length(s`seqfj) - 1)))`1`oddList)]" ford_johnson nil) (j skolem-const-decl "below[length(binsert_tk_interval(sk, x_1,
                                 length
                                   (upToOne
                                    (x_2,
                                     bin_search
                                     (s`seqfj)
                                     (car(s`oddList))
                                     (0, length(s`seqfj) - 1)))
                                  - 1,
                                 n,
                                 upToOne(x_2,
                                         bin_search
                                         (s`seqfj)
                                         (car(s`oddList))
                                         (0,
                                          length(s`seqfj) - 1)))`1`oddList)]" ford_johnson nil) (i skolem-const-decl "below[length(binsert_tk_interval(sk, x_1,
                                 length
                                   (upToOne
                                    (x_2,
                                     bin_search
                                     (s`seqfj)
                                     (car(s`oddList))
                                     (0, length(s`seqfj) - 1)))
                                  - 1,
                                 n,
                                 upToOne(x_2,
                                         bin_search
                                         (s`seqfj)
                                         (car(s`oddList))
                                         (0,
                                          length(s`seqfj) - 1)))`1`oddList)]" ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (sk skolem-const-decl "[# oddList: list[fjnode[T]], seqfj: finseq[fjnode[T]] #]" ford_johnson nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (m skolem-const-decl "below[n]" ford_johnson nil) (i skolem-const-decl "below[length(binsert_tk_interval(sk, x_1,
                                 length
                                   (upToOne
                                    (x_2,
                                     bin_search
                                     (s`seqfj)
                                     (car(s`oddList))
                                     (0, length(s`seqfj) - 1)))
                                  - 1,
                                 n,
                                 upToOne(x_2,
                                         bin_search
                                         (s`seqfj)
                                         (car(s`oddList))
                                         (0,
                                          length(s`seqfj) - 1)))`1`oddList)]" ford_johnson nil) (i skolem-const-decl "below[length(binsert_tk_interval(sk, x_1,
                                 length
                                   (upToOne
                                    (x_2,
                                     bin_search
                                     (s`seqfj)
                                     (car(s`oddList))
                                     (0, length(s`seqfj) - 1)))
                                  - 1,
                                 n,
                                 upToOne(x_2,
                                         bin_search
                                         (s`seqfj)
                                         (car(s`oddList))
                                         (0,
                                          length(s`seqfj) - 1)))`1`oddList)]" ford_johnson nil) (j skolem-const-decl "below[length(binsert_tk_interval(sk, x_1,
                                 length
                                   (upToOne
                                    (x_2,
                                     bin_search
                                     (s`seqfj)
                                     (car(s`oddList))
                                     (0, length(s`seqfj) - 1)))
                                  - 1,
                                 n,
                                 upToOne(x_2,
                                         bin_search
                                         (s`seqfj)
                                         (car(s`oddList))
                                         (0,
                                          length(s`seqfj) - 1)))`1`oddList)]" ford_johnson nil) (sk_1 skolem-const-decl "[finseqfj[T, leq], finseq[nat]]" ford_johnson nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (upto nonempty-type-eq-decl nil nat_types nil) (insert? const-decl "finseq" seq_extras structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (sk skolem-const-decl "[finseqfj[T, leq], finseq[nat]]" ford_johnson nil) (i skolem-const-decl "below[length(binsert_tk_interval(s, x_1, length(x_2) - 1, n,
                                 x_2)`1`oddList)]" ford_johnson nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (is_sorted? const-decl "bool" sorting_seq nil) (restrict const-decl "R" restrict nil) (m skolem-const-decl "below[n]" ford_johnson nil) (m skolem-const-decl "below[n]" ford_johnson nil) (m skolem-const-decl "below[n]" ford_johnson nil) (m skolem-const-decl "below[n]" ford_johnson nil) (i skolem-const-decl "below[length(binsert_tk_interval(s, x_1, length(x_2) - 1, n,
                                 x_2)`1`oddList)]" ford_johnson nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (sk skolem-const-decl "[finseqfj[T, leq], finseq[nat]]" ford_johnson nil) (nstructER_basic? const-decl "bool" ford_johnson nil) (binsert_one_level def-decl "finseqfj" ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (is_indx? const-decl "bool" ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (wf_nat formula-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (measure_induction formula-decl nil measure_induction nil) (int_plus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil) (binsert_one_level_go_to_nstruct-1 nil 3759013780 ("" (measure-induct "maxk(indx`length) - k + 1" ("k" "indx")) (("1" (skeep) (("1" (skeep) (("1" (expand "binsert_one_level" 1) (("1" (lift-if) (("1" (prop) (("1" (hide -2) (("1" (case "x_1 = 1") (("1" (replaces) (("1" (hide 1) (("1" (typepred "x_2") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "x_2") (("2" (typepred "maxk(x_2`length)") (("2" (lemma "t_is_increasing") (("2" (inst -1 "x_1 - 1" "maxk(x_2`length)-1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "x_1 + 1" "binsert_tk_interval
                                                     (s, x_1, t(x_1), n, x_2)`2") (("1" (case "binsert_tk_interval(s, x_1, t(x_1), n, x_2)`2`length = length(x_2)") (("1" (assert) (("1" (split -3) (("1" (inst -1 "binsert_tk_interval (s, x_1, t(x_1), n, x_2)`1" "n") (("1" (hide 2) (("1" (split 1) (("1" (lemma "binsert_tk_interval_preserves_indx") (("1" (inst -1 "x_1" "t(x_1)" "s" "n" "x_2") nil nil)) nil) ("2" (case-replace "x_1=1") (("1" (lemma "basis_PartialERforK_equiv") (("1" (inst?) (("1" (assert) (("1" (hide 2) (("1" (typepred "n") (("1" (replaces) (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "up_partialER") (("2" (inst?) (("1" (lemma "PartialERforK_equiv") (("1" (inst?) (("1" (assert) nil nil) ("2" (hide 3) (("2" (lemma "binsert_tk_interval_preserves_indx") (("2" (inst?) nil nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("3" (lemma "binsert_tk_interval_preserves_oddList") (("3" (inst?) (("3" (typepred "n") (("3" (hide -2 -3) (("3" (expand "oddNstructPreservation?" +) (("3" (replace -3) (("3" (expand "oddNstructPreservation?") (("3" (flatten) (("3" (split +) (("1" (skeep) (("1" (inst?) (("1" (typepred "i") (("1" (replaces) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide -3) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (hide 2) (("2" (rewrite "<") nil nil)) nil)) nil)) nil)) nil) ("2" (hide - 2) (("2" (lemma "binsert_tk_interval_length") (("2" (inst -1 "x_1" "t(x_1)" "s" "n" "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "binsert_tk_interval_length") (("2" (inst -1 "x_1" "t(x_1)" "s" "n" "x_2") (("2" (flatten) (("2" (replaces) (("2" (typepred "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (name-replace "sk" "(# seqfj
                                                        := insert?
                                                           (car(s`oddList),
                                                            s`seqfj,
                                                            bin_search
                                                            (s`seqfj)
                                                            (car(s`oddList))
                                                            (0, length(s`seqfj) - 1)),
                                                        oddList := cdr(s`oddList) #)") (("3" (hide -2) (("3" (lemma "up_partialER") (("3" (inst -1 "x_1" " length
                                                       (upToOne
                                                        (x_2,
                                                         bin_search
                                                         (s`seqfj)
                                                         (car(s`oddList))
                                                         (0, length(s`seqfj) - 1))) - 1" "sk" "n" "upToOne
                                                       (x_2,
                                                        bin_search
                                                        (s`seqfj)
                                                        (car(s`oddList))
                                                        (0, length(s`seqfj) - 1))") (("1" (case-replace "x_1=1") (("1" (hide-all-but (3 4)) (("1" (grind) nil nil)) nil) ("2" (lemma "PartialERforK_equiv") (("2" (beta) (("2" (name-replace "sk_1" " binsert_tk_interval(sk, x_1,
                                                    length
                                                      (upToOne(x_2,
                                                               bin_search
                                                               (s`seqfj)
                                                               (car(s`oddList))
                                                               (0, length(s`seqfj) - 1)))
                                                     - 1,
                                                    n,
                                                    upToOne(x_2,
                                                            bin_search
                                                            (s`seqfj)
                                                            (car(s`oddList))
                                                            (0, length(s`seqfj) - 1)))
                           ") (("1" (inst -1 "sk_1`1" "x_1" "n" "sk_1`2") (("1" (assert) (("1" (hide -2) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (expand "nstructER_basic?") (("1" (split) (("1" (skeep) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -3 -4) (("1" (assert) (("1" (inst -2 "i") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (skeep) (("1" (typepred "i_1") (("1" (hide-all-but (-1 -2 4)) (("1" (case-replace "length(sk_1`2) = length(x_2) - 1") (("1" (assert) nil nil) ("2" (lemma "binsert_tk_interval_length") (("2" (expand "sk_1") (("2" (inst? -1) (("1" (flatten) (("1" (replaces) (("1" (expand "upToOne") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (hide -2 -3 -6) (("2" (expand "sk_1" 1) (("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (inst?) (("1" (expand "oddNstructPreservation?") (("1" (replaces) (("1" (prop) (("1" (skeep) (("1" (expand "sk") (("1" (inst -2 "i+1") (("1" (skeep) (("1" (inst 1 "m") (("1" (expand "nth" -2) (("1" (propax) nil nil)) nil) ("2" (typepred "m") (("2" (expand "nth" -3) (("2" (inst -4 "i+1" "0") (("1" (assert) (("1" (expand "nth" -4) (("1" (replaces) (("1" (expand "nstruct?") (("1" (assert) (("1" (prop) (("1" (replaces) (("1" (hide-all-but (-5 1)) (("1" (rewrite "<") nil nil)) nil)) nil) ("2" (replaces) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (reveal -3) (("2" (replaces) (("2" (expand "sk") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (reveal -2) (("2" (replaces) (("2" (expand "sk") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "sk") (("2" (hide -3) (("2" (inst -3 " i+1" "j+1") (("1" (expand "nth" -3) (("1" (assert) nil nil)) nil) ("2" (typepred "j") (("2" (reveal -3) (("2" (replaces) (("2" (expand "sk") (("2" (hide-all-but (-1 1 4)) (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "i") (("3" (hide-all-but (-1 1 4)) (("3" (reveal -7) (("3" (replaces) (("3" (expand "sk") (("3" (expand "length" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) nil nil)) nil)) nil)) nil) ("2" (case-replace "length(sk_1`2)  = length(x_2) ") (("1" (lemma "t_is_increasing") (("1" (inst -1 "x_1" "x_1 + 1") (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "binsert_tk_interval_length") (("2" (expand "sk_1" 1) (("2" (inst? -1) (("1" (flatten) (("1" (replaces) (("1" (expand "upToOne") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (hide -1 4) (("1" (lemma "binsert_tk_interval_length") (("1" (expand "sk_1") (("1" (inst? -1) (("1" (flatten) (("1" (replaces) (("1" (expand "upToOne") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "binsert_tk_interval_preserves_indx") (("2" (hide -2 4) (("2" (expand "sk_1" 1) (("2" (inst? -1) (("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (case "length(sk_1`2) = length(x_2)") (("1" (replace -1) (("1" (expand "nstructER_basic?") (("1" (split) (("1" (skeep) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -3 -4 -5) (("1" (expand "finseq_appl") (("1" (inst?) (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (typepred "i_1") (("1" (replace -4) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (expand "sk_1" 1) (("2" (inst? -1) (("1" (typepred "n") (("1" (hide -1 -2 -3) (("1" (expand "oddNstructPreservation?") (("1" (replaces) (("1" (prop) (("1" (skeep) (("1" (expand "sk") (("1" (inst -1 "i+1") (("1" (skeep) (("1" (inst 1 "m") (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil) ("2" (inst -2 "i+1" "0") (("1" (expand "nth") (("1" (replaces) (("1" (expand "nstruct?") (("1" (assert) (("1" (prop) (("1" (replaces) (("1" (hide-all-but (-3 1)) (("1" (rewrite "<") nil nil)) nil)) nil) ("2" (replaces) (("2" (hide -3) (("2" (hide -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (hide -1 -2 2) (("2" (typepred "i") (("2" (reveal -5) (("2" (replaces) (("2" (expand "sk") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide -2) (("2" (inst -2 "i+1" "j+1") (("1" (assert) (("1" (expand "nth" -2) (("1" (expand "sk") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (typepred "j") (("2" (hide-all-but (-1 1 5)) (("2" (reveal -7) (("2" (replaces) (("2" (expand "sk") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (typepred "i") (("3" (hide-all-but (-1 1 5)) (("3" (reveal -7) (("3" (replaces) (("3" (expand "sk") (("3" (expand "length" 1) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 5) (("2" (hide 2) (("2" (expand "sk_1") (("2" (lemma "binsert_tk_interval_length") (("2" (inst? -1) (("1" (flatten) (("1" (replaces) (("1" (expand "upToOne") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (expand "upToOne") (("2" (assert) nil nil)) nil)) nil) ("3" (case-replace "x_1 =1") (("1" (assert) (("1" (hide -2 2 3) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (hide -2) (("4" (case-replace "x_1 = 1") (("1" (hide-all-but (2 3)) (("1" (grind) nil nil)) nil) ("2" (lemma "up_partialER") (("2" (inst -1 "x_1" "length(x_2)-1" "s" "n" "x_2") (("1" (beta) (("1" (lemma "PartialERforK_equiv") (("1" (name-replace "sk" "binsert_tk_interval(s,
                                                           x_1,
                                                           length(x_2) - 1,
                                                           n,
                                                           x_2)") (("1" (inst -1 "sk`1" "x_1" "n" "sk`2") (("1" (assert) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (hide -3) (("1" (expand "nstructER_basic?") (("1" (prop) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -3 -4) (("1" (skeep) (("1" (inst -2 "i") (("1" (expand "finseq_appl") (("1" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (skeep) (("2" (typepred "i_1") (("2" (assert) (("2" (lemma "binsert_tk_interval_length") (("2" (expand "sk") (("2" (inst -1 "x_1" "length(x_2)-1" "s" "n" "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (expand "sk") (("2" (inst?) (("2" (expand "oddNstructPreservation?") (("2" (replace -1) (("2" (prop) (("1" (skeep) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (case "length(sk`2) = length(x_2)") (("1" (replaces) (("1" (lemma "t_is_increasing") (("1" (inst -1 "x_1" "x_1+1") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (lemma "binsert_tk_interval_length") (("2" (hide 2 4 5 6) (("2" (expand "sk") (("2" (inst -1 "x_1" "length(x_2)-1" "s" "n" "x_2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (lemma "binsert_tk_interval_length") (("1" (hide -2 3) (("1" (expand "sk") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (lemma "binsert_tk_interval_preserves_indx") (("2" (expand "sk") (("2" (inst?) nil nil)) nil)) nil)) nil) ("3" (case-replace "sk`2`length = length(x_2)") (("1" (case "x_1 =  maxk(length(x_2))") (("1" (expand "nstructER_basic?") (("1" (split) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -4 -5) (("1" (expand "finseq_appl") (("1" (skeep) (("1" (inst -3 "i") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (typepred "i_1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -3) (("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (expand "sk") (("2" (inst? -1) (("2" (hide-all-but (-1 -4 1)) (("2" (expand "oddNstructPreservation?") (("2" (prop) (("1" (skeep) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (flatten) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (lemma "binsert_tk_interval_length") (("2" (expand "sk") (("2" (inst? -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide -1) (("5" (case-replace "x_1=1") (("1" (hide-all-but (3 4)) (("1" (grind) nil nil)) nil) ("2" (lemma "up_partialER") (("2" (inst -1 "x_1" "length(x_2)-1" "s" "n" "x_2") (("1" (beta) (("1" (lemma "PartialERforK_equiv") (("1" (inst?) (("1" (assert) (("1" (hide -2) (("1" (name-replace "sk" "binsert_tk_interval(s,
                                                     x_1,
                                                     length(x_2) - 1,
                                                     n,
                                                     x_2)") (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (expand "nstructER_basic?") (("1" (prop) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -3 -4) (("1" (skeep) (("1" (expand "finseq_appl") (("1" (inst?) (("1" (split) (("1" (propax) nil nil) ("2" (flatten) (("2" (skeep) (("2" (typepred "i_1") (("2" (assert) (("2" (lemma "binsert_tk_interval_length") (("2" (hide -6 -7) (("2" (expand "sk") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 -2) (("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (expand "sk") (("2" (inst?) (("2" (typepred "n") (("2" (hide -2 -3) (("2" (case "length(s`oddList) = 0") (("1" (expand "oddNstructPreservation?") (("1" (replace -4) (("1" (flatten) (("1" (split) (("1" (skeep) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "length(smallerones(car(s`oddList))) < n - 1") (("1" (expand "oddNstructPreservation?") (("1" (replace -4) (("1" (split) (("1" (flatten) (("1" (skeep) (("1" (inst -3 "i") (("1" (inst -4 "i" "0") (("1" (split) (("1" (skeep) (("1" (inst?) (("1" (typepred "m") (("1" (expand "nth" -2 2) (("1" (expand "nstruct?") (("1" (assert) (("1" (flatten) (("1" (replaces) (("1" (hide-all-but (-2 -3 1)) (("1" (rewrite "<") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst 2 "m") (("2" (case-replace "i=0") (("1" (expand "nth") (("1" (expand "nstruct?") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide-all-but (-1 -5 -6 1)) (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (expand "oddNstructPreservation?") (("2" (flatten) (("2" (inst -2 "0") (("1" (skeep) (("1" (expand "nth" -2) (("1" (typepred "m") (("1" (expand "nstruct?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "PartialERforK?") (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "sk" 1) (("2" (lemma "binsert_tk_interval_length") (("2" (inst?) (("2" (flatten) (("2" (replaces) (("2" (lemma "t_is_increasing") (("2" (inst -1 "x_1" "x_1 + 1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (split) (("1" (lemma "binsert_tk_interval_length") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (lemma "binsert_tk_interval_preserves_indx") (("2" (inst?) nil nil)) nil) ("3" (lemma "binsert_tk_interval_length") (("3" (inst?) (("3" (flatten) (("3" (replaces) (("3" (hide 1) (("3" (expand "nstructER_basic?") (("3" (prop) (("1" (lemma "up_partialER") (("1" (inst?) (("1" (beta) (("1" (skeep) (("1" (reveal -1) (("1" (expand "PartialERforK?") (("1" (flatten) (("1" (hide -5 -4 -3) (("1" (expand "finseq_appl") (("1" (inst -2 "i") (("1" (assert) (("1" (flatten) (("1" (skeep) (("1" (typepred "i_1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (expand "min") (("2" (assert) nil nil)) nil)) nil) ("3" (assert) nil nil) ("4" (case-replace "x_1=1") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (expand "min") (("2" (assert) (("2" (lemma "binsert_tk_interval_preserves_oddList") (("2" (inst?) (("2" (expand "oddNstructPreservation?") (("2" (replaces) (("2" (prop) (("1" (skeep) (("1" (case "length(s`oddList)=0") (("1" (reveal -1) (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil) ("2" (case-replace "i=0") (("1" (inst -5 "0") (("1" (skeep) (("1" (inst 2 "m") (("1" (hide -4 -6) (("1" (expand "nth") (("1" (expand "nstruct?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (inst -4 "i") (("1" (inst -5 "i" "0") (("1" (skeep) (("1" (inst 3 "m") (("1" (assert) (("1" (expand "nth" -5 2) (("1" (expand "nstruct?") (("1" (prop) (("1" (hide -3) (("1" (replaces) (("1" (reveal -4) (("1" (inst -1 "0") (("1" (skeep) (("1" (expand "nth") (("1" (expand "nstruct?") (("1" (prop) (("1" (hide -3) (("1" (typepred "m!1") (("1" (assert) (("1" (replaces) (("1" (hide-all-but (-1 -7 1)) (("1" (rewrite "<") nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (hide-all-but (-1 -5)) (("2" (rewrite "<") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (reveal -3) (("2" (inst -1 "0") (("2" (skeep) (("2" (expand "nstruct?") (("2" (assert) (("2" (expand "nth") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (typepred "i") (("3" (reveal -3) (("3" (replaces) nil nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (reveal -3) (("2" (reveal -2) (("2" (replaces) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -6 "i" "j") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (lemma "up_partialER") (("3" (inst?) (("1" (assert) (("1" (expand "PartialERforK?") (("1" (propax) nil nil)) nil)) nil) ("2" (case-replace "x_1=1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (skeep) (("2" (assert) (("2" (lemma "binsert_one_level_length") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (skeep) (("3" (typepred "y_2") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (skeep) (("4" (skeep) (("4" (hide 2) (("4" (expand "min") (("4" (lift-if) (("4" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (typepred "y_2") (("3" (hide -4) (("3" (typepred "maxk(y_2`length)") (("3" (lemma "t_is_increasing") (("3" (inst -1 "y_1 - 1" "maxk(y_2`length) - 1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil) ("7" (lemma "t_is_increasing") (("7" (inst -1 "y_1-1" "y_1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (skeep) nil nil)) nil)) nil) ("6" (hide 2) (("6" (skeep) (("6" (assert) nil nil)) nil)) nil) ("7" (hide 2) (("7" (skeep) (("7" (skeep) (("7" (hide -) (("7" (lemma "binsert_one_level_length") (("7" (inst?) (("7" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("8" (hide 2) (("8" (skeep) (("8" (skeep) (("8" (hide -1 -2) (("8" (typepred "x`2") (("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("9" (hide 2) (("9" (skeep) (("9" (skeep) (("9" (hide -1 -2) (("9" (expand "min") (("9" (lift-if) (("9" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (typepred "x`2") (("3" (typepred "maxk(x`2`length)") (("3" (lemma "t_is_increasing") (("3" (inst -1 "x`1 - 1" "maxk(x`2`length)-1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil) ("7" (lemma "t_is_increasing") (("7" (inst -1 "x`1 -1" "x`1") (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("10" (hide 2) (("10" (skeep) (("10" (skeep) (("10" (prop) (("10" (assert) nil nil)) nil)) nil)) nil)) nil) ("11" (hide 2) (("11" (skeep) (("11" (skeep) (("11" (assert) nil nil)) nil)) nil)) nil) ("12" (hide 2) (("12" (skeep) (("12" (skeep) (("12" (lemma "binsert_one_level_length") (("12" (inst?) (("12" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("13" (hide 2) (("13" (skeep) (("13" (skeep) (("13" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (typepred "y`2") (("3" (typepred "maxk(y`2`length)") (("3" (lemma "t_is_increasing") (("3" (inst -1 "y`1-1" " maxk(y`2`length)-1") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("14" (hide 2) (("14" (skeep) (("14" (skeep) (("14" (assert) (("14" (ground) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (typepred "y`2") (("1" (assert) (("1" (typepred " maxk(y`2`length)") (("1" (lemma "t_is_increasing") (("1" (inst -1 "y`1 - 1" "maxk(y`2`length) - 1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "y`1-1" "y`1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("15" (hide 2) (("15" (skeep) (("15" (assert) (("15" (skeep) nil nil)) nil)) nil)) nil) ("16" (hide 2) (("16" (skeep) (("16" (assert) nil nil)) nil)) nil) ("17" (hide 2) (("17" (skeep) (("17" (assert) nil nil)) nil)) nil) ("18" (hide 2) (("18" (skeep) (("18" (lemma "binsert_one_level_length") (("18" (inst?) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("19" (hide 2) (("19" (skeep) (("19" (typepred "y`2") (("19" (assert) nil nil)) nil)) nil)) nil) ("20" (hide 2) (("20" (skeep) (("20" (assert) nil nil)) nil)) nil) ("21" (hide 2) (("21" (skeep) (("21" (assert) nil nil)) nil)) nil) ("22" (hide 2) (("22" (skeep) (("22" (assert) (("22" (replaces) (("22" (lemma "binsert_one_level_length") (("22" (inst?) (("22" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("23" (hide 2) (("23" (skeep) (("23" (assert) (("23" (typepred "indx") (("23" (assert) nil nil)) nil)) nil)) nil)) nil) ("24" (skeep) (("24" (skeep) (("24" (hide 2) (("24" (ground) (("1" (expand "min") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "min") (("2" (lift-if) (("2" (prop) (("1" (typepred "indx") (("1" (typepred " maxk(indx`length)") (("1" (lemma "t_is_increasing") (("1" (inst -1 "k-1" "maxk(indx`length) - 1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "t_is_increasing") (("2" (inst -1 "k-1" "k") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("25" (skeep) nil nil) ("26" (skeep) (("26" (hide 2) (("26" (assert) nil nil)) nil)) nil) ("27" (hide 2) (("27" (expand "well_founded?") (("27" (skeep* :preds? t) (("27" (inst -2 "p") (("27" (prop) (("1" (skeep) (("1" (inst 1 "y!1") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (ground) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("28" (hide 2) (("28" (skeep) (("28" (assert) nil nil)) nil)) nil)) nil) ((binsert_one_level_length formula-decl nil ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (int_exp application-judgement "int" exponentiation nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals nil) (^ const-decl "real" exponentiation nil) (expt def-decl "real" exponentiation nil) (NOT const-decl "[bool -> bool]" booleans nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (t_is_increasing formula-decl nil ford_johnson nil) (binsert_tk_interval_preserves_oddList formula-decl nil ford_johnson nil) (length def-decl "nat" list_props nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (basis_PartialERforK_equiv formula-decl nil ford_johnson nil) (above nonempty-type-eq-decl nil int_types nil) (PartialERforK_equiv formula-decl nil ford_johnson nil) (up_partialER formula-decl nil ford_johnson nil) (binsert_tk_interval_preserves_indx formula-decl nil ford_johnson nil) (binsert_tk_interval_length formula-decl nil ford_johnson nil) (binsert_tk_interval def-decl "[finseqfj, finseq[nat]]" ford_johnson nil) (upToOne const-decl "finseq[nat]" ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (nth def-decl "T" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (upto nonempty-type-eq-decl nil nat_types nil) (insert? const-decl "finseq" seq_extras structures) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (bin_search def-decl "upto[j + 1]" ford_johnson nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (nstructER_basic? const-decl "bool" ford_johnson nil) (binsert_one_level def-decl "finseqfj" ford_johnson nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (is_indx? const-decl "bool" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (wf_nat formula-decl nil naturalnumbers nil) (restrict const-decl "R" restrict nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (> const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseq type-eq-decl nil finite_sequences nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (posnat nonempty-type-eq-decl nil integers nil) (measure_induction formula-decl nil measure_induction nil) (reflexive_restrict application-judgement "(reflexive?[S])" restrict_order_props nil) (antisymmetric_restrict application-judgement "(antisymmetric?[S])" restrict_order_props nil) (transitive_restrict application-judgement "(transitive?[S])" restrict_order_props nil) (preorder_restrict application-judgement "(preorder?[S])" restrict_order_props nil) (partial_order_restrict application-judgement "(partial_order?[S])" restrict_order_props nil) (dichotomous_restrict application-judgement "(dichotomous?[S])" restrict_order_props nil) (total_order_restrict application-judgement "(total_order?[S])" restrict_order_props nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (nstructER_basic_equiv_TCC1 0 (nstructER_basic_equiv_TCC1-1 nil 3759086560 ("" (subtype-tcc) nil nil) ((posnat nonempty-type-eq-decl nil integers nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (> const-decl "bool" reals nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil ford_johnson nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (nstructER_basic? const-decl "bool" ford_johnson nil) (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (is_sorted? const-decl "bool" sorting_seq nil) (is_indx? const-decl "bool" ford_johnson nil)) nil (nstructER_basic_equiv subtype "ford_johnson.indx" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), ford_johnson.is_indx?(ford_johnson.s`seqfj, indx))}"))) (nstructER_basic_equiv_TCC2 0 (nstructER_basic_equiv_TCC2-1 nil 3759086560 ("" (skeep) (("" (case-replace "t(1)=0") (("1" (expand "min") (("1" (assert) nil nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (> const-decl "bool" reals nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil)) nil (nstructER_basic_equiv subtype "real_defs.min(ford_johnson.t(1), (number_fields.-)(length(ford_johnson.s`seqfj), 1))" "{pos: nat_types[length(ford_johnson.indx)].below | reals.<=(pos, ford_johnson.t(1))}"))) (nstructER_basic_equiv 0 (nstructER_basic_equiv-1 nil 3759086560 ("" (skeep) (("" (beta) (("" (flatten) (("" (name-replace "indx" " (# length := length(s`seqfj),
                        seq := LAMBDA (i: below[length(s`seqfj)]): i #)") (("" (expand "PartialERforK?") (("" (split) (("1" (skeep) (("1" (expand "nstructER_basic?") (("1" (expand "finseq_appl") (("1" (flatten) (("1" (inst -1 "j") (("1" (assert) (("1" (expand "indx") (("1" (reveal -2) (("1" (swap-rel -1) (("1" (inst 2 "j") (("1" (replaces) (("1" (typepred "j") (("1" (assert) (("1" (case-replace "t(1)=0") (("1" (expand "min") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (expand "finseq_appl") (("2" (typepred "j") (("2" (expand "indx") (("2" (expand "nstructER_basic?") (("2" (flatten) (("2" (inst -4 "j") (("2" (assert) (("2" (inst 1 "j") (("2" (hide -5) (("2" (expand "indx") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (expand "finseq_appl") (("3" (expand "nstructER_basic?") (("3" (flatten) (("3" (expand "indx") (("3" (inst -1 "i") (("1" (hide -2) (("1" (typepred "i") (("1" (case-replace "t(1)=0") (("1" (assert) (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (typepred "i") (("2" (expand "indx") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "nstructER_basic?") (("4" (flatten) nil nil)) nil) ("5" (expand "nstructER_basic?") (("5" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (nstructER_basic? const-decl "bool" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (j skolem-const-decl "below[length(s`seqfj)]" ford_johnson nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (NOT const-decl "[bool -> bool]" booleans nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (nzint_times_nzint_is_nzint application-judgement "nzint" integers nil) (nzreal_expt application-judgement "nzreal" exponentiation nil) (int_expt application-judgement "int" exponentiation nil) (minus_odd_is_odd application-judgement "odd_int" integers nil) (nzreal_exp application-judgement "nzreal" exponentiation nil) (int_exp application-judgement "int" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (rat_minus_rat_is_rat application-judgement "rat" rationals nil) (TRUE const-decl "bool" booleans nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (indx skolem-const-decl "[# length: nat, seq: [below[length(s`seqfj)] -> below[length(s`seqfj)]] #]" ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (j skolem-const-decl "below[length(s`seqfj)]" ford_johnson nil) (i skolem-const-decl "{i: below[length(indx)] | i <= t(1)}" ford_johnson nil) (PartialERforK? const-decl "bool" ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (seqfjFatten_TCC1 0 (seqfjFatten_TCC1-1 nil 3715637010 ("" (skeep) (("" (assert) nil nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (seqfjFatten subtype "ford_johnson.n" "posnat"))) (seqfjFatten_TCC2 0 (seqfjFatten_TCC2-1 nil 3735624353 ("" (auto-rewrite "finseq_appl") (("" (skeep) (("" (assert) (("" (split) (("1" (grind) nil nil) ("2" (assert) nil nil) ("3" (typepred "n") (("3" (lemma "nstructER_basic_equiv") (("3" (inst?) (("3" (assert) (("3" (flatten) nil nil)) nil)) nil)) nil)) nil) ("4" (typepred "n") (("4" (expand "nstructER_basic?") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (<= const-decl "bool" reals nil) (restrict const-decl "R" restrict nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (is_sorted? const-decl "bool" sorting_seq nil) (is_indx? const-decl "bool" ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nstructER_basic_equiv formula-decl nil ford_johnson nil) (int_minus_int_is_int application-judgement "int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (posnat nonempty-type-eq-decl nil integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (> const-decl "bool" reals nil) (nstructER_basic? const-decl "bool" ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (seqfjFatten subtype "(# length := length(ford_johnson.s`seqfj), seq := LAMBDA (i: nat_types[length(ford_johnson.s`seqfj)].below): i #)" "{indx: finite_sequences[nat].finseq | booleans.AND(reals.>(length(indx), 0), (booleans.AND(ford_johnson.is_indx?(ford_johnson.s`seqfj, indx), booleans.AND(reals.<=(1, ford_johnson.maxk(indx`length)), booleans.AND(ford_johnson.PartialERforK?(ford_johnson.s, indx, 1, real_defs.min(ford_johnson.t(1), (number_fields.-)(length(indx), 1)), ford_johnson.n), booleans.AND(ford_johnson.oddNstructPreservation?(ford_johnson.s, ford_johnson.n), indx`seq(0) = 0))))))}"))) (seqfjFatten_TCC3 0 (seqfjFatten_TCC3-1 nil 3735624353 ("" (skeep) (("" (lemma "binsert_one_level_length") (("" (inst?) (("1" (assert) nil nil) ("2" (split) (("1" (hide 3) (("1" (grind) nil nil)) nil) ("2" (typepred "n") (("2" (lemma "nstructER_basic_equiv") (("2" (inst?) (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "n") (("3" (expand "nstructER_basic?") (("3" (assert) nil nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) ((binsert_one_level_length formula-decl nil ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (restrict const-decl "R" restrict nil) (is_sorted? const-decl "bool" sorting_seq nil) (nstructER_basic_equiv formula-decl nil ford_johnson nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (is_indx? const-decl "bool" ford_johnson nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (PartialERforK? const-decl "bool" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (nstructER_basic? const-decl "bool" ford_johnson nil) (n skolem-const-decl "{n: nat | nstructER_basic?(s, n)}" ford_johnson nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (<= const-decl "bool" reals nil) (posnat nonempty-type-eq-decl nil integers nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (T formal-type-decl nil ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil)) nil (seqfjFatten subtype "ford_johnson.binsert_one_level(ford_johnson.s, 1, ford_johnson.n, (# length := length(ford_johnson.s`seqfj), seq := LAMBDA (i: nat_types[length(ford_johnson.s`seqfj)].below): i #))" "{s: firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].finseqfj | reals.>(length(s`seqfj), 0)}"))) (seqfjFatten_TCC4 0 (seqfjFatten_TCC4-1 nil 3735635286 ("" (skeep) (("" (assert) (("" (lemma "binsert_one_level_go_to_nstruct") (("" (inst?) (("1" (assert) nil nil) ("2" (split) (("1" (grind) nil nil) ("2" (lemma "nstructER_basic_equiv") (("2" (hide 3) (("2" (inst -1 "s" "n") (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "n") (("3" (hide 3) (("3" (expand "nstructER_basic?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (s skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (above nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (posnat nonempty-type-eq-decl nil integers nil) (<= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (n skolem-const-decl "{n: nat | nstructER_basic?(s, n)}" ford_johnson nil) (nstructER_basic? const-decl "bool" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (PartialERforK? const-decl "bool" ford_johnson nil) (= const-decl "[T, T -> boolean]" equalities nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (is_indx? const-decl "bool" ford_johnson nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (nstructER_basic_equiv formula-decl nil ford_johnson nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (restrict const-decl "R" restrict nil) (is_sorted? const-decl "bool" sorting_seq nil) (binsert_one_level_go_to_nstruct formula-decl nil ford_johnson nil)) nil (seqfjFatten subtype "(number_fields.-)(ford_johnson.n, 1)" "{n_1: naturalnumbers.nat | ford_johnson.nstructER_basic?(ford_johnson.binsert_one_level(ford_johnson.s, 1, ford_johnson.n, (# length := length(ford_johnson.s`seqfj), seq := LAMBDA (i: nat_types[length(ford_johnson.s`seqfj)].below): i #)), n_1)}"))) (seqfjFatten_TCC5 0 (seqfjFatten_TCC5-1 nil 3747585831 ("" (termination-tcc) nil nil) nil nil (seqfjFatten termination "ford_johnson.seqfjFatten(ford_johnson.binsert_one_level(ford_johnson.s, 1, ford_johnson.n, (# length := length(ford_johnson.s`seqfj), seq := LAMBDA (i: nat_types[length(ford_johnson.s`seqfj)].below): i #)), (number_fields.-)(ford_johnson.n, 1))" "nil"))) (seqfjFatten_length 0 (seqfjFatten_length-1 nil 3773062594 ("" (measure-induct "n" ("s" "n")) (("1" (skeep) (("1" (expand "seqfjFatten" -2) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (inst? -2) (("1" (assert) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "well_founded?") (("2" (skeep* :preds? t) (("2" (inst -2 "p") (("2" (prop) (("1" (skeep) (("1" (inst 1 "y!1") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (x_1 skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (x_2 skolem-const-decl "{n: nat | nstructER_basic?(x_1, n)}" ford_johnson nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (is_indx? const-decl "bool" ford_johnson nil) (<= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (PartialERforK? const-decl "bool" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (binsert_one_level def-decl "finseqfj" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (seqfjFatten def-decl "finseqfj" ford_johnson nil) (/= const-decl "boolean" notequal nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nstructER_basic? const-decl "bool" ford_johnson nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil ford_johnson nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (seqfjFatten_gives_permutation 0 (seqfjFatten_gives_permutation-1 nil 3759002389 ("" (measure-induct "n" ("s" "n")) (("1" (skeep) (("1" (expand "seqfjFatten" 1) (("1" (lift-if) (("1" (prop) (("1" (lemma "permutation_equiv") (("1" (flatten) (("1" (inst -1 "x_1") nil nil)) nil)) nil) ("2" (inst?) (("1" (assert) (("1" (lemma "binsert_one_level_gives_permutation") (("1" (inst?) (("1" (lemma "permutation_equiv") (("1" (flatten) (("1" (hide -1 -2) (("1" (inst -1 "x_1" "binsert_one_level(x_1,
                                            1,
                                            x_2,
                                            (# length := length(x_1`seqfj),
                                               seq
                                               := LAMBDA
                                                  (i: below[length(x_1`seqfj)]):
                                                  i #))" " seqfjFatten(binsert_one_level(x_1,
                                                        1,
                                                        x_2,
                                                        (# length
                                                           := length(x_1`seqfj),
                                                           seq
                                                           := LAMBDA
                                                              (i:
                                                               below
                                                               [length
                                                                (x_1`seqfj)]):
                                                              i #)),
                                      x_2 - 1)") (("1" (assert) (("1" (hide -1 1 3) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (split) (("1" (grind) nil nil) ("2" (typepred "x_2") (("2" (lemma "nstructER_basic_equiv") (("2" (inst?) (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "x_2") (("3" (expand "nstructER_basic?") (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "well_founded?") (("2" (skeep* :preds? t) (("2" (inst -2 "p") (("2" (prop) (("1" (skeep) (("1" (inst 1 "y!1") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (x_1 skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (x_2 skolem-const-decl "{n: nat | nstructER_basic?(x_1, n)}" ford_johnson nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (is_indx? const-decl "bool" ford_johnson nil) (<= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (PartialERforK? const-decl "bool" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (binsert_one_level def-decl "finseqfj" ford_johnson nil) (binsert_one_level_gives_permutation formula-decl nil ford_johnson nil) (NOT const-decl "[bool -> bool]" booleans nil) (nstructER_basic_equiv formula-decl nil ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (restrict const-decl "R" restrict nil) (is_sorted? const-decl "bool" sorting_seq nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (permutation_equiv formula-decl nil firt_phase_ford_johnson nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (seqfjFatten def-decl "finseqfj" ford_johnson nil) (permutation const-decl "bool" firt_phase_ford_johnson nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nstructER_basic? const-decl "bool" ford_johnson nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil ford_johnson nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (seqfjFatten_gives_down_nstructER_basic_TCC1 0 (seqfjFatten_gives_down_nstructER_basic_TCC1-1 nil 3772220942 ("" (skeep* :preds? t) (("" (use "seqfjFatten_length") (("" (assert) nil nil)) nil)) nil) ((seqfjFatten_length formula-decl nil ford_johnson nil) (nstructER_basic? const-decl "bool" ford_johnson nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil)) nil (seqfjFatten_gives_down_nstructER_basic subtype "ford_johnson.seqfjFatten(ford_johnson.s, ford_johnson.n)" "{s: firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].finseqfj | reals.>(length(s`seqfj), 0)}"))) (seqfjFatten_gives_down_nstructER_basic 0 (seqfjFatten_gives_down_nstructER_basic-1 nil 3759090534 ("" (measure-induct "n" ("s" "n")) (("1" (skeep) (("1" (expand "seqfjFatten" 1) (("1" (lift-if) (("1" (prop) (("1" (typepred "x_2") (("1" (hide -3) (("1" (assert) nil nil)) nil)) nil) ("2" (inst -1 "binsert_one_level(x_1,
                                                     1,
                                                     x_2,
                                                     (# length
                                                        := length
                                                           (x_1`seqfj),
                                                        seq
                                                        := LAMBDA
                                                           (i:
                                                            below
                                                            [length
                                                             (x_1`seqfj)]):
                                                           i #))" "x_2-1") (("1" (assert) (("1" (hide-all-but (1 3)) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide 2) (("2" (lemma "seqfjFatten_length") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide -1 2) (("3" (lemma "seqfjFatten_length") (("3" (inst?) (("3" (assert) nil nil)) nil)) nil)) nil)) nil) ("4" (hide 2) (("4" (skeep) (("4" (lemma "seqfjFatten_length") (("4" (inst?) (("4" (assert) nil nil)) nil)) nil)) nil)) nil) ("5" (hide 2) (("5" (skeep) (("5" (lemma "seqfjFatten_length") (("5" (inst?) (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("6" (hide 2) (("6" (expand "well_founded?") (("6" (skeep* :preds? t) (("6" (inst -2 "p") (("6" (prop) (("1" (skeep) (("1" (inst 1 "y!1") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((seqfjFatten_length formula-decl nil ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (x_1 skolem-const-decl "{s: finseqfj | length(s`seqfj) > 0}" ford_johnson nil) (x_2 skolem-const-decl "{n: nat | nstructER_basic?(x_1, n)}" ford_johnson nil) (posnat nonempty-type-eq-decl nil integers nil) (below type-eq-decl nil nat_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (is_indx? const-decl "bool" ford_johnson nil) (<= const-decl "bool" reals nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil) (t const-decl "{t: nat | k > 1 => t >= 2}" ford_johnson nil) (maxk const-decl "{k: above(1) | t(k - 1) < l AND t(k) >= l}" ford_johnson nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (PartialERforK? const-decl "bool" ford_johnson nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (binsert_one_level def-decl "finseqfj" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (seqfjFatten def-decl "finseqfj" ford_johnson nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nstructER_basic? const-decl "bool" ford_johnson nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil ford_johnson nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (mergeInsertion_TCC1 0 (mergeInsertion_TCC1-1 nil 3718636077 ("" (subtype-tcc) nil nil) nil shostak (mergeInsertion subtype "length(ford_johnson.s)" "{x: reals.real | reals.>=(x, 1)}"))) (mergeInsertion_TCC2 0 (mergeInsertion_TCC2-1 nil 3759011223 ("" (skeep) (("" (skeep) (("" (lemma "lengthBottleneckIs1") (("" (inst -1 "sc" "0" "sc") (("1" (assert) (("1" (hide -2 2) (("1" (lemma "plain_finseqfj_nstructER0") (("1" (inst?) (("1" (assert) (("1" (typepred "s") (("1" (replaces) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (expand "^") (("3" (expand "expt") (("3" (assert) nil nil)) nil)) nil) ("4" (replaces) (("4" (typepred "s") (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil ford_johnson nil) (lengthBottleneckIs1 formula-decl nil firt_phase_ford_johnson nil) (TRUE const-decl "bool" booleans nil) (expt def-decl "real" exponentiation nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (plain_finseqfj_nstructER0 formula-decl nil firt_phase_ford_johnson nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (below type-eq-decl nil nat_types nil) (NOT const-decl "[bool -> bool]" booleans nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (sc skolem-const-decl "finseqfj[T, leq]" ford_johnson nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil)) nil (mergeInsertion subtype "firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].seqfjBottleneck(ford_johnson.sc)" "{s: firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].finseqfj | reals.>(length(s`seqfj), 0)}"))) (mergeInsertion_TCC3 0 (mergeInsertion_TCC3-1 nil 3772384470 ("" (skeep) (("" (skeep) (("" (lemma "correctionER") (("" (inst -1 "sc" "sc") (("1" (assert) (("1" (split) (("1" (replaces) (("1" (expand "nstructER?") (("1" (flatten) (("1" (expand "nstructER_basic?") (("1" (split) (("1" (propax) nil nil) ("2" (expand "oddNstructPreservation?") (("2" (split) (("1" (hide-all-but (-6 1)) (("1" (skeep) (("1" (inst? -1) (("1" (skeep) (("1" (inst?) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-5 1)) (("2" (skeep) (("2" (inst?) (("2" (assert) (("2" (case-replace "nth(seqfjBottleneck[T, <=]
                                 ((# seqfj := s,
                                     oddList := null #))`oddList,
                             i) = nth(seqfjBottleneck
                                 ((# seqfj := s,
                                     oddList := null #))`oddList,
                             i)") (("2" (case-replace "nth(seqfjBottleneck[T, <=]
                                 ((# seqfj := s,
                                     oddList := null #))`oddList,
                             j) = nth(seqfjBottleneck
                                 ((# seqfj := s,
                                     oddList := null #))`oddList,
                             j)") (("2" (assert) (("2" (name-replace "ii" "smallerones(nth(seqfjBottleneck((# seqfj := s,
                                                oddList
                                                := null #))`oddList,
                             i))") (("2" (name-replace "jj" "smallerones(nth(seqfjBottleneck((# seqfj := s,
                                                oddList
                                                := null #))`oddList,
                             j))") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (lemma "lengthBottleneckIs1") (("3" (inst -1 "(# seqfj := s, oddList := null #)" "0" "(# seqfj := s, oddList := null #)") (("1" (split) (("1" (expand "is_sorted?") (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (typepred "s") (("2" (lemma "plain_finseqfj_nstructER0") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (typepred "s") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "0") (("2" (lemma "plain_finseqfj_nstructER0") (("2" (inst?) (("2" (typepred "s") (("2" (replaces) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (typepred "s") (("3" (replaces) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil ford_johnson nil) (correctionER formula-decl nil firt_phase_ford_johnson nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (TRUE const-decl "bool" booleans nil) (above nonempty-type-eq-decl nil integers nil) (logb const-decl "nat" firt_phase_ford_johnson nil) (odd? const-decl "bool" integers nil) (integer nonempty-type-from-decl nil integers nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (below type-eq-decl nil nat_types nil) (seqfjBottleneck def-decl "finseqfj" firt_phase_ford_johnson nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (lengthBottleneckIs1 formula-decl nil firt_phase_ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (expt def-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (NOT const-decl "[bool -> bool]" booleans nil) (plain_finseqfj_nstructER0 formula-decl nil firt_phase_ford_johnson nil) (s skolem-const-decl "{s: finseq[fjnode[T]] |
   length(s) > 0 AND plain_finseqfj((# seqfj := s, oddList := null #))}" ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nstructER_basic? const-decl "bool" ford_johnson nil) (nstructER? const-decl "bool" firt_phase_ford_johnson nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (posint_exp application-judgement "posint" exponentiation nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (sc skolem-const-decl "finseqfj[T, leq]" ford_johnson nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (mergeInsertion subtype "ford_johnson.h" "{n: naturalnumbers.nat | ford_johnson.nstructER_basic?(firt_phase_ford_johnson[ford_johnson.T, ford_johnson.leq].seqfjBottleneck(ford_johnson.sc), n)}"))) (mergeInsertion_is_ok 0 (mergeInsertion_is_ok-1 nil 3766824224 ("" (skeep) (("" (split) (("1" (expand "mergeInsertion") (("1" (lemma "seqfjFatten_gives_permutation") (("1" (inst?) (("1" (lemma "seqfjBottleneck_works") (("1" (inst?) (("1" (split) (("1" (flatten) (("1" (lemma "permutation_equiv") (("1" (flatten) (("1" (hide -1) (("1" (inst -2 "(# seqfj := s, oddList := null #)" "seqfjBottleneck((# seqfj := s, oddList := null #))" "seqfjFatten(seqfjBottleneck((# seqfj := s,
                                                       oddList := null #)),
                                    logb(length(s), 2))") (("1" (split) (("1" (hide -2 -3 -4 -5) (("1" (expand "permutation") (("1" (skeep) (("1" (inst -1 "x") (("1" (expand "occurrences" -1 1) (("1" (expand "map") (("1" (assert) (("1" (replaces) (("1" (assert) (("1" (lemma "seqfjFatten_gives_down_nstructER_basic") (("1" (inst?) (("1" (expand "nstructER_basic?") (("1" (flatten) (("1" (hide -1 -3) (("1" (expand "occurrences") (("1" (expand "map") (("1" (lift-if) (("1" (prop) (("1" (hide 2) (("1" (expand "oddNstructPreservation?") (("1" (flatten) (("1" (inst -1 "0") (("1" (hide -2) (("1" (skeep) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (propax) nil nil) ("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "s") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "mergeInsertion") (("2" (lemma "seqfjFatten_gives_down_nstructER_basic") (("2" (inst?) (("2" (expand "nstructER_basic?") (("2" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((seqfjFatten_gives_permutation formula-decl nil ford_johnson nil) (seqfjBottleneck_works formula-decl nil firt_phase_ford_johnson nil) (permutation_equiv formula-decl nil firt_phase_ford_johnson nil) (permutation const-decl "bool" firt_phase_ford_johnson nil) (permutation const-decl "bool" firt_phase_ford_johnson nil) (map def-decl "nat" firt_phase_ford_johnson nil) (TRUE const-decl "bool" booleans nil) (seqfjFatten_gives_down_nstructER_basic formula-decl nil ford_johnson nil) (oddNstructPreservation? const-decl "bool" ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (s skolem-const-decl "{s: finseq[fjnode[T]] |
   plain_finseqfj((# seqfj := s, oddList := null #)) AND length(s) > 0}" ford_johnson nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (occurrences const-decl "nat" firt_phase_ford_johnson nil) (seqfjFatten def-decl "finseqfj" ford_johnson nil) (listn_0 name-judgement "listn[fjnode[T]](0)" ford_johnson nil) (NOT const-decl "[bool -> bool]" booleans nil) (logb const-decl "nat" firt_phase_ford_johnson nil) (above nonempty-type-eq-decl nil integers nil) (nstructER_basic? const-decl "bool" ford_johnson nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (null adt-constructor-decl "(null?)" list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (seqfjBottleneck def-decl "finseqfj" firt_phase_ford_johnson nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (leq formal-const-decl "(total_preorder?[T])" ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil ford_johnson nil) (mergeInsertion const-decl "finseq[fjnode[T]]" ford_johnson nil)) shostak)))
