(fjnode)(firt_phase_ford_johnson (log_exp_TCC1 0 (log_exp_TCC1-1 nil 3734217614 ("" (subtype-tcc) nil nil) nil shostak (log_exp subtype "firt_phase_ford_johnson.n" "{i: integers.int | booleans.OR(firt_phase_ford_johnson.b /= 0, reals.>=(i, 0))}"))) (log_exp_TCC2 0 (log_exp_TCC2-1 nil 3734217614 ("" (lemma "increasing_expt_aux") (("" (skeep) (("" (case "n >= 2") (("1" (inst -2 "b" "n-2") (("1" (assert) (("1" (expand "^") (("1" (assert) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (hide -) (("2" (case-replace "n=0") (("1" (grind) nil nil) ("2" (case-replace "n=1") (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_times_posint_is_posint application-judgement "posint" integers nil) (expt def-decl "real" exponentiation nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (n skolem-const-decl "nat" firt_phase_ford_johnson nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (above nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (int_plus_int_is_int application-judgement "int" integers nil) (posint_exp application-judgement "posint" exponentiation nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (increasing_expt_aux formula-decl nil exponentiation nil)) shostak (log_exp subtype "exponentiation.^(firt_phase_ford_johnson.b, firt_phase_ford_johnson.n)" "{x: reals.real | reals.>=(x, 1)}"))) (log_exp 0 (log_exp-1 nil 3732007780 ("" (skeep) (("" (lemma "log_nat_bounds") (("" (typepred "b") (("" (inst -2 "b" "b ^ n") (("" (expand "logb" 1) (("" (beta) (("" (prop) (("" (name-replace "ll" "log_nat(b ^ n, b)`1") (("" (lemma "both_sides_expt_gt1_lt") (("" (inst?) (("" (assert) (("" (lemma "both_sides_expt_gt1_le") (("" (inst?) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((log_nat_bounds formula-decl nil log_nat reals) (posint_exp application-judgement "posint" exponentiation nil) (>= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (both_sides_expt_gt1_le formula-decl nil exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_expt_gt1_lt formula-decl nil exponentiation nil) (logb const-decl "nat" firt_phase_ford_johnson nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (above nonempty-type-eq-decl nil integers nil)) shostak)) (is_sorted?_TCC1 0 (is_sorted?_TCC1-1 nil 3718042630 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (finseq type-eq-decl nil finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (is_sorted? subtype "(number_fields.+)(firt_phase_ford_johnson.i, 1)" "below[length(s)]"))) (add_fold_TCC1 0 (add_fold_TCC1-1 nil 3738651969 ("" (subtype-tcc) nil nil) ((listn_0 name-judgement "listn[fjnode[T]](0)" firt_phase_ford_johnson nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[fjnode])" fjnode_adt nil) (nth def-decl "T" list_props nil)) nil (add_fold subtype "firt_phase_ford_johnson.fjlist" "(list_adt[fjnode_adt[firt_phase_ford_johnson.T].fjnode].cons?)"))) (add_fold_TCC2 0 (add_fold_TCC2-1 nil 3738651969 ("" (skeep) (("" (typepred "fjlist") (("" (inst -1 "0") (("1" (expand "nth") (("1" (propax) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ((nth def-decl "T" list_props nil) (<< adt-def-decl "(strict_well_founded?[fjnode])" fjnode_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (fjlist skolem-const-decl "{fjlist: list[fjnode[T]] |
   FORALL (n: below[length(fjlist)]): nth(fjlist, n) << fj}" firt_phase_ford_johnson nil) (fj skolem-const-decl "fjnode[T]" firt_phase_ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" firt_phase_ford_johnson nil)) nil (add_fold subtype "list_adt[fjnode_adt[firt_phase_ford_johnson.T].fjnode].car(firt_phase_ford_johnson.fjlist)" "(LAMBDA (x: fjnode_adt[firt_phase_ford_johnson.T].fjnode): fjnode_adt[firt_phase_ford_johnson.T].<<(x, firt_phase_ford_johnson.fj))"))) (add_fold_TCC3 0 (add_fold_TCC3-1 nil 3738651969 ("" (skeep) (("" (typepred "fjlist") (("" (skeep) (("" (inst -1 "n+1") (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil) ("2" (typepred "n") (("2" (expand "length" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth def-decl "T" list_props nil) (<< adt-def-decl "(strict_well_founded?[fjnode])" fjnode_adt nil) (strict_well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (n skolem-const-decl "below[length(cdr(fjlist))]" firt_phase_ford_johnson nil) (fjlist skolem-const-decl "{fjlist: list[fjnode[T]] |
   FORALL (n: below[length(fjlist)]): nth(fjlist, n) << fj}" firt_phase_ford_johnson nil) (fj skolem-const-decl "fjnode[T]" firt_phase_ford_johnson nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (listn_0 name-judgement "listn[fjnode[T]](0)" firt_phase_ford_johnson nil)) nil (add_fold subtype "list_adt[fjnode_adt[firt_phase_ford_johnson.T].fjnode].cdr(firt_phase_ford_johnson.fjlist)" "{fjlist: list_adt[fjnode_adt[firt_phase_ford_johnson.T].fjnode].list | FORALL (n: nat_types[list_props[fjnode_adt[firt_phase_ford_johnson.T].fjnode].length(fjlist)].below): fjnode_adt[firt_phase_ford_johnson.T].<<(list_props[fjnode_adt[firt_phase_ford_johnson.T].fjnode].nth(fjlist, n), firt_phase_ford_johnson.fj)}"))) (add_fold_TCC4 0 (add_fold_TCC4-1 nil 3738651969 ("" (termination-tcc) nil nil) ((listn_0 name-judgement "listn[fjnode[T]](0)" firt_phase_ford_johnson nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[fjnode])" fjnode_adt nil) (nth def-decl "T" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (add_fold termination "firt_phase_ford_johnson.add_fold(firt_phase_ford_johnson.fj)(firt_phase_ford_johnson.f)(list_adt[fjnode_adt[firt_phase_ford_johnson.T].fjnode].cdr(firt_phase_ford_johnson.fjlist))" "nil"))) (nodes_TCC1 0 (nodes_TCC1-1 nil 3738651969 ("" (case "FORALL (fj: fjnode[T]):
               NOT length(smallerones(fj)) = 0 IMPLIES
                (FORALL (n: below[length[fjnode[T]](smallerones[T](fj))]):  some[fjnode[T]]
                 (LAMBDA (z: fjnode[T]):
                    nth[fjnode[T]](smallerones[T](fj), n) = z)
                 (smallerones(fj)))") (("1" (measure-induct+ "length(smallerones(fj))" ("fj")) (("1" (skeep) (("1" (expand "<<" 2) (("1" (expand "some" 2) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (inst -1 "consFjnode(val(x!1), cdr(smallerones(x!1)))") (("2" (prop) (("1" (case "n=0") (("1" (replaces -1) (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil)) nil) ("2" (rewrite "fjnode_smallerones_consFjnode") (("2" (inst -1 "n -1") (("1" (expand "<<" -1) (("1" (case-replace "nth[fjnode[T]](cdr(smallerones(x!1)), n - 1) = nth[fjnode[T]](smallerones[T](x!1), n) ") (("1" (hide - 5 6) (("1" (grind) nil nil)) nil) ("2" (typepred "n") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 3 4) (("2" (rewrite "fjnode_smallerones_consFjnode") (("2" (typepred "n") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide -1 4 5) (("3" (rewrite "fjnode_smallerones_consFjnode") (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (measure-induct+ "length(smallerones(fj))" ("fj")) (("2" (skeep) (("2" (expand "some" 2) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (inst -1 "consFjnode(val(x!1),cdr(smallerones(x!1)))") (("2" (prop) (("1" (inst -1 "n - 1") (("1" (rewrite "fjnode_smallerones_consFjnode") (("1" (case-replace "nth[fjnode[T]](smallerones[T](x!1), n) = nth[fjnode[T]](cdr(smallerones(x!1)), n - 1)") (("1" (hide -1 4) (("1" (case "n > 0") (("1" (expand "nth" 1 1) (("1" (assert) nil nil)) nil) ("2" (hide 2) (("2" (assert) (("2" (typepred "n") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (prop) (("1" (hide -1 4) (("1" (grind) nil nil)) nil) ("2" (hide -1 4) (("2" (typepred "n") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (typepred "n") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "n") (("2" (hide 3) (("2" (grind) nil nil)) nil)) nil) ("3" (hide 3 4) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((x!1 skolem-const-decl "fjnode[T]" firt_phase_ford_johnson nil) (n skolem-const-decl "below[length[fjnode[T]](smallerones[T](x!1))]" firt_phase_ford_johnson nil) (> const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (wf_nat formula-decl nil naturalnumbers nil) (<< adt-def-decl "(strict_well_founded?[fjnode])" fjnode_adt nil) (strict_well_founded? const-decl "bool" orders nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (val adt-accessor-decl "[fjnode -> T]" fjnode_adt nil) (consFjnode adt-constructor-decl "[[T, list[fjnode]] -> (consFjnode?)]" fjnode_adt nil) (consFjnode? adt-recognizer-decl "[fjnode -> boolean]" fjnode_adt nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (x!1 skolem-const-decl "fjnode[T]" firt_phase_ford_johnson nil) (n skolem-const-decl "below[length(smallerones(x!1))]" firt_phase_ford_johnson nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (fjnode_smallerones_consFjnode formula-decl nil fjnode_adt nil) (listn_0 name-judgement "listn[fjnode[T]](0)" firt_phase_ford_johnson nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (list type-decl nil list_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (PRED type-eq-decl nil defined_types nil) (some adt-def-decl "boolean" list_adt nil) (nth def-decl "T" list_props nil)) nil (nodes subtype "fjnode_adt[firt_phase_ford_johnson.T].smallerones(firt_phase_ford_johnson.fj)" "{fjlist: list_adt[fjnode_adt[firt_phase_ford_johnson.T].fjnode].list | FORALL (n: nat_types[list_props[fjnode_adt[firt_phase_ford_johnson.T].fjnode].length(fjlist)].below): fjnode_adt[firt_phase_ford_johnson.T].<<(list_props[fjnode_adt[firt_phase_ford_johnson.T].fjnode].nth(fjlist, n), firt_phase_ford_johnson.fj)}"))) (map_TCC1 0 (map_TCC1-1 nil 3738651969 ("" (subtype-tcc) nil nil) ((listn_0 name-judgement "listn[fjnode[T]](0)" firt_phase_ford_johnson nil)) nil (map subtype "firt_phase_ford_johnson.fjlist" "(list_adt[fjnode_adt[firt_phase_ford_johnson.T].fjnode].cons?)"))) (map_TCC2 0 (map_TCC2-1 nil 3738651969 ("" (termination-tcc) nil nil) ((listn_0 name-judgement "listn[fjnode[T]](0)" firt_phase_ford_johnson nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (map termination "firt_phase_ford_johnson.map(list_adt[fjnode_adt[firt_phase_ford_johnson.T].fjnode].cdr(firt_phase_ford_johnson.fjlist))" "nil"))) (map_TCC3 0 (map_TCC3-1 nil 3738651969 ("" (subtype-tcc) nil nil) ((real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (map subtype "0" "below[length(sfj)]"))) (map_TCC4 0 (map_TCC4-1 nil 3738651969 ("" (skeep) (("" (expand "rest") (("" (expand "^") (("" (lift-if) (("" (prop) (("1" (expand "empty_seq") (("1" (assert) nil nil)) nil) ("2" (expand "empty_seq") (("2" (assert) nil nil)) nil) ("3" (expand "min") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((rest const-decl "finseq" seq_extras structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (empty_seq const-decl "finseq" finite_sequences nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (^ const-decl "finseq" finite_sequences nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) nil (map termination "firt_phase_ford_johnson.map(seq_extras[fjnode_adt[firt_phase_ford_johnson.T].fjnode].rest(firt_phase_ford_johnson.sfj))" "nil"))) (permutation_equiv 0 (permutation_equiv-1 nil 3733829031 ("" (prop) (("1" (skeep) (("1" (grind) nil nil)) nil) ("2" (skeep) (("2" (grind) nil nil)) nil) ("3" (skeep) (("3" (grind) nil nil)) nil)) nil) ((occurrences const-decl "nat" firt_phase_ford_johnson nil) (occurrences const-decl "nat" firt_phase_ford_johnson nil) (listn_0 name-judgement "listn[fjnode[T]](0)" firt_phase_ford_johnson nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (permutation const-decl "bool" firt_phase_ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak)) (compare2to2_TCC1 0 (compare2to2_TCC1-1 nil 3715637010 ("" (subtype-tcc) nil nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (odd? const-decl "bool" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil)) shostak (compare2to2 subtype "(number_fields.-)(firt_phase_ford_johnson.s1`seqfj`length, 1)" "below[s1`seqfj`length]"))) (compare2to2_TCC2 0 (compare2to2_TCC2-1 nil 3715637010 ("" (subtype-tcc) nil nil) ((nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil nat_types nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil)) shostak (compare2to2 subtype "number_fields.*(2, firt_phase_ford_johnson.i)" "below[s1`seqfj`length]"))) (compare2to2_TCC3 0 (compare2to2_TCC3-1 nil 3715637010 ("" (subtype-tcc) nil nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (below type-eq-decl nil nat_types nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/= const-decl "boolean" notequal nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (<= const-decl "bool" reals nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (integer nonempty-type-from-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (compare2to2 subtype "(number_fields.+)(number_fields.*(2, firt_phase_ford_johnson.i), 1)" "below[s1`seqfj`length]"))) (seqfjBottleneck_TCC1 0 (seqfjBottleneck_TCC1-1 nil 3715637010 ("" (termination-tcc) nil nil) ((nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (leq formal-const-decl "(total_preorder?[T])" firt_phase_ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (lt const-decl "bool" sorting nil) (odd? const-decl "bool" integers nil) (compare2to2 const-decl "finseqfj" firt_phase_ford_johnson nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak (seqfjBottleneck termination "firt_phase_ford_johnson.seqfjBottleneck(firt_phase_ford_johnson.compare2to2(firt_phase_ford_johnson.s1))" "nil"))) (nstruct?_TCC1 0 (nstruct?_TCC1-1 nil 3715637010 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" firt_phase_ford_johnson nil) (below type-eq-decl nil nat_types nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (< const-decl "bool" reals nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak (nstruct? subtype "(number_fields.-)((number_fields.-)(firt_phase_ford_johnson.n, 1), firt_phase_ford_johnson.i)" "nat"))) (nstruct?_TCC2 0 (nstruct?_TCC2-1 nil 3715637010 ("" (termination-tcc) nil nil) ((int_minus_int_is_int application-judgement "int" integers nil)) shostak (nstruct? termination "firt_phase_ford_johnson.nstruct?(list_props[fjnode_adt[firt_phase_ford_johnson.T].fjnode].nth(fjnode_adt[firt_phase_ford_johnson.T].smallerones(firt_phase_ford_johnson.node), firt_phase_ford_johnson.i))((number_fields.-)((number_fields.-)(firt_phase_ford_johnson.n, 1), firt_phase_ford_johnson.i))" "nil"))) (length_odd_TCC1 0 (length_odd_TCC1-1 nil 3718638316 ("" (skeep) (("" (assert) (("" (typepred "n") (("" (lemma " both_sides_expt_gt1_lt") (("" (inst -1 "2" "n-1" "n") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (both_sides_expt_gt1_lt formula-decl nil exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posrat_exp application-judgement "posrat" exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak (length_odd subtype "(number_fields.-)(firt_phase_ford_johnson.n, 1)" "{n | reals.<=(exponentiation.^(2, firt_phase_ford_johnson.n), firt_phase_ford_johnson.l)}"))) (length_odd_TCC2 0 (length_odd_TCC2-1 nil 3734434620 ("" (termination-tcc) nil nil) nil nil (length_odd termination "firt_phase_ford_johnson.length_odd(firt_phase_ford_johnson.l, (number_fields.-)(firt_phase_ford_johnson.n, 1))" "nil"))) (nstructER?_TCC1 0 (nstructER?_TCC1-1 nil 3718704824 ("" (skeep) (("" (typepred "n") (("" (assert) nil nil)) nil)) nil) ((plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (posint_exp application-judgement "posint" exponentiation nil)) shostak (nstructER? subtype "firt_phase_ford_johnson.n" "{n | reals.<=(exponentiation.^(2, firt_phase_ford_johnson.n), firt_phase_ford_johnson.l)}"))) (plain_finseqfj_nstructER0_TCC1 0 (plain_finseqfj_nstructER0_TCC1-1 nil 3732661487 ("" (skeep) (("" (typepred "s0") (("" (hide -2) (("" (grind) nil nil)) nil)) nil)) nil) ((finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (expt def-decl "real" exponentiation nil) (^ const-decl "real" exponentiation nil) (posnat_expt application-judgement "posnat" exponentiation nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (plain_finseqfj_nstructER0 subtype "0" "{n: naturalnumbers.nat | reals.<=(exponentiation.^(2, n), length(firt_phase_ford_johnson.s0`seqfj))}"))) (plain_finseqfj_nstructER0 0 (plain_finseqfj_nstructER0-1 nil 3732666027 ("" (skeep) (("" (expand "nstructER?") (("" (split) (("1" (expand "permutation") (("1" (propax) nil nil)) nil) ("2" (expand "^") (("2" (expand "expt") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "plain_finseqfj") (("3" (flatten) nil nil)) nil) ("4" (expand "plain_finseqfj") (("4" (flatten) (("4" (expand "length_odd") (("4" (propax) nil nil)) nil)) nil)) nil) ("5" (expand "plain_finseqfj") (("5" (flatten) (("5" (skeep) (("5" (typepred "i") (("5" (assert) nil nil)) nil)) nil)) nil)) nil) ("6" (expand "plain_finseqfj") (("6" (flatten) (("6" (skeep) (("6" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((posint_exp application-judgement "posint" exponentiation nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nstructER? const-decl "bool" firt_phase_ford_johnson nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (listn_0 name-judgement "listn[fjnode[T]](0)" firt_phase_ford_johnson nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (finseq type-eq-decl nil finite_sequences nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (> const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (posrat_exp application-judgement "posrat" exponentiation nil) (length_odd def-decl "nat" firt_phase_ford_johnson nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (posnat_expt application-judgement "posnat" exponentiation nil) (^ const-decl "real" exponentiation nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (expt def-decl "real" exponentiation nil) (permutation const-decl "bool" firt_phase_ford_johnson nil)) shostak)) (occ_list_vs_fjnodes 0 (occ_list_vs_fjnodes-1 nil 3741087815 ("" (skeep) (("" (induct "l") (("1" (skeep) (("1" (typepred "l!1") (("1" (inst?) nil nil)) nil)) nil) ("2" (flatten) (("2" (expand "add_fold") (("2" (expand "length") (("2" (expand "occurrences") (("2" (expand "map") (("2" (expand "length") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (split) (("1" (hide -2) (("1" (expand "add_fold" 1) (("1" (lift-if) (("1" (prop) (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (replaces -1) (("2" (expand "occurrences" 2 3) (("2" (expand "map") (("2" (lift-if) (("2" (prop) (("2" (expand "occurrences" 2 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep) (("2" (inst -1 "i+1") (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (pred type-eq-decl nil defined_types nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[fjnode])" fjnode_adt nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (add_fold def-decl "nat" firt_phase_ford_johnson nil) (occurrences def-decl "nat" firt_phase_ford_johnson nil) (occurrences const-decl "nat" firt_phase_ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (list_induction formula-decl nil list_adt nil) (listn_0 name-judgement "listn[fjnode[T]](0)" firt_phase_ford_johnson nil) (NOT const-decl "[bool -> bool]" booleans nil) (map def-decl "nat" firt_phase_ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (TRUE const-decl "bool" booleans nil) (cons1_var skolem-const-decl "fjnode[T]" firt_phase_ford_johnson nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (i skolem-const-decl "below[length(cons2_var)]" firt_phase_ford_johnson nil) (cons2_var skolem-const-decl "list[fjnode[T]]" firt_phase_ford_johnson nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (comparePeservesElements 0 (comparePeservesElements-5 nil 3797789998 ("" (measure-induct+ "s`seqfj`length" "s") (("" (expand "permutation") (("" (skeep) (("" (expand "occurrences" -1 (3 4)) (("" (expand "occurrences" 1 (3 4)) (("" (case "length(x!1`seqfj)<=3") (("1" (hide -2) (("1" (case "length(x!1`seqfj) <= 1") (("1" (case "compare2to2(x!1) = x!1") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (expand "compare2to2") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "map" 2 1) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2") (("1" (assert) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (case "occurrences(x)(compare2to2(x!1)`seqfj`seq(0)) = occurrences(x)(x!1`seqfj`seq(0))+ occurrences(x)(x!1`seqfj`seq(1))") (("1" (replaces -1) (("1" (expand "occurrences" 2 2) (("1" (expand "map" 2 1) (("1" (assert) (("1" (expand "map" 2 1) (("1" (lift-if) (("1" (prop) (("1" (expand "rest" -1) (("1" (expand "^") (("1" (expand "min") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "rest" 2 3) (("2" (expand "^") (("2" (case-replace "map(rest(compare2to2(x!1)`seqfj))(occurrences(x)) =0") (("1" (case "length(x!1`seqfj)=2") (("1" (hide -2 -3 3 4) (("1" (expand "compare2to2") (("1" (lift-if) (("1" (prop) (("1" (expand "odd?") (("1" (assert) nil nil)) nil) ("2" (expand "occurrences" 2 2) (("2" (expand "map") (("2" (expand "rest" 2 (1 2)) (("2" (expand "^") (("2" (expand "min") (("2" (expand "empty_seq") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "length(x!1`seqfj) = 3") (("1" (hide -2 -3 1 2 4 5) (("1" (expand "map" 1 1) (("1" (expand "rest" 1 (1 2)) (("1" (expand "^") (("1" (expand "min") (("1" (assert) (("1" (expand "map" 1 1) (("1" (expand "rest" 1 (1 2 3)) (("1" (expand "^") (("1" (expand "min") (("1" (expand "empty_seq") (("1" (expand "finseq_appl") (("1" (expand "compare2to2") (("1" (expand "map") (("1" (expand "length") (("1" (assert) (("1" (assert) (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (expand "occurrences" 1 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 4)) (("2" (lemma "occ_list_vs_fjnodes") (("2" (copy -1) (("2" (copy -1) (("2" (inst -1 "compare2to2(x!1)`seqfj`seq(0)" "x" "smallerones((compare2to2(x!1)`seqfj`seq(0)))") (("1" (inst -2 "x!1`seqfj`seq(0)" "x" "smallerones(x!1`seqfj`seq(0))") (("1" (inst -3 "x!1`seqfj`seq(1)" "x" "smallerones(x!1`seqfj`seq(1))") (("1" (expand "occurrences" 1 (2 3)) (("1" (replaces) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (expand "occurrences" 1) (("1" (replaces) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "occurrences" 2) (("2" (replaces) (("2" (expand "compare2to2") (("2" (assert) (("2" (expand "lt") (("2" (typepred "leq") (("2" (expand "total_preorder?") (("2" (expand "preorder?") (("2" (expand "reflexive?") (("2" (prop) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -1 -2 -3) (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map" 2 1) (("2" (expand "length" 2) (("2" (expand "map" 2 1) (("2" (expand "occurrences" 2 1) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst -1 "x!1`seqfj`seq(1)" "x" "smallerones(x!1`seqfj`seq(1))") (("2" (replaces) (("2" (expand "occurrences" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "occurrences" 1) (("3" (replaces) (("3" (expand "compare2to2" 1 1) (("3" (lift-if) (("3" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences") (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "map") (("1" (expand "occurrences") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences") (("2" (expand "map") (("2" (expand "length") (("2" (expand "map") (("2" (expand "occurrences") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "occurrences" 2 1) (("4" (replaces) (("4" (expand "compare2to2" 2 1) (("4" (lift-if) (("4" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 2) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst -1 "x!1`seqfj`seq(1)" "x" "smallerones(x!1`seqfj`seq(1))") (("1" (expand "occurrences" 1 2) (("1" (propax) nil nil)) nil) ("2" (hide-all-but (1 3)) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("2" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "map") (("2" (expand "occurrences" 2 1) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (lift-if) (("5" (prop) (("1" (expand "occurrences" 1) (("1" (replaces) (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "lt") (("1" (typepred "leq") (("1" (expand "total_preorder?") (("1" (expand "preorder?") (("1" (expand "reflexive?") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (expand "length" 1) (("1" (hide -1 -2 -3) (("1" (expand "occurrences" 1 1) (("1" (expand "map" 1 1) (("1" (expand "length" 1 1) (("1" (expand "occurrences") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (expand "compare2to2") (("2" (assert) (("2" (expand "lt") (("2" (typepred "leq") (("2" (expand "total_preorder?") (("2" (expand "preorder?") (("2" (expand "reflexive?") (("2" (prop) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -1 -2 -3) (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map" 2 1) (("2" (expand "length" 2) (("2" (expand "occurrences" 2 3) (("2" (lemma "occ_list_vs_fjnodes") (("2" (expand "occurrences" 2 1) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (lift-if) (("6" (prop) (("1" (expand "occurrences" 1 1) (("1" (replaces) (("1" (expand "compare2to2" 1 1) (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "map") (("1" (expand "occurrences" 1 1) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 2) (("2" (expand "occurrences" 2 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand "length" 1 1) (("1" (assert) (("1" (expand "compare2to2") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "length" 2) (("2" (assert) (("2" (expand "compare2to2") (("2" (expand "occurrences" 2 1) (("2" (expand "map" 2 1) (("2" (expand "length") (("2" (expand "occurrences" 2 3) (("2" (lemma "occ_list_vs_fjnodes") (("2" (expand "occurrences" 2 1) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "compare2to2" 1) (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "occurrences" 2 4) (("2" (expand "occurrences" 2 1) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (lift-if) (("7" (prop) (("1" (lift-if) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (expand "occurrences" 1) (("1" (replaces) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences") (("1" (expand "map") (("1" (expand "length" 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences") (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "map") (("2" (expand "occurrences") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (expand "compare2to2" 2 1) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 (2 3)) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2 1) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "map") (("2" (expand "occurrences" 2 1) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (expand "occurrences" 1) (("1" (replaces) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences" 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "map") (("1" (expand "occurrences") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (expand "length" 2) (("2" (expand "occurrences" 2) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "map") (("2" (expand "occurrences") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (expand "compare2to2" 2 1) (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 3) (("1" (expand "occurrences") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "map") (("2" (lemma "occ_list_vs_fjnodes") (("2" (expand "occurrences" 2 1) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (lift-if) (("1" (prop) (("1" (expand "occurrences" 1 1) (("1" (replaces) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "map") (("1" (expand "occurrences" 1 1) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2 1) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 2) (("2" (expand "occurrences" 2 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (expand "compare2to2" 2 1) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length") (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 (2 4)) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length") (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 (2 3)) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (expand "occurrences" 1 1) (("1" (replaces) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "compare2to2" 1) (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "map") (("1" (expand "occurrences" 1 1) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 (2 3)) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (expand "compare2to2" 2 1) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length") (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 (2 4)) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length") (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 (2 3)) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("1" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("1" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("1" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "compare2to2" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "rest(compare2to2(x!1)) = compare2to2(rest(rest(x!1)))") (("1" (inst -2 "rest(rest(x!1))") (("1" (split) (("1" (inst?) (("1" (expand "map" 2 1) (("1" (lift-if) (("1" (prop) (("1" (expand "compare2to2" -1) (("1" (assert) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "occurrences" 2 2) (("2" (expand "map" 2 1) (("2" (assert) (("2" (expand "map" 2 1) (("2" (lift-if) (("2" (prop) (("1" (expand "rest" -1) (("1" (expand "^") (("1" (expand "min") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "occurrences" -1 (1 2)) (("2" (case "rest(rest(x!1))`seqfj = rest(rest(x!1`seqfj))") (("1" (replaces) (("1" (expand "finseq_appl") (("1" (case "rest(rest(x!1))`oddList = x!1`oddList") (("1" (replaces) (("1" (both-sides "-" "occurrences(x)(rest(x!1`seqfj)`seq(0))
                                       + occurrences(x)(x!1`seqfj`seq(0))" 2) (("1" (assert) (("1" (expand "occurrences" 2 2) (("1" (replaces) (("1" (case "compare2to2(rest(rest(x!1)))`seqfj = rest(compare2to2(x!1)`seqfj)") (("1" (case "compare2to2(rest(rest(x!1)))`oddList = compare2to2(x!1)`oddList") (("1" (replaces) (("1" (assert) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst -1 "compare2to2(x!1)`seqfj`seq(0)" "x" "smallerones(compare2to2(x!1)`seqfj`seq(0))") (("1" (both-sides "+" "occurrences(x)(rest(x!1`seqfj)`seq(0)) + occurrences(x)(x!1`seqfj`seq(0))" 2) (("1" (assert) (("1" (expand "occurrences" 2 3) (("1" (lift-if) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but -1) (("1" (expand "compare2to2") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (expand "rest" 2) (("2" (expand "^") (("2" (expand "compare2to2" 2) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2" -2) (("1" (assert) (("1" (hide -3) (("1" (expand "occurrences" 1 3) (("1" (expand "map") (("1" (expand "length") (("1" (assert) (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst -1 "x!1`seqfj`seq(1)" "x" "smallerones(x!1`seqfj`seq(1))") (("1" (expand "occurrences" 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand "map") (("1" (assert) nil nil)) nil) ("2" (replaces -1) (("2" (expand "occurrences" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("2" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2" -1) (("2" (assert) (("2" (hide -1) (("2" (expand "occurrences" 2 3) (("2" (expand "map") (("2" (expand "length" 2 1) (("2" (assert) (("2" (assert) (("2" (hide 3) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst -1 "x!1`seqfj`seq(0)" "x" "smallerones(x!1`seqfj`seq(0))") (("1" (expand "occurrences" 2 1) (("1" (lift-if) (("1" (prop) (("1" (expand "map") (("1" (assert) nil nil)) nil) ("2" (replaces) (("2" (expand "occurrences" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("2" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (hide-all-but -1) (("1" (expand "compare2to2") (("1" (expand "length") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (expand "rest" 2) (("2" (expand "^") (("2" (expand "compare2to2" 2) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2" 3) (("1" (assert) (("1" (hide -2) (("1" (expand "occurrences" 1 3) (("1" (expand "map") (("1" (expand "length") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst -1 "x!1`seqfj`seq(1)" "x" "smallerones(x!1`seqfj`seq(1))") (("1" (expand "occurrences" 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand "map") (("1" (assert) nil nil)) nil) ("2" (replaces -1) (("2" (expand "occurrences" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("2" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2" 4) (("2" (assert) (("2" (hide -1) (("2" (expand "occurrences" 2 3) (("2" (expand "map") (("2" (expand "length" 2 1) (("2" (assert) (("2" (hide 3) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst -1 "x!1`seqfj`seq(0)" "x" "smallerones(x!1`seqfj`seq(0))") (("1" (expand "occurrences" 2 1) (("1" (lift-if) (("1" (prop) (("1" (expand "map") (("1" (assert) nil nil)) nil) ("2" (replaces) (("2" (expand "occurrences" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("2" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("2" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 5)) (("2" (case "odd?(x!1`seqfj`length)<=>odd?(rest(rest(x!1))`seqfj`length)") (("1" (expand "compare2to2") (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (hide-all-but (1 2)) (("1" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (grind) nil nil)) nil) ("3" (assert) (("3" (hide-all-but 2) (("3" (expand "rest") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 5)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (split) (("1" (flatten) (("1" (expand "rest") (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (expand "odd?") (("1" (skeep) (("1" (inst 1 "j-1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "rest") (("2" (expand "rest") (("2" (expand "^") (("2" (expand "min") (("2" (expand "odd?") (("2" (skeep) (("2" (inst 1 "j+1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3 4) (("2" (swap-rel -1) (("2" (replaces) (("2" (expand "rest") (("2" (expand "rest") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (hide -1) (("2" (expand "rest") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (hide -1) (("2" (expand "rest") (("2" (assert) (("2" (expand "rest") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "rest") (("2" (expand "rest") (("2" (expand "^") (("2" (expand "min") (("2" (expand "empty_seq") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (decompose-equality) (("1" (expand "rest" 1 1) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand "compare2to2") (("1" (lift-if) (("1" (prop) (("1" (expand "rest") (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1 3)) (("2" (expand "rest") (("2" (expand "odd?") (("2" (skeep) (("2" (inst 1 "j-1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 3)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "even_or_odd") (("2" (inst?) (("2" (assert) (("2" (expand "compare2to2") (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 2 3)) (("1" (expand "rest") (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (expand "odd?") (("1" (skeep) (("1" (inst 1 "j + 1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "rest") (("2" (propax) nil nil)) nil) ("3" (expand "rest") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((occurrences const-decl "nat" firt_phase_ford_johnson nil) (occurrences const-decl "nat" firt_phase_ford_johnson nil) (<= const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (TRUE const-decl "bool" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (listn_0 name-judgement "listn[fjnode[T]](0)" firt_phase_ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (x!1 skolem-const-decl "finseqfj" firt_phase_ford_johnson nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[fjnode])" fjnode_adt nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[fjnode -> T]" fjnode_adt nil) (nodes_TCC1 subtype-tcc nil firt_phase_ford_johnson nil) (reflexive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (occ_list_vs_fjnodes formula-decl nil firt_phase_ford_johnson nil) (^ const-decl "finseq" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (rest const-decl "finseq" seq_extras structures) (below type-eq-decl nil nat_types nil) (map def-decl "nat" firt_phase_ford_johnson nil) (length def-decl "nat" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (empty_seq const-decl "finseq" finite_sequences nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (odd? const-decl "bool" integers nil) (leq formal-const-decl "(total_preorder?[T])" firt_phase_ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (lt const-decl "bool" sorting nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (occurrences def-decl "nat" firt_phase_ford_johnson nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (map def-decl "nat" firt_phase_ford_johnson nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (even_or_odd formula-decl nil naturalnumbers nil) (int_plus_int_is_int application-judgement "int" integers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (list_cons_extensionality formula-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rest const-decl "finseqfj" firt_phase_ford_johnson nil) (permutation const-decl "bool" firt_phase_ford_johnson nil) (compare2to2 const-decl "finseqfj" firt_phase_ford_johnson nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil) (comparePeservesElements-4 nil 3797781707 ("" (measure-induct+ "s`seqfj`length" "s") (("" (expand "permutation") (("" (skeep) (("" (expand "occurrences" -1 (3 4)) (("" (expand "occurrences" 1 (3 4)) (("" (expand "occurrences" -1 (3 4)) (("" (case "length(x!1`seqfj)<=3") (("1" (hide -2) (("1" (case "length(x!1`seqfj) <= 1") (("1" (case "compare2to2(x!1) = x!1") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (expand "compare2to2") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "map" 2 1) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2") (("1" (assert) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (case "occurrences(x)(compare2to2(x!1)`seqfj`seq(0)) = occurrences(x)(x!1`seqfj`seq(0))+ occurrences(x)(x!1`seqfj`seq(1))") (("1" (replaces -1) (("1" (expand "occurrences" 2 2) (("1" (expand "map" 2 1) (("1" (assert) (("1" (expand "map" 2 1) (("1" (lift-if) (("1" (prop) (("1" (expand "rest" -1) (("1" (expand "^") (("1" (expand "min") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "rest" 2 3) (("2" (expand "^") (("2" (case-replace "map(rest(compare2to2(x!1)`seqfj))(occurrences(x)) =0") (("1" (case "length(x!1`seqfj)=2") (("1" (hide -2 -3 3 4) (("1" (expand "compare2to2") (("1" (lift-if) (("1" (prop) (("1" (expand "odd?") (("1" (assert) nil nil)) nil) ("2" (expand "occurrences" 2 2) (("2" (expand "map") (("2" (expand "rest" 2 (1 2)) (("2" (expand "^") (("2" (expand "min") (("2" (expand "empty_seq") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "length(x!1`seqfj) = 3") (("1" (hide -2 -3 1 2 4 5) (("1" (expand "map" 1 1) (("1" (expand "rest" 1 (1 2)) (("1" (expand "^") (("1" (expand "min") (("1" (assert) (("1" (expand "map" 1 1) (("1" (expand "rest" 1 (1 2 3)) (("1" (expand "^") (("1" (expand "min") (("1" (expand "empty_seq") (("1" (expand "finseq_appl") (("1" (expand "compare2to2") (("1" (expand "map") (("1" (expand "length") (("1" (assert) (("1" (assert) (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (expand "occurrences" 1 1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 4)) (("2" (lemma "occ_list_vs_fjnodes") (("2" (copy -1) (("2" (copy -1) (("2" (inst -1 "compare2to2(x!1)`seqfj`seq(0)" "x" "smallerones((compare2to2(x!1)`seqfj`seq(0)))") (("1" (inst -2 "x!1`seqfj`seq(0)" "x" "smallerones(x!1`seqfj`seq(0))") (("1" (inst -3 "x!1`seqfj`seq(1)" "x" "smallerones(x!1`seqfj`seq(1))") (("1" (expand "occurrences" 1 (2 3)) (("1" (replaces) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (expand "occurrences" 1) (("1" (replaces) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "occurrences" 2) (("2" (replaces) (("2" (expand "compare2to2") (("2" (assert) (("2" (expand "lt") (("2" (typepred "leq") (("2" (expand "total_preorder?") (("2" (expand "preorder?") (("2" (expand "reflexive?") (("2" (prop) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -1 -2 -3) (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map" 2 1) (("2" (expand "length" 2) (("2" (expand "map" 2 1) (("2" (expand "occurrences" 2 1) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst -1 "x!1`seqfj`seq(1)" "x" "smallerones(x!1`seqfj`seq(1))") (("2" (replaces) (("2" (expand "occurrences" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "occurrences" 1) (("3" (replaces) (("3" (expand "compare2to2" 1 1) (("3" (lift-if) (("3" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences") (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "map") (("1" (expand "occurrences") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences") (("2" (expand "map") (("2" (expand "length") (("2" (expand "map") (("2" (expand "occurrences") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "occurrences" 2 1) (("4" (replaces) (("4" (expand "compare2to2" 2 1) (("4" (lift-if) (("4" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 2) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst -1 "x!1`seqfj`seq(1)" "x" "smallerones(x!1`seqfj`seq(1))") (("1" (expand "occurrences" 1 2) (("1" (propax) nil nil)) nil) ("2" (hide-all-but (1 3)) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("2" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "map") (("2" (expand "occurrences" 2 1) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (lift-if) (("5" (prop) (("1" (expand "occurrences" 1) (("1" (replaces) (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "lt") (("1" (typepred "leq") (("1" (expand "total_preorder?") (("1" (expand "preorder?") (("1" (expand "reflexive?") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (expand "length" 1) (("1" (hide -1 -2 -3) (("1" (expand "occurrences" 1 1) (("1" (expand "map" 1 1) (("1" (expand "length" 1 1) (("1" (expand "occurrences") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (expand "compare2to2") (("2" (assert) (("2" (expand "lt") (("2" (typepred "leq") (("2" (expand "total_preorder?") (("2" (expand "preorder?") (("2" (expand "reflexive?") (("2" (prop) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -1 -2 -3) (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map" 2 1) (("2" (expand "length" 2) (("2" (expand "occurrences" 2 3) (("2" (lemma "occ_list_vs_fjnodes") (("2" (expand "occurrences" 2 1) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (lift-if) (("6" (prop) (("1" (expand "occurrences" 1 1) (("1" (replaces) (("1" (expand "compare2to2" 1 1) (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "map") (("1" (expand "occurrences" 1 1) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 2) (("2" (expand "occurrences" 2 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand "length" 1 1) (("1" (assert) (("1" (expand "compare2to2") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "length" 2) (("2" (assert) (("2" (expand "compare2to2") (("2" (expand "occurrences" 2 1) (("2" (expand "map" 2 1) (("2" (expand "length") (("2" (expand "occurrences" 2 3) (("2" (lemma "occ_list_vs_fjnodes") (("2" (expand "occurrences" 2 1) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "compare2to2" 1) (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "occurrences" 2 4) (("2" (expand "occurrences" 2 1) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (lift-if) (("7" (prop) (("1" (lift-if) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (expand "occurrences" 1) (("1" (replaces) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences") (("1" (expand "map") (("1" (expand "length" 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences") (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "map") (("2" (expand "occurrences") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (expand "compare2to2" 2 1) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 (2 3)) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2 1) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "map") (("2" (expand "occurrences" 2 1) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (expand "occurrences" 1) (("1" (replaces) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences" 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "map") (("1" (expand "occurrences") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (expand "length" 2) (("2" (expand "occurrences" 2) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "map") (("2" (expand "occurrences") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (expand "compare2to2" 2 1) (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 3) (("1" (expand "occurrences") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "map") (("2" (lemma "occ_list_vs_fjnodes") (("2" (expand "occurrences" 2 1) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (lift-if) (("1" (prop) (("1" (expand "occurrences" 1 1) (("1" (replaces) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "map") (("1" (expand "occurrences" 1 1) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2 1) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 2) (("2" (expand "occurrences" 2 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (expand "compare2to2" 2 1) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length") (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 (2 4)) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length") (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 (2 3)) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (expand "occurrences" 1 1) (("1" (replaces) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "compare2to2" 1) (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "map") (("1" (expand "occurrences" 1 1) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 (2 3)) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (expand "compare2to2" 2 1) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length") (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 (2 4)) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length") (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 (2 3)) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("1" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("1" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("1" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "compare2to2" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (compare2to2 const-decl "finseqfj" firt_phase_ford_johnson nil) (rest const-decl "finseqfj" firt_phase_ford_johnson nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (list_cons_extensionality formula-decl nil list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (int_plus_int_is_int application-judgement "int" integers nil) (even_or_odd formula-decl nil naturalnumbers nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (occurrences def-decl "nat" firt_phase_ford_johnson nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (lt const-decl "bool" sorting nil) (PRED type-eq-decl nil defined_types nil) (total_preorder? const-decl "bool" total_preorder nil) (leq formal-const-decl "(total_preorder?[T])" firt_phase_ford_johnson nil) (odd? const-decl "bool" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (empty_seq const-decl "finseq" finite_sequences nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (rest const-decl "finseq" seq_extras structures) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (int_minus_int_is_int application-judgement "int" integers nil) (^ const-decl "finseq" finite_sequences nil) (occ_list_vs_fjnodes formula-decl nil firt_phase_ford_johnson nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (preorder? const-decl "bool" orders nil) (reflexive? const-decl "bool" relations nil) (nodes_TCC1 subtype-tcc nil firt_phase_ford_johnson nil) (val adt-accessor-decl "[fjnode -> T]" fjnode_adt nil) (nth def-decl "T" list_props nil) (<< adt-def-decl "(strict_well_founded?[fjnode])" fjnode_adt nil) (strict_well_founded? const-decl "bool" orders nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (= const-decl "[T, T -> boolean]" equalities nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (<= const-decl "bool" reals nil)) nil) (comparePeservesElements-3 nil 3739260382 ("" (measure-induct+ "s`seqfj`length" "s") (("" (expand "permutation") (("" (skeep) (("" (expand "occurrences" -1 (3 4)) (("" (expand "occurrences" 1 (3 4)) (("" (case "length(x!1`seqfj)<=3") (("1" (hide -2) (("1" (case "length(x!1`seqfj) <= 1") (("1" (case "compare2to2(x!1) = x!1") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (expand "compare2to2") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "map" 2 2) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2") (("1" (assert) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (case "occurrences(x)(compare2to2(x!1)`seqfj`seq(0)) = occurrences(x)(x!1`seqfj`seq(0))+ occurrences(x)(x!1`seqfj`seq(1))") (("1" (replaces -1) (("1" (expand "occurrences" 2 1) (("1" (expand "map" 2 1) (("1" (assert) (("1" (expand "map" 2 1) (("1" (lift-if) (("1" (prop) (("1" (expand "rest" -1) (("1" (expand "^") (("1" (expand "min") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "rest" 2 3) (("2" (expand "^") (("2" (case-replace "map(rest(compare2to2(x!1)`seqfj))(occurrences(x)) =0") (("1" (case "length(x!1`seqfj)=2") (("1" (hide -2 -3 3 4) (("1" (expand "compare2to2") (("1" (lift-if) (("1" (prop) (("1" (expand "odd?") (("1" (assert) nil nil)) nil) ("2" (expand "occurrences" 2 2) (("2" (expand "map") (("2" (expand "rest" 2 (1 2)) (("2" (expand "^") (("2" (expand "min") (("2" (expand "empty_seq") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "length(x!1`seqfj) = 3") (("1" (hide -2 -3 1 2 4 5) (("1" (expand "map" 1 1) (("1" (expand "rest" 1 (1 2)) (("1" (expand "^") (("1" (expand "min") (("1" (assert) (("1" (expand "map" 1 1) (("1" (expand "rest" 1 (1 2 3)) (("1" (expand "^") (("1" (expand "min") (("1" (expand "empty_seq") (("1" (expand "finseq_appl") (("1" (expand "compare2to2") (("1" (expand "map") (("1" (expand "length") (("1" (assert) (("1" (assert) (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (expand "occurrences" 1 2) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1 4)) (("2" (lemma "occ_list_vs_fjnodes") (("2" (copy -1) (("2" (copy -1) (("2" (inst -1 "compare2to2(x!1)`seqfj`seq(0)" "x" "smallerones((compare2to2(x!1)`seqfj`seq(0)))") (("1" (inst -2 "x!1`seqfj`seq(0)" "x" "smallerones(x!1`seqfj`seq(0))") (("1" (inst -3 "x!1`seqfj`seq(1)" "x" "smallerones(x!1`seqfj`seq(1))") (("1" (expand "occurrences" 1 (2 3)) (("1" (replaces) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (lift-if) (("1" (prop) (("1" (expand "occurrences" 1) (("1" (replaces) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "occurrences" 2) (("2" (replaces) (("2" (expand "compare2to2") (("2" (assert) (("2" (expand "<") (("2" (typepred "<=") (("2" (expand "total_preorder?") (("2" (expand "preorder?") (("2" (expand "reflexive?") (("2" (prop) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -1 -2 -3) (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map" 2 1) (("2" (expand "length" 2) (("2" (expand "map" 2 1) (("2" (expand "occurrences" 2 1) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst -1 "x!1`seqfj`seq(1)" "x" "smallerones(x!1`seqfj`seq(1))") (("2" (replaces) (("2" (expand "occurrences" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "occurrences" 1) (("3" (replaces) (("3" (expand "compare2to2" 1 1) (("3" (lift-if) (("3" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences") (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "map") (("1" (expand "occurrences") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences") (("2" (expand "map") (("2" (expand "length") (("2" (expand "map") (("2" (expand "occurrences") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "occurrences" 2 1) (("4" (replaces) (("4" (expand "compare2to2" 2 1) (("4" (lift-if) (("4" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 2) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst -1 "x!1`seqfj`seq(1)" "x" "smallerones(x!1`seqfj`seq(1))") (("1" (expand "occurrences" 1 2) (("1" (propax) nil nil)) nil) ("2" (hide-all-but (1 3)) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("2" (split) (("1" (propax) nil nil) ("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "map") (("2" (expand "occurrences" 2 1) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("5" (lift-if) (("5" (prop) (("1" (expand "occurrences" 1) (("1" (replaces) (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "<") (("1" (typepred "<=") (("1" (expand "total_preorder?") (("1" (expand "preorder?") (("1" (expand "reflexive?") (("1" (prop) (("1" (inst?) (("1" (assert) (("1" (expand "length" 1) (("1" (hide -1 -2 -3) (("1" (expand "occurrences" 1 1) (("1" (expand "map" 1 1) (("1" (expand "length" 1 1) (("1" (expand "occurrences") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (expand "compare2to2") (("2" (assert) (("2" (expand "<") (("2" (typepred "<=") (("2" (expand "total_preorder?") (("2" (expand "preorder?") (("2" (expand "reflexive?") (("2" (prop) (("2" (inst -1 "x") (("2" (assert) (("2" (hide -1 -2 -3) (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map" 2 1) (("2" (expand "length" 2) (("2" (expand "occurrences" 2 3) (("2" (lemma "occ_list_vs_fjnodes") (("2" (expand "occurrences" 2 1) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (lift-if) (("6" (prop) (("1" (expand "occurrences" 1 1) (("1" (replaces) (("1" (expand "compare2to2" 1 1) (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "map") (("1" (expand "occurrences" 1 1) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 2) (("2" (expand "occurrences" 2 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand "length" 1 1) (("1" (assert) (("1" (expand "compare2to2") (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "length" 2) (("2" (assert) (("2" (expand "compare2to2") (("2" (expand "occurrences" 2 1) (("2" (expand "map" 2 1) (("2" (expand "length") (("2" (expand "occurrences" 2 3) (("2" (lemma "occ_list_vs_fjnodes") (("2" (expand "occurrences" 2 1) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "compare2to2" 1) (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "occurrences" 2 4) (("2" (expand "occurrences" 2 1) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (lift-if) (("7" (prop) (("1" (lift-if) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (expand "occurrences" 1) (("1" (replaces) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences") (("1" (expand "map") (("1" (expand "length" 1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences") (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "map") (("2" (expand "occurrences") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (expand "compare2to2" 2 1) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 (2 3)) (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2 1) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "map") (("2" (expand "occurrences" 2 1) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (expand "occurrences" 1) (("1" (replaces) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences" 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "map") (("1" (expand "occurrences") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (expand "length" 2) (("2" (expand "occurrences" 2) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "map") (("2" (expand "occurrences") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (expand "compare2to2" 2 1) (("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 3) (("1" (expand "occurrences") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "map") (("2" (lemma "occ_list_vs_fjnodes") (("2" (expand "occurrences" 2 1) (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (lift-if) (("1" (prop) (("1" (expand "occurrences" 1 1) (("1" (replaces) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "map") (("1" (expand "occurrences" 1 1) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2 1) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 2) (("2" (expand "occurrences" 2 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (expand "compare2to2" 2 1) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length") (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 (2 4)) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length") (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 (2 3)) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (expand "occurrences" 1 1) (("1" (replaces) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (expand "compare2to2" 1) (("1" (expand "length" 1) (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "map") (("1" (expand "occurrences" 1 1) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 (2 3)) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 1) (("2" (replaces) (("2" (expand "compare2to2" 2 1) (("2" (lift-if) (("2" (prop) (("1" (assert) (("1" (expand "compare2to2") (("1" (expand "length") (("1" (expand "occurrences" 1 1) (("1" (expand "map") (("1" (expand "length" 1) (("1" (expand "occurrences" 1 (2 4)) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (expand "compare2to2") (("2" (expand "length") (("2" (expand "occurrences" 2 1) (("2" (expand "map") (("2" (expand "length" 2) (("2" (expand "occurrences" 2 (2 3)) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst?) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("1" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("1" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (reveal 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("1" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "compare2to2" 1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil) ("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "rest(compare2to2(x!1)) = compare2to2(rest(rest(x!1)))") (("1" (inst -2 "rest(rest(x!1))") (("1" (split) (("1" (inst?) (("1" (expand "map" 2 2) (("1" (lift-if) (("1" (prop) (("1" (expand "compare2to2" -1) (("1" (assert) nil nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "occurrences" 2 1) (("2" (expand "map" 2 1) (("2" (assert) (("2" (expand "map" 2 1) (("2" (lift-if) (("2" (prop) (("1" (expand "rest" -1) (("1" (expand "^") (("1" (expand "min") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "occurrences" -1 (1 2)) (("2" (case "rest(rest(x!1))`seqfj = rest(rest(x!1`seqfj))") (("1" (replaces) (("1" (expand "finseq_appl") (("1" (case "rest(rest(x!1))`oddList = x!1`oddList") (("1" (replaces) (("1" (both-sides "-" "occurrences(x)(rest(x!1`seqfj)`seq(0))
       + occurrences(x)(x!1`seqfj`seq(0))" 2) (("1" (assert) (("1" (expand "occurrences" 2 2) (("1" (replaces) (("1" (case "compare2to2(rest(rest(x!1)))`seqfj = rest(compare2to2(x!1)`seqfj)") (("1" (case "compare2to2(rest(rest(x!1)))`oddList = compare2to2(x!1)`oddList") (("1" (replaces) (("1" (assert) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst -1 "compare2to2(x!1)`seqfj`seq(0)" "x" "smallerones(compare2to2(x!1)`seqfj`seq(0))") (("1" (both-sides "+" "occurrences(x)(rest(x!1`seqfj)`seq(0)) + occurrences(x)(x!1`seqfj`seq(0))" 2) (("1" (assert) (("1" (expand "occurrences" 2 3) (("1" (lift-if) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but -1) (("1" (expand "compare2to2") (("1" (assert) (("1" (lift-if) (("1" (prop) (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (expand "length") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (expand "rest" 2) (("2" (expand "^") (("2" (expand "compare2to2" 2) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2" -2) (("1" (assert) (("1" (hide -3) (("1" (expand "occurrences" 1 3) (("1" (expand "map") (("1" (expand "length") (("1" (assert) (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst -1 "x!1`seqfj`seq(1)" "x" "smallerones(x!1`seqfj`seq(1))") (("1" (expand "occurrences" 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand "map") (("1" (assert) nil nil)) nil) ("2" (replaces -1) (("2" (expand "occurrences" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("2" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2" -1) (("2" (assert) (("2" (hide -1) (("2" (expand "occurrences" 2 3) (("2" (expand "map") (("2" (expand "length" 2 1) (("2" (assert) (("2" (assert) (("2" (hide 3) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst -1 "x!1`seqfj`seq(0)" "x" "smallerones(x!1`seqfj`seq(0))") (("1" (expand "occurrences" 2 1) (("1" (lift-if) (("1" (prop) (("1" (expand "map") (("1" (assert) nil nil)) nil) ("2" (replaces) (("2" (expand "occurrences" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("2" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (hide-all-but -1) (("1" (expand "compare2to2") (("1" (expand "length") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (replaces) (("2" (expand "rest" 2) (("2" (expand "^") (("2" (expand "compare2to2" 2) (("2" (lift-if) (("2" (prop) (("1" (expand "compare2to2" 3) (("1" (assert) (("1" (hide -2) (("1" (expand "occurrences" 1 3) (("1" (expand "map") (("1" (expand "length") (("1" (assert) (("1" (assert) (("1" (hide 2) (("1" (lemma "occ_list_vs_fjnodes") (("1" (inst -1 "x!1`seqfj`seq(1)" "x" "smallerones(x!1`seqfj`seq(1))") (("1" (expand "occurrences" 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand "map") (("1" (assert) nil nil)) nil) ("2" (replaces -1) (("2" (expand "occurrences" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("2" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2" 4) (("2" (assert) (("2" (hide -1) (("2" (expand "occurrences" 2 3) (("2" (expand "map") (("2" (expand "length" 2 1) (("2" (assert) (("2" (hide 3) (("2" (lemma "occ_list_vs_fjnodes") (("2" (inst -1 "x!1`seqfj`seq(0)" "x" "smallerones(x!1`seqfj`seq(0))") (("1" (expand "occurrences" 2 1) (("1" (lift-if) (("1" (prop) (("1" (expand "map") (("1" (assert) nil nil)) nil) ("2" (replaces) (("2" (expand "occurrences" 2 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("2" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (lemma "nodes_TCC1") (("2" (inst?) (("2" (split) (("1" (propax) nil nil) ("2" (skeep) (("2" (typepred "i") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 5)) (("2" (case "odd?(x!1`seqfj`length)<=>odd?(rest(rest(x!1))`seqfj`length)") (("1" (expand "compare2to2") (("1" (lift-if) (("1" (prop) (("1" (assert) (("1" (hide-all-but (1 2)) (("1" (decompose-equality) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (grind) nil nil)) nil) ("3" (assert) (("3" (hide-all-but 2) (("3" (expand "rest") (("3" (propax) nil nil)) nil)) nil)) nil) ("4" (hide-all-but (1 5)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3) (("2" (split) (("1" (flatten) (("1" (expand "rest") (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (expand "odd?") (("1" (skeep) (("1" (inst 1 "j-1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "rest") (("2" (expand "rest") (("2" (expand "^") (("2" (expand "min") (("2" (expand "odd?") (("2" (skeep) (("2" (inst 1 "j+1") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3 4) (("2" (swap-rel -1) (("2" (replaces) (("2" (expand "rest") (("2" (expand "rest") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (hide -1) (("2" (expand "rest") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (hide -1) (("2" (expand "rest") (("2" (assert) (("2" (expand "rest") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "rest") (("2" (expand "rest") (("2" (expand "^") (("2" (expand "min") (("2" (expand "empty_seq") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (decompose-equality) (("1" (expand "rest" 1 1) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand "compare2to2") (("1" (lift-if) (("1" (prop) (("1" (expand "rest") (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1 3)) (("2" (expand "rest") (("2" (expand "odd?") (("2" (skeep) (("2" (inst 1 "j-1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 3)) (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "even_or_odd") (("2" (inst?) (("2" (assert) (("2" (expand "compare2to2") (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 2 3)) (("1" (expand "rest") (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (expand "odd?") (("1" (skeep) (("1" (inst 1 "j + 1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "rest") (("2" (propax) nil nil)) nil) ("3" (expand "rest") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (decompose-equality) (("1" (grind) nil nil) ("2" (decompose-equality) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((<= const-decl "bool" reals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (TRUE const-decl "bool" booleans nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (= const-decl "[T, T -> boolean]" equalities nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (strict_well_founded? const-decl "bool" orders nil) (<< adt-def-decl "(strict_well_founded?[fjnode])" fjnode_adt nil) (nth def-decl "T" list_props nil) (val adt-accessor-decl "[fjnode -> T]" fjnode_adt nil) (nodes_TCC1 subtype-tcc nil firt_phase_ford_johnson nil) (reflexive? const-decl "bool" relations nil) (preorder? const-decl "bool" orders nil) (NOT const-decl "[bool -> bool]" booleans nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (occ_list_vs_fjnodes formula-decl nil firt_phase_ford_johnson nil) (^ const-decl "finseq" finite_sequences nil) (int_minus_int_is_int application-judgement "int" integers nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (rest const-decl "finseq" seq_extras structures) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (empty_seq const-decl "finseq" finite_sequences nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (odd? const-decl "bool" integers nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (occurrences def-decl "nat" firt_phase_ford_johnson nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (even_or_odd formula-decl nil naturalnumbers nil) (int_plus_int_is_int application-judgement "int" integers nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (list_cons_extensionality formula-decl nil list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (rest const-decl "finseqfj" firt_phase_ford_johnson nil) (compare2to2 const-decl "finseqfj" firt_phase_ford_johnson nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) nil) (comparePeservesElements-2 nil 3739260071 ("" (measure-induct+ "s`seqfj`length" "s") (("" (expand "permutation") (("" (skeep) (("" (expand "occurrences" -1 (3 4)) (("" (expand "occurrences" 1 (3 4)) (("" (case "length(x!1`seqfj)<=2") (("1" (postpone) nil nil) ("2" (case "rest(compare2to2(x!1)) = compare2to2(rest(rest(x!1)))") (("1" (case " occurrences(x)(rest(x!1`seqfj)`seq(0)) +
                  occurrences(x)(x!1`seqfj`seq(0))= occurrences(x)(compare2to2(x!1)`seqfj`seq(0))") (("1" (expand "map" 2 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 2)) (("1" (expand "compare2to2") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (inst -3 "rest(rest(x!1))") (("2" (split) (("1" (inst?) (("1" (swap-rel -3) (("1" (replace -3) (("1" (expand "rest" -1 (5 6)) (("1" (swap-rel -1) (("1" (replaces) (("1" (case-replace "rest(rest(x!1))`oddList =x!1`oddList") (("1" (assert) (("1" (swap-rel -2) (("1" (replaces -2) (("1" (expand "occurrences" 2 1) (("1" (expand "map" 2 1) (("1" (expand "finseq_appl") (("1" (expand "map" 2 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 3)) (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "occurrences" 2 2) (("2" (expand "rest" 2 (3 4)) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (expand "rest") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (expand "rest") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "rest") (("2" (assert) (("2" (expand "^") (("2" (case "val(x!1`seqfj`seq(0)) > val(x!1`seqfj`seq(1))") (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "occurrences" 1 (1 2)) (("1" (lift-if) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (expand "occurrences") (("1" (assert) nil nil)) nil) ("2" (expand "occurrences" 2 2) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (expand "occurrences") (("1" (lift-if) (("1" (prop) (("1" (expand "add_fold") (("1" (expand "add_fold") (("1" (expand "length" 2) (("1" (expand "occurrences") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 2) (("2" (lift-if) (("2" (prop) (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (expand "add_fold" 2 2) (("2" (expand "length" 2 1) (("2" (expand "add_fold" 2 2) (("2" (expand "occurrences" 2 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (expand "occurrences" 1 2) (("1" (lift-if) (("1" (prop) (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (expand "add_fold" 2 2) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (expand "compare2to2") (("3" (assert) nil nil)) nil)) nil) ("4" (hide-all-but (1 2)) (("4" (assert) nil nil)) nil) ("5" (hide-all-but (1 2)) (("5" (expand "rest") (("5" (assert) (("5" (expand "^") (("5" (expand "min") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (decompose-equality) (("1" (expand "rest" 1 1) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand "compare2to2") (("1" (lift-if) (("1" (prop) (("1" (expand "rest") (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1 3)) (("2" (expand "rest") (("2" (expand "odd?") (("2" (skeep) (("2" (inst 1 "j-1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 3)) (("3" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "even_or_odd") (("2" (inst?) (("2" (assert) (("2" (expand "compare2to2") (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 2 3)) (("1" (expand "rest") (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (expand "odd?") (("1" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "rest") (("2" (propax) nil nil)) nil) ("3" (expand "rest") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil nil) (comparePeservesElements-1 nil 3719094149 ("" (measure-induct+ "s`seqfj`length" "s") (("" (expand "permutation") (("" (skeep) (("" (expand "occurrences" -1 (3 4)) (("" (expand "occurrences" 1 (3 4)) (("" (case "length(x!1`seqfj)<2") (("1" (postpone) nil nil) ("2" (case "rest(compare2to2(x!1)) = compare2to2(rest(rest(x!1)))") (("1" (case " occurrences(x)(rest(x!1`seqfj)`seq(0)) +
       occurrences(x)(x!1`seqfj`seq(0))= occurrences(x)(compare2to2(x!1)`seqfj`seq(0))") (("1" (expand "map" 2 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 2)) (("1" (expand "compare2to2") (("1" (assert) nil nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (inst -3 "rest(rest(x!1))") (("2" (split) (("1" (inst?) (("1" (swap-rel -3) (("1" (replace -3) (("1" (expand "rest" -1 (5 6)) (("1" (swap-rel -1) (("1" (replaces) (("1" (case-replace "rest(rest(x!1))`oddList =x!1`oddList") (("1" (assert) (("1" (swap-rel -2) (("1" (replaces -2) (("1" (expand "occurrences" 2 1) (("1" (expand "map" 2 1) (("1" (expand "finseq_appl") (("1" (expand "map" 2 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 3)) (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "finseq_appl") (("2" (expand "occurrences" 2 2) (("2" (expand "rest" 2 (3 4)) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (expand "rest") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 4)) (("2" (expand "rest") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 2)) (("2" (expand "rest") (("2" (assert) (("2" (expand "^") (("2" (case "val(x!1`seqfj`seq(0)) > val(x!1`seqfj`seq(1))") (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "occurrences" 1 (1 2)) (("1" (lift-if) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (expand "occurrences") (("1" (assert) nil nil)) nil) ("2" (expand "occurrences" 2 2) (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (expand "occurrences") (("1" (lift-if) (("1" (prop) (("1" (expand "add_fold") (("1" (expand "add_fold") (("1" (expand "length" 2) (("1" (expand "occurrences") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 2 2) (("2" (lift-if) (("2" (prop) (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (expand "add_fold" 2 2) (("2" (expand "length" 2 1) (("2" (expand "add_fold" 2 2) (("2" (expand "occurrences" 2 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (lift-if) (("2" (prop) (("1" (expand "occurrences" 1 2) (("1" (lift-if) (("1" (prop) (("1" (expand "length") (("1" (assert) nil nil)) nil) ("2" (expand "add_fold" 2 2) (("2" (assert) (("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (expand "compare2to2") (("3" (assert) nil nil)) nil)) nil) ("4" (hide-all-but (1 2)) (("4" (assert) nil nil)) nil) ("5" (hide-all-but (1 2)) (("5" (expand "rest") (("5" (assert) (("5" (expand "^") (("5" (expand "min") (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -1 3) (("2" (decompose-equality) (("1" (expand "rest" 1 1) (("1" (expand "compare2to2" 1 1) (("1" (lift-if) (("1" (prop) (("1" (expand "compare2to2") (("1" (lift-if) (("1" (prop) (("1" (expand "rest") (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (expand "empty_seq") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (assert) nil nil) ("5" (assert) nil nil) ("6" (assert) nil nil) ("7" (assert) nil nil) ("8" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -2 1 3)) (("2" (expand "rest") (("2" (expand "odd?") (("2" (skeep) (("2" (inst 1 "j-1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 3)) (("3" (postpone) nil nil)) nil)) nil)) nil)) nil) ("2" (lemma "even_or_odd") (("2" (inst?) (("2" (assert) (("2" (expand "compare2to2") (("2" (lift-if) (("2" (prop) (("1" (hide-all-but (-1 2 3)) (("1" (expand "rest") (("1" (expand "rest") (("1" (expand "^") (("1" (expand "min") (("1" (prop) (("1" (expand "odd?") (("1" (expand "empty_seq") (("1" (propax) nil nil)) nil)) nil) ("2" (expand "empty_seq") (("2" (expand "odd?") (("2" (propax) nil nil)) nil)) nil) ("3" (expand "odd?") (("3" (skeep) (("3" (inst 3 "j+1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "rest") (("2" (propax) nil nil)) nil) ("3" (expand "rest") (("3" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) (("1" (postpone) nil nil) ("2" (postpone) nil nil) ("3" (postpone) nil nil) ("4" (postpone) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((> const-decl "bool" reals nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (rat_div_nzrat_is_rat application-judgement "rat" rationals nil) (empty_seq const-decl "finseq" finite_sequences nil) (IFF const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (int_min application-judgement "{k: int | k <= i AND k <= j}" real_defs nil) (int_plus_int_is_int application-judgement "int" integers nil) (odd? const-decl "bool" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (finseq_appl const-decl "[below[length(fs)] -> T]" finite_sequences nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (^ const-decl "finseq" finite_sequences nil) (length def-decl "nat" list_props nil) (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) (NOT const-decl "[bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (rest const-decl "finseq" seq_extras structures) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (compare2to2 const-decl "finseqfj" firt_phase_ford_johnson nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (fjnode type-decl nil fjnode_adt nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (seqfjBottPreservesElements 0 (seqfjBottPreservesElements-1 nil 3733828040 ("" (measure-induct+ "length(s`seqfj)" "s") (("" (expand "seqfjBottleneck" 1) (("" (lift-if) (("" (prop) (("1" (inst -2 "compare2to2(x!1)") (("1" (prop) (("1" (lemma "comparePeservesElements") (("1" (inst?) (("1" (lemma "permutation_equiv") (("1" (flatten) (("1" (hide -1 -2) (("1" (inst -1 "x!1" "compare2to2(x!1)" "seqfjBottleneck(compare2to2(x!1))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (expand "compare2to2") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -1 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (permutation_equiv formula-decl nil firt_phase_ford_johnson nil) (comparePeservesElements formula-decl nil firt_phase_ford_johnson nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (compare2to2 const-decl "finseqfj" firt_phase_ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (permutation const-decl "bool" firt_phase_ford_johnson nil) (seqfjBottleneck def-decl "finseqfj" firt_phase_ford_johnson nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (oneStepCorrectionER_TCC1 0 (oneStepCorrectionER_TCC1-1 nil 3718705741 ("" (skeep) (("" (typepred "n") (("" (lemma "both_sides_expt_gt1_lt") (("" (inst -1 "2" "n" "n+1") (("" (assert) nil nil)) nil)) nil)) nil)) nil) ((plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (^ const-decl "real" exponentiation nil) (>= const-decl "bool" reals nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (<= const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (posreal nonempty-type-eq-decl nil real_types nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (both_sides_expt_gt1_lt formula-decl nil exponentiation nil)) shostak (oneStepCorrectionER subtype "firt_phase_ford_johnson.n" "{n: naturalnumbers.nat | reals.<=(exponentiation.^(2, n), length(firt_phase_ford_johnson.s`seqfj))}"))) (oneStepCorrectionER_TCC2 0 (oneStepCorrectionER_TCC2-1 nil 3719264110 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (listn_0 name-judgement "listn[fjnode[T]](0)" firt_phase_ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (occurrences const-decl "nat" firt_phase_ford_johnson nil) (occurrences const-decl "nat" firt_phase_ford_johnson nil) (permutation const-decl "bool" firt_phase_ford_johnson nil) (^ const-decl "real" exponentiation nil) (nstructER? const-decl "bool" firt_phase_ford_johnson nil) (posint_exp application-judgement "posint" exponentiation nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil)) shostak (oneStepCorrectionER subtype "(number_fields.+)(firt_phase_ford_johnson.n, 1)" "{n: naturalnumbers.nat | reals.<=(exponentiation.^(2, n), length(firt_phase_ford_johnson.s`seqfj))}"))) (oneStepCorrectionER 0 (oneStepCorrectionER-3 nil 3797781878 ("" (skeep) (("" (skeep) (("" (expand "nstructER?" 1) (("" (split) (("1" (lemma "comparePeservesElements") (("1" (inst -1 "s1") (("1" (expand "nstructER?") (("1" (flatten) (("1" (hide-all-but (-1 -2 1)) (("1" (expand "permutation") (("1" (skeep) (("1" (inst -1 "x") (("1" (inst -2 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (expand "nstructER?") (("2" (flatten) (("2" (hide-all-but (-2 -8 1)) (("2" (replaces -1) (("2" (case " floor(floor(s`seqfj`length / 2 ^ n) / 2) = floor(s`seqfj`length / 2 ^ n / 2)") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (lemma "floor_div") (("2" (inst -1 "floor(s`seqfj`length / 2 ^ n / 2)" "2" "floor(s`seqfj`length / 2 ^ n)") (("2" (assert) (("2" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (expand "nstruct?") (("3" (prop) (("1" (expand "nstructER?") (("1" (flatten) (("1" (hide-all-but (-3 -7 1)) (("1" (typepred "k") (("1" (expand "compare2to2" -1) (("1" (assert) (("1" (inst -2 "IF lt(val(s1`seqfj`seq(2*k)), val(s1`seqfj`seq(2*k+1))) THEN 2*k+1 ELSE 2*k ENDIF") (("1" (lift-if) (("1" (prop) (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "length") (("1" (expand "nstruct?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (expand "length") (("2" (expand "nstruct?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nstructER?") (("2" (flatten) (("2" (hide-all-but (-3 -8 1)) (("2" (skeep) (("2" (case-replace "i=0") (("1" (expand "nth") (("1" (expand "compare2to2") (("1" (prop) (("1" (inst -4 "2*k") nil nil) ("2" (inst -3 "1+2*k") nil nil) ("3" (assert) (("3" (reveal -6) (("3" (propax) nil nil)) nil)) nil) ("4" (reveal -6) (("4" (assert) (("4" (lift-if) (("4" (typepred "leq") (("4" (expand "total_preorder?") (("4" (flatten) (("4" (expand "dichotomous?") (("4" (prop) (("1" (assert) (("1" (expand "lt") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "lt") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (lift-if) (("2" (prop) (("1" (expand "nth") (("1" (assert) (("1" (inst -3 "1+ 2*k") (("1" (expand "nstruct?" -3) (("1" (prop) (("1" (inst -3 "i-1") (("1" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (expand "compare2to2") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth") (("2" (assert) (("2" (inst -3 "1 + 2*k") (("2" (expand "nstruct?") (("2" (prop) (("1" (inst?) (("1" (flatten) nil nil)) nil) ("2" (typepred "i") (("2" (expand "compare2to2") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "nth") (("3" (assert) (("3" (inst -2 "2*k") (("3" (expand "nstruct?" -2) (("3" (prop) (("1" (inst -3 "i-1") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "compare2to2") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "nth") (("4" (assert) (("4" (inst -2 "2*k") (("4" (expand "nstruct?") (("4" (prop) (("1" (inst -3 "i-1") (("1" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (expand "compare2to2") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal -6) (("5" (propax) nil nil)) nil) ("6" (reveal -6) (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "compare2to2") (("4" (assert) (("4" (expand "nstructER?") (("4" (lift-if) (("4" (flatten) (("4" (hide-all-but (-2 -4 -8 1)) (("4" (replaces -1) (("4" (prop) (("1" (expand "length_odd" 1) (("1" (assert) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length_odd" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (case "odd?(s1`seqfj`length)") (("1" (skeep) (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "nth") (("1" (lift-if) (("1" (prop) (("1" (expand "nstructER?") (("1" (flatten) (("1" (hide -4 -5 -7) (("1" (inst -4 "s1`seqfj`length - 1") (("1" (inst -6 "i-1") (("1" (skeep) (("1" (typepred "m") (("1" (expand "nstruct?" -6) (("1" (flatten) (("1" (hide -7) (("1" (expand "nstruct?" -8) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nstructER?") (("2" (flatten) (("2" (hide -1 -3 -4 -5 -6) (("2" (inst? -2) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (expand "nstructER?") (("2" (flatten) (("2" (hide-all-but (-5 2)) (("2" (skeep) (("2" (inst? -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "nstructER?") (("6" (flatten) (("6" (hide -1 -2) (("6" (skeep) (("6" (case "odd?(s1`seqfj`length)") (("1" (expand "compare2to2") (("1" (assert) (("1" (case-replace "i=0") (("1" (expand "nth" 1) (("1" (inst 1 "n") (("1" (hide-all-but (-3 -7 1)) (("1" (inst?) nil nil)) nil) ("2" (reveal -2) (("2" (replaces) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst -5 "i - 1") (("1" (skeep) (("1" (inst 2 "m") nil nil)) nil) ("2" (typepred "i") (("2" (hide-all-but (-1 -2 1)) (("2" (expand "compare2to2") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (hide-all-but (-2 -4 2)) (("2" (inst -2 "i") (("1" (skeep) (("1" (inst?) nil nil)) nil) ("2" (typepred "i") (("2" (expand "compare2to2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil firt_phase_ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (permutation const-decl "bool" firt_phase_ford_johnson nil) (listn_0 name-judgement "listn[fjnode[T]](0)" firt_phase_ford_johnson nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (comparePeservesElements formula-decl nil firt_phase_ford_johnson nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (floor_div formula-decl nil floor_ceil nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (expt def-decl "real" exponentiation nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (real nonempty-type-from-decl nil reals nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (compare2to2 const-decl "finseqfj" firt_phase_ford_johnson nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (dichotomous? const-decl "bool" orders nil) (nth def-decl "T" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (val adt-accessor-decl "[fjnode -> T]" fjnode_adt nil) (lt const-decl "bool" sorting nil) (leq formal-const-decl "(total_preorder?[T])" firt_phase_ford_johnson nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (length def-decl "nat" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (length_odd def-decl "nat" firt_phase_ford_johnson nil) (j skolem-const-decl "below[length(compare2to2(s1)`oddList)]" firt_phase_ford_johnson nil) (s1 skolem-const-decl "finseqfj" firt_phase_ford_johnson nil) (odd? const-decl "bool" integers nil) (s skolem-const-decl "{s: finseqfj | plain_finseqfj(s)}" firt_phase_ford_johnson nil) (n skolem-const-decl "{n: nat | 2 ^ (1 + n) <= length(s`seqfj)}" firt_phase_ford_johnson nil) (i skolem-const-decl "below[length(compare2to2(s1)`oddList)]" firt_phase_ford_johnson nil) (nstructER? const-decl "bool" firt_phase_ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (posint_exp application-judgement "posint" exponentiation nil)) nil) (oneStepCorrectionER-2 nil 3733830834 ("" (skeep) (("" (skeep) (("" (expand "nstructER?" 1) (("" (split) (("1" (lemma "comparePeservesElements") (("1" (inst -1 "s1") (("1" (expand "nstructER?") (("1" (flatten) (("1" (hide-all-but (-1 -2 1)) (("1" (expand "permutation") (("1" (skeep) (("1" (inst -1 "x") (("1" (inst -2 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (expand "nstructER?") (("2" (flatten) (("2" (hide-all-but (-2 -8 1)) (("2" (replaces -1) (("2" (case " floor(floor(s`seqfj`length / 2 ^ n) / 2) = floor(s`seqfj`length / 2 ^ n / 2)") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (lemma "floor_div") (("2" (inst -1 "floor(s`seqfj`length / 2 ^ n / 2)" "2" "floor(s`seqfj`length / 2 ^ n)") (("2" (assert) (("2" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (expand "nstruct?") (("3" (prop) (("1" (expand "nstructER?") (("1" (flatten) (("1" (hide-all-but (-3 -7 1)) (("1" (typepred "k") (("1" (expand "compare2to2" -1) (("1" (assert) (("1" (inst -2 "IF val(s1`seqfj`seq(2*k)) < val(s1`seqfj`seq(2*k+1)) THEN 2*k+1 ELSE 2*k ENDIF") (("1" (lift-if) (("1" (prop) (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "length") (("1" (expand "nstruct?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (expand "length") (("2" (expand "nstruct?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "<=") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nstructER?") (("2" (flatten) (("2" (hide-all-but (-3 -8 1)) (("2" (skeep) (("2" (case-replace "i=0") (("1" (expand "nth") (("1" (expand "compare2to2") (("1" (prop) (("1" (inst -4 "2*k") nil nil) ("2" (inst -3 "1+2*k") nil nil) ("3" (assert) (("3" (reveal -6) (("3" (propax) nil nil)) nil)) nil) ("4" (reveal -6) (("4" (assert) (("4" (lift-if) (("4" (typepred "<=") (("4" (expand "total_preorder?") (("4" (flatten) (("4" (expand "dichotomous?") (("4" (expand "<") (("4" (prop) (("4" (inst? -2) (("4" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (lift-if) (("2" (prop) (("1" (expand "nth") (("1" (assert) (("1" (inst -3 "1+ 2*k") (("1" (expand "nstruct?" -3) (("1" (prop) (("1" (inst -3 "i-1") (("1" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (expand "compare2to2") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth") (("2" (assert) (("2" (inst -3 "1 + 2*k") (("2" (expand "nstruct?") (("2" (prop) (("1" (inst?) (("1" (flatten) nil nil)) nil) ("2" (typepred "i") (("2" (expand "compare2to2") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (expand "nth") (("3" (assert) (("3" (inst -2 "2*k") (("3" (expand "nstruct?" -2) (("3" (prop) (("1" (inst -3 "i-1") (("1" (flatten) (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "compare2to2") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "nth") (("4" (assert) (("4" (inst -2 "2*k") (("4" (expand "nstruct?") (("4" (prop) (("1" (inst -3 "i-1") (("1" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (expand "compare2to2") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (reveal -6) (("5" (propax) nil nil)) nil) ("6" (reveal -6) (("6" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "compare2to2") (("4" (assert) (("4" (expand "nstructER?") (("4" (lift-if) (("4" (flatten) (("4" (hide-all-but (-2 -4 -8 1)) (("4" (replaces -1) (("4" (prop) (("1" (expand "length_odd" 1) (("1" (assert) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length_odd" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (case "odd?(s1`seqfj`length)") (("1" (skeep) (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "nth") (("1" (lift-if) (("1" (prop) (("1" (expand "nstructER?") (("1" (flatten) (("1" (hide -4 -5 -7) (("1" (inst -4 "s1`seqfj`length - 1") (("1" (inst -6 "i-1") (("1" (skeep) (("1" (typepred "m") (("1" (expand "nstruct?" -6) (("1" (flatten) (("1" (hide -7) (("1" (expand "nstruct?" -8) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nstructER?") (("2" (flatten) (("2" (hide -1 -3 -4 -5 -6) (("2" (inst? -2) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (expand "nstructER?") (("2" (flatten) (("2" (hide-all-but (-5 2)) (("2" (skeep) (("2" (inst? -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (expand "nstructER?") (("6" (flatten) (("6" (hide -1 -2) (("6" (skeep) (("6" (case "odd?(s1`seqfj`length)") (("1" (expand "compare2to2") (("1" (assert) (("1" (case-replace "i=0") (("1" (expand "nth" 1) (("1" (inst 1 "n") (("1" (hide-all-but (-3 -7 1)) (("1" (inst?) nil nil)) nil) ("2" (reveal -2) (("2" (replaces) nil nil)) nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst -5 "i - 1") (("1" (skeep) (("1" (inst 2 "m") nil nil)) nil) ("2" (typepred "i") (("2" (hide-all-but (-1 -2 1)) (("2" (expand "compare2to2") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (hide-all-but (-2 -4 2)) (("2" (inst -2 "i") (("1" (skeep) (("1" (inst?) nil nil)) nil) ("2" (typepred "i") (("2" (expand "compare2to2") (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil firt_phase_ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (comparePeservesElements formula-decl nil firt_phase_ford_johnson nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (TRUE const-decl "bool" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (floor_div formula-decl nil floor_ceil nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (expt def-decl "real" exponentiation nil) (number nonempty-type-decl nil numbers nil) (= const-decl "[T, T -> boolean]" equalities nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (integer nonempty-type-from-decl nil integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (compare2to2 const-decl "finseqfj" firt_phase_ford_johnson nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (dichotomous? const-decl "bool" orders nil) (nth def-decl "T" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (even_plus_odd_is_odd application-judgement "odd_int" integers nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (val adt-accessor-decl "[fjnode -> T]" fjnode_adt nil) (total_preorder? const-decl "bool" total_preorder nil) (PRED type-eq-decl nil defined_types nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (length def-decl "nat" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (length_odd def-decl "nat" firt_phase_ford_johnson nil) (odd? const-decl "bool" integers nil) (nstructER? const-decl "bool" firt_phase_ford_johnson nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (posint_exp application-judgement "posint" exponentiation nil)) shostak) (oneStepCorrectionER-1 nil 3718705747 ("" (skeep) (("" (skeep) (("" (expand "nstructER?" 1) (("" (split) (("1" (lemma "comparePeservesElements") (("1" (inst -1 "s" "s1") (("1" (expand "nstructER?") (("1" (flatten) (("1" (hide-all-but (-1 -2 1)) (("1" (expand "permutation") (("1" (skeep) (("1" (inst -1 "x") (("1" (inst -2 "x") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (expand "nstructER?") (("2" (flatten) (("2" (hide-all-but (-2 -8 1)) (("2" (replaces -1) (("2" (case " floor(floor(s`seqfj`length / 2 ^ n) / 2) = floor(s`seqfj`length / 2 ^ n / 2)") (("1" (replaces -1) (("1" (grind) nil nil)) nil) ("2" (hide 2) (("2" (lemma "floor_div") (("2" (inst -1 "floor(s`seqfj`length / 2 ^ n / 2)" "2" "floor(s`seqfj`length / 2 ^ n)") (("2" (assert) (("2" (split) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (expand "nstruct?") (("3" (prop) (("1" (expand "nstructER?") (("1" (flatten) (("1" (hide-all-but (-3 -8 1)) (("1" (inst -1 "IF val(s1`seqfj`seq(2*k)) <  val(s1`seqfj`seq(1+2*k)) THEN 1 + 2*k ELSE 2*k ENDIF") (("1" (lift-if) (("1" (prop) (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "length") (("1" (expand "nstruct?") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) (("2" (expand "length") (("2" (expand "nstruct?") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (typepred "k") (("2" (expand "compare2to2" -1) (("2" (assert) nil nil)) nil)) nil)) nil) ("3" (flatten) (("3" (typepred "k") (("3" (expand "compare2to2" -1) (("3" (assert) nil nil)) nil)) nil)) nil) ("4" (typepred "k") (("4" (expand "compare2to2" -1) (("4" (assert) nil nil)) nil)) nil) ("5" (typepred "k") (("5" (expand "compare2to2" -1) (("5" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nstructER?") (("2" (flatten) (("2" (hide-all-but (-3 -8 1)) (("2" (skeep) (("2" (case-replace "i=0") (("1" (expand "nth") (("1" (expand "compare2to2") (("1" (prop) (("1" (inst -4 "2*k") nil nil) ("2" (inst -3 "1+2*k") nil nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (lift-if) (("2" (prop) (("1" (expand "nth") (("1" (assert) (("1" (inst -3 "1+ 2*k") (("1" (expand "nstruct?" -3) (("1" (prop) (("1" (inst -3 "i-1") (("1" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (expand "compare2to2") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth") (("2" (assert) (("2" (inst -2 "2 * k") (("2" (expand "nstruct?" -2) (("2" (prop) (("1" (inst -3 "i-1") (("1" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (expand "compare2to2") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("4" (expand "compare2to2") (("4" (assert) (("4" (expand "nstructER?") (("4" (lift-if) (("4" (flatten) (("4" (hide-all-but (-2 -4 -8 1)) (("4" (replaces -1) (("4" (prop) (("1" (expand "length_odd" 1) (("1" (assert) (("1" (expand "length") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "length_odd" 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("5" (skeep) (("5" (case-replace "m=n") (("1" (split) (("1" (flatten) (("1" (inst 1 "0") (("1" (expand "nth") (("1" (expand "nstructER?") (("1" (flatten) (("1" (hide -3 -6 -7 -8 -9) (("1" (expand "compare2to2") (("1" (replaces -3) (("1" (assert) (("1" (inst -3 "floor(s`seqfj`length / 2 ^ n) - 1") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length_odd") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (skeep) (("2" (expand "compare2to2") (("2" (lift-if) (("2" (prop) (("1" (expand "nstructER?") (("1" (flatten) (("1" (replaces -6) nil nil)) nil)) nil) ("2" (expand "nstructER?") (("2" (flatten) (("2" (hide-all-but (-1 -2 -9 -10 1 2)) (("2" (split) (("1" (case-replace "i=0") (("1" (hide-all-but (-2 -3)) (("1" (expand "nstruct?") (("1" (expand "nth") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case " FORALL (i: below[length(s1`oddList)] | i/=0):
        length(smallerones(nth(s1`oddList, 0))) >
         length(smallerones(nth(s1`oddList, i)))") (("1" (inst -1 "i") (("1" (hide-all-but (-1 -2 -3)) (("1" (expand "nstruct?") (("1" (expand "nth" -1 1) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (induct "i") (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (skeep) (("3" (inst -6 "jb") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (hide-all-but (-1 1 2 3)) (("2" (reveal -7) (("2" (expand "length_odd" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (flatten) (("1" (expand "nstructER?") (("1" (flatten) (("1" (hide -7 -8) (("1" (inst -6 "m") (("1" (flatten) (("1" (assert) (("1" (skeep) (("1" (inst 1 "IF odd?(s1`seqfj`length) THEN i+1 ELSE i ENDIF") (("1" (lift-if) (("1" (prop) (("1" (expand "compare2to2") (("1" (assert) (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) nil nil)) nil) ("3" (expand "compare2to2") (("3" (assert) nil nil)) nil) ("4" (expand "compare2to2") (("4" (assert) nil nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "length_odd") (("2" (assert) nil nil)) nil)) nil) ("3" (flatten) (("3" (expand "length_odd") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (flatten) (("2" (expand "nstructER?") (("2" (flatten) (("2" (hide-all-but (-1 -3 -4 -5 -6 -9 1 2)) (("2" (skeep) (("2" (expand "compare2to2") (("2" (lift-if) (("2" (prop) (("1" (case-replace "m=0") (("1" (inst -8 "0") (("1" (flatten) (("1" (split -9) (("1" (propax) nil nil) ("2" (case-replace "i=0") (("1" (expand "nth" -4) (("1" (hide-all-but (-4 -7 3)) (("1" (inst -2 "s1`seqfj`length - 1") (("1" (expand "nstruct?") (("1" (assert) nil nil)) nil) ("2" (reveal -8) (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" -3) (("2" (assert) (("2" (inst 2 "i-1") (("2" (typepred "i") (("2" (expand "length_odd" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (case-replace "i=0") (("1" (expand "nth" -3) (("1" (hide-all-but (1 -3 -4 -6 1 3)) (("1" (inst -3 "s1`seqfj`length - 1") (("1" (expand "nstruct?") (("1" (assert) (("1" (flatten) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "nth" -2) (("2" (assert) (("2" (inst -7 "m") (("2" (flatten) (("2" (split -8) (("1" (propax) nil nil) ("2" (inst 1 "i-1") (("2" (typepred "i") (("2" (expand "length_odd" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -6 "m") (("1" (flatten) (("1" (split -7) (("1" (propax) nil nil) ("2" (inst 1 "i") (("2" (typepred "i") (("2" (expand "length_odd" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("6" (skeep) (("6" (expand "compare2to2") (("6" (lift-if) (("6" (prop) (("1" (case-replace "i=0") (("1" (expand "nth") (("1" (expand "nth") (("1" (expand "nstructER?") (("1" (flatten) (("1" (hide-all-but (-1 -2 -3 -6 -7 -10 1)) (("1" (split -6) (("1" (inst -5 "s1`seqfj`length - 1") (("1" (expand "nstruct?") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil) ("2" (typepred "i") (("2" (expand "compare2to2") (("2" (lift-if) (("2" (prop) (("2" (expand "length" -2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth") (("2" (assert) (("2" (expand "nstructER?") (("2" (flatten) (("2" (inst -8 "i-1") (("1" (assert) nil nil) ("2" (typepred "i") (("2" (expand "compare2to2") (("2" (expand "length" -1) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (expand "compare2to2") (("2" (assert) (("2" (expand "nstructER?") (("2" (flatten) (("2" (inst -8 "i") nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("7" (flatten) (("7" (expand "compare2to2") (("7" (lift-if) (("7" (prop) (("1" (expand "nstructER?") (("1" (flatten) (("1" (hide-all-but (-1 -2 -8 1)) (("1" (inst -3 "s1`seqfj`length - 1") (("1" (expand "nstruct?") (("1" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "nstructER?") (("2" (flatten) (("2" (hide-all-but (-2 -10 2)) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((number nonempty-type-decl nil numbers nil) (fjnode type-decl nil fjnode_adt nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (PRED type-eq-decl nil defined_types nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (< const-decl "bool" reals nil) (below type-eq-decl nil nat_types nil) (nstruct? def-decl "boolean" firt_phase_ford_johnson nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (comparePeservesElements formula-decl nil firt_phase_ford_johnson nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (even_plus_even_is_even application-judgement "even_int" integers nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (floor_div formula-decl nil floor_ceil nil) (posnat_expt application-judgement "posnat" exponentiation nil) (posrat_div_posrat_is_posrat application-judgement "posrat" rationals nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (expt def-decl "real" exponentiation nil) (integer nonempty-type-from-decl nil integers nil) (<= const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil) (/= const-decl "boolean" notequal nil) (nznum nonempty-type-eq-decl nil number_fields nil) (/ const-decl "[numfield, nznum -> numfield]" number_fields nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (^ const-decl "real" exponentiation nil) (compare2to2 const-decl "finseqfj" firt_phase_ford_johnson nil) (mult_divides2 application-judgement "(divides(m))" divides nil) (mult_divides1 application-judgement "(divides(n))" divides nil) (even_times_int_is_even application-judgement "even_int" integers nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (smallerones adt-accessor-decl "[fjnode -> list[fjnode]]" fjnode_adt nil) (nth def-decl "T" list_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (int_plus_int_is_int application-judgement "int" integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nonneg_int nonempty-type-eq-decl nil integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (val adt-accessor-decl "[fjnode -> T]" fjnode_adt nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (length_odd def-decl "nat" firt_phase_ford_johnson nil) (below_induction formula-decl nil bounded_nat_inductions nil) (below type-eq-decl nil naturalnumbers nil) (pred type-eq-decl nil defined_types nil) (odd? const-decl "bool" integers nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (posrat_exp application-judgement "posrat" exponentiation nil) (nstructER? const-decl "bool" firt_phase_ford_johnson nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (posint_exp application-judgement "posint" exponentiation nil)) shostak)) (correctionER_TCC1 0 (correctionER_TCC1-1 nil 3730179507 ("" (subtype-tcc) nil nil) nil shostak (correctionER subtype "firt_phase_ford_johnson.s0`seqfj`length" "{x: reals.real | reals.>=(x, 1)}"))) (correctionER_TCC2 0 (correctionER_TCC2-1 nil 3732655135 ("" (skeep) (("" (skeep) (("" (typepred "m") (("" (lemma "both_sides_expt_gt1_le") (("" (inst -1 "2" "m" "n") (("" (assert) (("" (replaces -3) (("" (expand "logb") (("" (lemma "log_nat_bounds") (("" (inst -1 "2" "s0`seqfj`length") (("" (assert) (("" (flatten) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((both_sides_expt_gt1_le formula-decl nil exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (logb const-decl "nat" firt_phase_ford_johnson nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (above nonempty-type-eq-decl nil integers nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (log_nat_bounds formula-decl nil log_nat reals) (TRUE const-decl "bool" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (> const-decl "bool" reals nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil)) shostak (correctionER subtype "firt_phase_ford_johnson.m" "{n: naturalnumbers.nat | reals.<=(exponentiation.^(2, n), length(firt_phase_ford_johnson.s0`seqfj))}"))) (correctionER_TCC3 0 (correctionER_TCC3-1 nil 3734217614 ("" (skeep) (("" (skeep) (("" (expand "logb") (("" (replaces) (("" (lemma "log_nat_bounds") (("" (inst?) (("" (beta) (("" (flatten) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (> const-decl "bool" reals nil) (above nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (fjnode type-decl nil fjnode_adt nil) (list type-decl nil list_adt nil) (finseq type-eq-decl nil finite_sequences nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (log_nat_bounds formula-decl nil log_nat reals) (logb const-decl "nat" firt_phase_ford_johnson nil) (posint_exp application-judgement "posint" exponentiation nil)) shostak (correctionER subtype "firt_phase_ford_johnson.n" "{n: naturalnumbers.nat | reals.<=(exponentiation.^(2, n), length(firt_phase_ford_johnson.s0`seqfj))}"))) (correctionER 0 (correctionER-2 "" 3804612214 ("" (skeep) (("" (measure-induct "length(s`seqfj)" "s") (("1" (skeep) (("1" (skeep) (("1" (expand "seqfjBottleneck" 1) (("1" (lift-if) (("1" (prop) (("1" (case-replace "m = logb(s0`seqfj`length,2)") (("1" (hide-all-but (-2 -4)) (("1" (expand "nstructER?") (("1" (flatten) (("1" (hide-all-but (-1 -3)) (("1" (typepred "logb(s0`seqfj`length,2)") (("1" (lemma "floor_div") (("1" (inst -1 "1" "2 ^ logb(s0`seqfj`length, 2)" "s0`seqfj`length") (("1" (assert) (("1" (hide -1 -3 -4) (("1" (split) (("1" (expand "logb") (("1" (lemma "log_nat_bounds") (("1" (inst -1 "2" "s0`seqfj`length") (("1" (assert) (("1" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "logb") (("2" (lemma "log_nat_bounds") (("2" (inst -1 "2" "s0`seqfj`length") (("2" (assert) (("2" (flatten) (("2" (case-replace "2 ^ (1 + log_nat(s0`seqfj`length, 2)`1) = 2 * 2 ^ log_nat(s0`seqfj`length, 2)`1") (("2" (hide-all-but (1)) (("2" (expand "^") (("2" (expand "expt" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "compare2to2(x)") (("1" (split) (("1" (propax) nil nil) ("2" (inst 1 "m+1") (("1" (lemma "oneStepCorrectionER") (("1" (inst -1 "x" "s0" "m") (("1" (assert) nil nil) ("2" (typepred "m") (("2" (typepred " logb(s0`seqfj`length, 2)") (("2" (hide -2 -5 2 4) (("2" (lemma "both_sides_expt_gt1_le") (("2" (inst -1 "2" "m+1" "logb(s0`seqfj`length, 2)") (("2" (assert) (("2" (expand "logb") (("2" (lemma "log_nat_bounds") (("2" (inst -1 "2" "s0`seqfj`length") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "m") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "compare2to2") (("3" (assert) nil nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (case-replace "m=logb(s0`seqfj`length, 2)") (("2" (expand "nstructER?" -1) (("2" (flatten) (("2" (hide-all-but (-2 1 2 4)) (("2" (typepred "m") (("2" (case "m < logb(s0`seqfj`length, 2)") (("1" (lemma "floor_div") (("1" (inst -1 "1" "2^m" "s0`seqfj`length") (("1" (assert) (("1" (flatten) (("1" (hide -1) (("1" (case-replace " 2 * 2 ^ m =  2 ^(1 + m)") (("1" (hide -1) (("1" (lemma "log_nat_bounds") (("1" (inst -1 "2" "s0`seqfj`length") (("1" (assert) (("1" (flatten) (("1" (case " 2 ^ log_nat(s0`seqfj`length, 2)`1 < 2 ^ (1 + m)") (("1" (hide -2 -3 -3 -4) (("1" (lemma "both_sides_expt_gt1_lt") (("1" (inst -1 "2" " logb(s0`seqfj`length, 2)" "m+1") (("1" (assert) (("1" (expand "logb") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (expand "^") (("2" (expand "expt" 1 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide 2) (("2" (hide -2) (("2" (replaces -1) (("2" (expand "logb") (("2" (lemma "log_nat_bounds") (("2" (inst -1 "2" "s0`seqfj`length") (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide 2) (("3" (skeep) (("3" (typepred "m") (("3" (lemma "both_sides_expt_gt1_le") (("3" (inst -1 "2" "m" "n") (("3" (assert) (("3" (hide -2) (("3" (replaces -2) (("3" (expand "logb") (("3" (lemma "log_nat_bounds") (("3" (inst -1 "2" "s0`seqfj`length") (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) nil shostak) (correctionER-1 nil 3729557229 ("" (skeep) (("" (measure-induct "length(s`seqfj)" "s") (("1" (skeep) (("1" (skeep) (("1" (expand "seqfjBottleneck" 1) (("1" (lift-if) (("1" (prop) (("1" (case-replace "m = logb(s0`seqfj`length,2)") (("1" (hide-all-but (-2 -4)) (("1" (expand "nstructER?") (("1" (flatten) (("1" (hide-all-but (-1 -3)) (("1" (typepred "logb(s0`seqfj`length,2)") (("1" (lemma "floor_div") (("1" (inst -1 "1" "2 ^ logb(s0`seqfj`length, 2)" "s0`seqfj`length") (("1" (assert) (("1" (hide -1 -3 -4) (("1" (split) (("1" (expand "logb") (("1" (lemma "log_nat_bounds") (("1" (inst -1 "2" "s0`seqfj`length") (("1" (assert) (("1" (flatten) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "logb") (("2" (lemma "log_nat_bounds") (("2" (inst -1 "2" "s0`seqfj`length") (("2" (assert) (("2" (flatten) (("2" (case-replace "2 ^ (1 + log_nat(s0`seqfj`length, 2)`1) = 2 * 2 ^ log_nat(s0`seqfj`length, 2)`1") (("2" (hide-all-but (1)) (("2" (expand "^") (("2" (expand "expt" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -2 "compare2to2(x)") (("1" (split) (("1" (propax) nil nil) ("2" (inst 1 "m+1") (("1" (lemma "oneStepCorrectionER") (("1" (inst -1 "x" "s0" "m") (("1" (assert) nil nil) ("2" (typepred "m") (("2" (typepred " logb(s0`seqfj`length, 2)") (("2" (hide -2 -5 2 4) (("2" (lemma "both_sides_expt_gt1_le") (("2" (inst -1 "2" "m+1" "logb(s0`seqfj`length, 2)") (("2" (assert) (("2" (expand "logb") (("2" (lemma "log_nat_bounds") (("2" (inst -1 "2" "s0`seqfj`length") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "m") (("2" (assert) nil nil)) nil)) nil) ("3" (expand "compare2to2") (("3" (assert) nil nil)) nil)) nil) ("2" (expand "compare2to2") (("2" (assert) nil nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (case-replace "m=logb(s0`seqfj`length, 2)") (("2" (expand "nstructER?" -1) (("2" (flatten) (("2" (hide-all-but (-2 1 2 4)) (("2" (typepred "m") (("2" (case "m < logb(s0`seqfj`length, 2)") (("1" (lemma "floor_div") (("1" (inst -1 "1" "2^m" "s0`seqfj`length") (("1" (assert) (("1" (flatten) (("1" (hide -1) (("1" (case-replace " 2 * 2 ^ m =  2 ^(1 + m)") (("1" (hide -1) (("1" (lemma "log_nat_bounds") (("1" (inst -1 "2" "s0`seqfj`length") (("1" (assert) (("1" (flatten) (("1" (case " 2 ^ log_nat(s0`seqfj`length, 2)`1 < 2 ^ (1 + m)") (("1" (hide -2 -3 -3 -4) (("1" (lemma "both_sides_expt_gt1_lt") (("1" (inst -1 "2" " logb(s0`seqfj`length, 2)" "m+1") (("1" (assert) (("1" (expand "logb") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1)) (("2" (expand "^") (("2" (expand "expt" 1 2) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (hide 2) (("2" (hide -1) (("2" (replaces -1) (("2" (expand "logb") (("2" (lemma "log_nat_bounds") (("2" (inst -1 "2" "s0`seqfj`length") (("2" (assert) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (skeep) (("3" (hide 2) (("3" (skeep) (("3" (typepred "m") (("3" (lemma "both_sides_expt_gt1_le") (("3" (inst -1 "2" "m" "n") (("3" (assert) (("3" (hide -2) (("3" (replaces -2) (("3" (expand "logb") (("3" (lemma "log_nat_bounds") (("3" (inst -1 "2" "s0`seqfj`length") (("3" (assert) (("3" (flatten) (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((TRUE const-decl "bool" booleans nil) (compare2to2 const-decl "finseqfj" firt_phase_ford_johnson nil) (x skolem-const-decl "{s: finseqfj | s`seqfj`length > 0}" firt_phase_ford_johnson nil) (nnint_times_nnint_is_nnint application-judgement "nonneg_int" integers nil) (m skolem-const-decl "{m: nat | m <= logb(s0`seqfj`length, 2)}" firt_phase_ford_johnson nil) (both_sides_expt_gt1_le formula-decl nil exponentiation nil) (oneStepCorrectionER formula-decl nil firt_phase_ford_johnson nil) (NOT const-decl "[bool -> bool]" booleans nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (integer nonempty-type-from-decl nil integers nil) (expt def-decl "real" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals) (even_times_int_is_even application-judgement "even_int" integers nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (log_nat_bounds formula-decl nil log_nat reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_times_even_is_even application-judgement "even_int" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (floor_div formula-decl nil floor_ceil nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (posint_exp application-judgement "posint" exponentiation nil) (both_sides_expt_gt1_lt formula-decl nil exponentiation nil) (seqfjBottleneck def-decl "finseqfj" firt_phase_ford_johnson nil) (nstructER? const-decl "bool" firt_phase_ford_johnson nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (above nonempty-type-eq-decl nil integers nil) (logb const-decl "nat" firt_phase_ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (s0 skolem-const-decl "{s0: finseqfj | plain_finseqfj(s0) AND s0`seqfj`length > 0}" firt_phase_ford_johnson nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (> const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (lengthBottleneckIs1 0 (lengthBottleneckIs1-1 nil 3729548176 ("" (skeep) (("" (skeep) (("" (skeep) (("" (lemma "correctionER") (("" (inst -1 "s0" "s") (("" (assert) (("" (split) (("1" (expand "nstructER?" -1) (("1" (flatten) (("1" (hide-all-but (-2 -8 1)) (("1" (replaces -1) (("1" (lemma "floor_div") (("1" (inst -1 "1" " 2 ^ logb(s0`seqfj`length, 2)" "s0`seqfj`length") (("1" (typepred "logb(s0`seqfj`length, 2)") (("1" (assert) (("1" (expand "logb") (("1" (lemma "log_nat_bounds") (("1" (inst -1 "2" "s0`seqfj`length") (("1" (assert) (("1" (split) (("1" (flatten) nil nil) ("2" (flatten) (("2" (case-replace "2 ^ (1 + log_nat(s0`seqfj`length, 2)`1) = 2 * 2 ^ log_nat(s0`seqfj`length, 2)`1") (("2" (hide-all-but (1)) (("2" (expand "^") (("2" (expand "expt" 1 1) (("2" (propax) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst 1 "m") (("2" (hide -1 2) (("2" (typepred "m") (("2" (typepred " logb(s0`seqfj`length, 2)") (("2" (lemma "both_sides_expt_gt1_lt") (("2" (inst -1 "2" "m" "1 + logb(s0`seqfj`length, 2)") (("2" (assert) (("2" (lemma "log_nat_bounds") (("2" (expand "logb") (("2" (inst -1 "2" "s0`seqfj`length") (("2" (assert) (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((correctionER formula-decl nil firt_phase_ford_johnson nil) (<= const-decl "bool" reals nil) (m skolem-const-decl "{m: nat | 2 ^ m <= s0`seqfj`length}" firt_phase_ford_johnson nil) (s0 skolem-const-decl "{s0: finseqfj | plain_finseqfj(s0) AND length(s0`seqfj) > 0}" firt_phase_ford_johnson nil) (both_sides_expt_gt1_lt formula-decl nil exponentiation nil) (posint_exp application-judgement "posint" exponentiation nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nstructER? const-decl "bool" firt_phase_ford_johnson nil) (floor_div formula-decl nil floor_ceil nil) (NOT const-decl "[bool -> bool]" booleans nil) (log_nat def-decl "[n: nat, {y | y < p AND x = p ^ n * y}]" log_nat reals) (* const-decl "[numfield, numfield -> numfield]" number_fields nil) (< const-decl "bool" reals nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (= const-decl "[T, T -> boolean]" equalities nil) (even_times_int_is_even application-judgement "even_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (expt def-decl "real" exponentiation nil) (nnrat_exp application-judgement "nnrat" exponentiation nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (log_nat_bounds formula-decl nil log_nat reals) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat" rationals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_times_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_times_even_is_even application-judgement "even_int" integers nil) (odd_plus_odd_is_even application-judgement "even_int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (logb const-decl "nat" firt_phase_ford_johnson nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (above nonempty-type-eq-decl nil integers nil) (^ const-decl "real" exponentiation nil) (/= const-decl "boolean" notequal nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (int nonempty-type-eq-decl nil integers nil) (posreal nonempty-type-eq-decl nil real_types nil) (nonneg_real nonempty-type-eq-decl nil real_types nil) (>= const-decl "bool" reals nil) (integer nonempty-type-from-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (TRUE const-decl "bool" booleans nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil)) shostak)) (seqfjBottleneck_works 0 (seqfjBottleneck_works-2 nil 3736226734 ("" (skeep) (("" (case "length(s`seqfj)=0") (("1" (expand "seqfjBottleneck") (("1" (assert) (("1" (split) (("1" (expand "is_sorted?") (("1" (skeep) nil))) ("2" (expand "permutation") (("2" (propax) nil))))))))) ("2" (split) (("1" (lemma "lengthBottleneckIs1") (("1" (inst -1 "s" "0" "s") (("1" (split) (("1" (expand "is_sorted?") (("1" (skeep) (("1" (assert) nil))))) ("2" (hide 2) (("2" (lemma "plain_finseqfj_nstructER0") (("2" (inst -1 "s") (("1" (assert) nil) ("2" (expand "plain_finseqfj") (("2" (flatten) (("2" (assert) nil))))))))))))) ("2" (assert) nil) ("3" (expand "^") (("3" (expand "expt") (("3" (assert) nil))))) ("4" (assert) nil))))) ("2" (lemma "correctionER") (("2" (inst -1 "s" "s") (("1" (assert) (("1" (split) (("1" (expand "nstructER?") (("1" (propax) nil))) ("2" (inst 1 "0") (("2" (lemma "plain_finseqfj_nstructER0") (("2" (inst -1 "s") (("2" (assert) nil))))))))))) ("2" (assert) nil) ("3" (assert) nil)))))))))) nil) ((finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (fjnode type-decl nil fjnode_adt nil) (T formal-type-decl nil firt_phase_ford_johnson nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (permutation const-decl "bool" firt_phase_ford_johnson nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (seqfjBottleneck def-decl "finseqfj" firt_phase_ford_johnson nil) (correctionER formula-decl nil firt_phase_ford_johnson nil) (above nonempty-type-eq-decl nil integers nil) (logb const-decl "nat" firt_phase_ford_johnson nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nstructER? const-decl "bool" firt_phase_ford_johnson nil) (lengthBottleneckIs1 formula-decl nil firt_phase_ford_johnson nil) (expt def-decl "real" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (plain_finseqfj_nstructER0 formula-decl nil firt_phase_ford_johnson nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (<= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (>= const-decl "bool" reals nil) (^ const-decl "real" exponentiation nil) (bool nonempty-type-eq-decl nil booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (s skolem-const-decl "finseqfj" firt_phase_ford_johnson nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil)) nil) (seqfjBottleneck_works-1 nil 3729556474 ("" (skeep) (("" (case "length(s`seqfj)=0") (("1" (expand "seqfjBottleneck") (("1" (assert) (("1" (split) (("1" (expand "is_sorted?") (("1" (skeep) nil nil)) nil) ("2" (expand "permutation") (("2" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (split) (("1" (lemma "lengthBottleneckIs1") (("1" (inst -1 "s" "0" "s") (("1" (split) (("1" (expand "is_sorted?") (("1" (skeep) (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (lemma "plain_finseqfj_nstructER0") (("2" (inst -1 "s") (("1" (assert) nil nil) ("2" (expand "plain_finseqfj") (("2" (flatten) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (expand "^") (("3" (expand "expt") (("3" (assert) nil nil)) nil)) nil) ("4" (assert) nil nil)) nil)) nil) ("2" (lemma "correctionER") (("2" (inst -1 "s" "s") (("1" (assert) (("1" (split) (("1" (expand "nstructER?") (("1" (propax) nil nil)) nil) ("2" (inst 1 "0") (("2" (lemma "plain_finseqfj_nstructER0") (("2" (inst -1 "s") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((finseqfj type-eq-decl nil firt_phase_ford_johnson nil) (finseq type-eq-decl nil finite_sequences nil) (list type-decl nil list_adt nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (PRED type-eq-decl nil defined_types nil) (bool nonempty-type-eq-decl nil booleans nil) (fjnode type-decl nil fjnode_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (is_sorted? const-decl "bool" firt_phase_ford_johnson nil) (seqfjBottleneck def-decl "finseqfj" firt_phase_ford_johnson nil) (correctionER formula-decl nil firt_phase_ford_johnson nil) (logb const-decl "nat" firt_phase_ford_johnson nil) (above nonempty-type-eq-decl nil integers nil) (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil) (nstructER? const-decl "bool" firt_phase_ford_johnson nil) (lengthBottleneckIs1 formula-decl nil firt_phase_ford_johnson nil) (expt def-decl "real" exponentiation nil) (int_minus_int_is_int application-judgement "int" integers nil) (plain_finseqfj_nstructER0 formula-decl nil firt_phase_ford_johnson nil) (<= const-decl "bool" reals nil) (OR const-decl "[bool, bool -> bool]" booleans nil) (/= const-decl "boolean" notequal nil) (^ const-decl "real" exponentiation nil) (> const-decl "bool" reals nil) (plain_finseqfj const-decl "bool" firt_phase_ford_johnson nil) (real_le_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_exp application-judgement "posint" exponentiation nil)) shostak)))
