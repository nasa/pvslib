(radix_sort_nat
 (d_nth_TCC1 0
  (d_nth_TCC1-1 nil 3785248401 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil))
 (d_nth_TCC2 0
  (d_nth_TCC2-1 nil 3785248401 ("" (termination-tcc) nil nil) nil nil))
 (n_digits_TCC1 0
  (n_digits_TCC1-1 nil 3785248401
   ("" (skeep)
    (("" (typepred "ndiv(n, 10)") (("" (grind) nil nil)) nil)) nil)
   ((<= const-decl "bool" reals nil)
    (ndiv const-decl "{q: int | x = b * q + rem(b)(x)}"
     modulo_arithmetic nil)
    (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}"
         modulo_arithmetic nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (< const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nil application-judgement "upto(n)" modulo_arithmetic nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (div const-decl "upto(n)" div_nat "ints/"))
   nil))
 (max_digits_TCC1 0
  (max_digits_TCC1-1 nil 3785248401
   ("" (subtype-tcc) (("" (grind) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (max_digits_TCC2 0
  (max_digits_TCC2-1 nil 3785248401
   ("" (subtype-tcc) (("" (grind) nil nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (max_digits_TCC3 0
  (max_digits_TCC3-1 nil 3785248401
   ("" (subtype-tcc)
    (("" (grind)
      (("" (expand "length" -2)
        (("" (lift-if)
          (("" (prop) (("1" (assert) nil nil) ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (max_digits_TCC4 0
  (max_digits_TCC4-1 nil 3785248401
   ("" (termination-tcc)
    (("" (grind)
      (("" (grind) (("" (expand "length") (("" (grind) nil nil)) nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil))
   nil))
 (max_digits_works_TCC1 0
  (max_digits_works_TCC1-1 nil 3794741514 ("" (subtype-tcc) nil nil)
   nil nil))
 (max_digits_works 0
  (max_digits_works-1 nil 3794741515
   ("" (measure-induct+ "length(l)" "l")
    (("" (skeep)
      (("" (expand "max_digits" 1)
        (("" (lift-if)
          (("" (prop)
            (("1" (grind)
              (("1" (typepred "i") (("1" (grind) nil nil)) nil)) nil)
             ("2" (expand "max" 2)
              (("2" (lift-if)
                (("2" (prop)
                  (("1" (expand "nth" 1)
                    (("1" (lift-if)
                      (("1" (prop)
                        (("1" (assert) nil nil)
                         ("2" (inst -2 "cdr(x!1)")
                          (("1" (inst -2 "i-1")
                            (("1" (assert) (("1" (grind) nil nil)) nil)
                             ("2" (assert) nil nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (expand "nth" 2)
                    (("2" (lift-if)
                      (("2" (prop)
                        (("1" (assert) nil nil)
                         ("2" (inst -1 "cdr(x!1)")
                          (("1" (inst -1 "i-1")
                            (("1" (assert) (("1" (grind) nil nil)) nil)
                             ("2" (assert) nil nil))
                            nil)
                           ("2" (grind) nil nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (x!1 skolem-const-decl "(cons?[nat])" radix_sort_nat nil)
    (posint_max application-judgement "{k: posint | i <= k AND j <= k}"
     real_defs nil)
    (posrat_max application-judgement "{s: posrat | s >= q AND s >= r}"
     real_defs nil)
    (i skolem-const-decl "below[length(x!1)]" radix_sort_nat nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (max_digits def-decl "posnat" radix_sort_nat nil)
    (nth def-decl "T" list_props nil)
    (n_digits def-decl "posnat" radix_sort_nat nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (d_nth_zero 0
  (d_nth_zero-1 nil 3785254619
   ("" (induct "i")
    (("1" (grind) (("1" (rewrite "rem_mod") nil nil)) nil)
     ("2" (skeep)
      (("2" (expand "d_nth" 1)
        (("2" (case "ndiv(0, 10) = 0")
          (("1" (assert) nil nil)
           ("2" (hide -1 2)
            (("2" (typepred "ndiv(0, 10)") (("2" (assert) nil nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((ndiv const-decl "{q: int | x = b * q + rem(b)(x)}"
     modulo_arithmetic nil)
    (rem const-decl "{r: mod(b) | EXISTS q: x = b * q + r}"
         modulo_arithmetic nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (mod nonempty-type-eq-decl nil euclidean_division nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nil application-judgement "upto(n)" modulo_arithmetic nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (div const-decl "upto(n)" div_nat "ints/")
    (nmod const-decl "below(m)" mod_nat "ints/")
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (d_nth def-decl "below[10]" radix_sort_nat nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   shostak))
 (d_nth_digits_TCC1 0
  (d_nth_digits_TCC1-1 nil 3785596384 ("" (subtype-tcc) nil nil) nil
   nil))
 (d_nth_digits 0
  (d_nth_digits-1 nil 3785596386
   ("" (measure-induct+ "i" "i")
    (("" (skeep)
      (("" (expand "d_nth" -3)
        (("" (typepred "x!1")
          (("" (lift-if)
            (("" (prop)
              (("1" (grind) nil nil)
               ("2" (expand "n_digits" -4)
                (("2" (lift-if)
                  (("2" (lift-if)
                    (("2" (lift-if)
                      (("2" (prop)
                        (("1" (case "div(m, 10) =0 and div(n, 10)=0")
                          (("1" (prop)
                            (("1" (replaces -1)
                              (("1"
                                (replaces -1)
                                (("1"
                                  (rewrite "d_nth_zero")
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (prop)
                            (("1" (hide-all-but (-3 1))
                              (("1"
                                (typepred "div(m, 10)")
                                (("1" (grind) nil nil))
                                nil))
                              nil)
                             ("2" (hide-all-but (-1 1))
                              (("2"
                                (typepred "div(n, 10)")
                                (("2" (grind) nil nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (assert) nil nil)
                         ("3" (case "div(n, 10) = 0")
                          (("1" (replaces -1)
                            (("1" (rewrite "d_nth_zero")
                              (("1" (assert) nil nil)) nil))
                            nil)
                           ("2" (hide-all-but (-1 1))
                            (("2" (typepred "div(n, 10)")
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil)
                         ("4" (assert)
                          (("4" (inst -4 "x!1-1")
                            (("4" (assert)
                              (("4"
                                (inst -4 "div(m,10)" "div(n,10)")
                                (("4"
                                  (assert)
                                  (("4"
                                    (prop)
                                    (("1"
                                      (hide-all-but (-1 1 2 4))
                                      (("1"
                                        (typepred
                                         "div(m, 10)"
                                         "div(n, 10)")
                                        (("1"
                                          (replaces -1 3)
                                          (("1"
                                            (replaces -2 3)
                                            (("1" (grind) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nmod const-decl "below(m)" mod_nat "ints/")
    (div const-decl "upto(n)" div_nat "ints/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_max application-judgement "{k: posint | i <= k AND j <= k}"
     real_defs nil)
    (posrat_max application-judgement "{s: posrat | s >= q AND s >= r}"
     real_defs nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (TRUE const-decl "bool" booleans nil)
    (d_nth_zero formula-decl nil radix_sort_nat nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nzint_max application-judgement "{k: nzint | i <= k AND j <= k}"
     real_defs nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (d_nth def-decl "below[10]" radix_sort_nat nil)
    (below type-eq-decl nil nat_types nil)
    (n_digits def-decl "posnat" radix_sort_nat nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (<= const-decl "bool" reals nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (> const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (d_exp_dec 0
  (d_exp_dec-1 nil 3793440567
   ("" (induct "d")
    (("1" (skeep) (("1" (grind) nil nil)) nil)
     ("2" (skeep*)
      (("2" (expand "d_nth" 1)
        (("2" (inst -1 "div(n, 10)")
          (("2" (both-sides "-" "nmod(div(n, 10), 10 ^ j)" -1)
            (("1" (assert)
              (("1" (expand "^")
                (("1" (expand "expt" 1 2)
                  (("1" (replaces -1 1)
                    (("1" (expand "expt" 1 (1 2 4))
                      (("1" (expand "expt" 1 (4))
                        (("1" (expand "nmod")
                          (("1" (expand "div")
                            (("1"
                              (typepred
                               "floor(n / (100 * expt(10, j)))")
                              (("1"
                                (lemma "floor_div_prod")
                                (("1"
                                  (inst-cp -1 "expt(10, j)" "10" "n")
                                  (("1"
                                    (replaces -2 :dir rl)
                                    (("1"
                                      (inst-cp
                                       -1
                                       "10 * expt(10, j)"
                                       "10"
                                       "n")
                                      (("1"
                                        (replaces -2 :dir rl)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (integer nonempty-type-from-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_times_even_is_even application-judgement "even_int" integers
     nil)
    (even_minus_even_is_even application-judgement "even_int" integers
     nil)
    (floor_div_prod formula-decl nil mod_lems "ints/")
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (expt def-decl "real" exponentiation nil)
    (div const-decl "upto(n)" div_nat "ints/")
    (nat_induction formula-decl nil naturalnumbers nil)
    (nmod const-decl "below(m)" mod_nat "ints/")
    (below type-eq-decl nil naturalnumbers nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (d_nth def-decl "below[10]" radix_sort_nat nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (d_nth_rem 0
  (d_nth_rem-1 nil 3785849476
   ("" (skeep)
    (("" (lemma "d_exp_dec")
      (("" (inst-cp -1 "nmod(m, 10 ^ (x + 1))" "x")
        (("" (inst -1 "nmod(m, 10 ^ (x + 1 + k))" "x")
          ((""
            (case-replace "d_nth(nmod(m, 10 ^ (1 + x)), x)  =
       (nmod(nmod(m, 10 ^ (1 + x)), 10 ^ (1 + x)) -
        nmod(nmod(m, 10 ^ (1 + x)), 10 ^ x)) / 10 ^ x" :hide? t)
            (("1"
              (case-replace "d_nth(nmod(m, 10 ^ (x + 1 + k)), x) 
       = (nmod(nmod(m, 10 ^ (x + 1 + k)), 10 ^ (1 + x)) - nmod(nmod(m, 10 ^ (x + 1 + k)), 10 ^ x))/ 10 ^ x")
              (("1" (hide -)
                (("1" (expand "^")
                  (("1" (lemma "nmod_mult")
                    (("1" (inst-cp -1 "expt(10, (1 + x))" "1" "m")
                      (("1" (replaces -2)
                        (("1" (expand "expt" 1 2)
                          (("1" (inst-cp -1 "expt(10, x)" "10" "m")
                            (("1" (replaces -2)
                              (("1"
                                (case-replace
                                 "expt(10, 1 + k + x) = expt(10, 1 + x) * expt(10, k)"
                                 :hide?
                                 t)
                                (("1"
                                  (inst-cp
                                   -1
                                   "expt(10, 1 + x)"
                                   "expt(10, k)"
                                   "m")
                                  (("1"
                                    (replaces -2)
                                    (("1"
                                      (expand "expt" 1 5)
                                      (("1"
                                        (inst
                                         -1
                                         "expt(10, x)"
                                         "10 * expt(10, k)"
                                         "m")
                                        (("1" (replaces -1) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (hide -1 2)
                                  (("2"
                                    (lemma "expt_plus")
                                    (("2"
                                      (inst -1 "1 + x" "k" "10")
                                      (("2"
                                        (expand "^")
                                        (("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (grind) nil nil))
              nil)
             ("2" (grind) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((d_exp_dec formula-decl nil radix_sort_nat nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (expt def-decl "real" exponentiation nil)
    (nzreal nonempty-type-eq-decl nil reals nil)
    (expt_plus formula-decl nil exponentiation nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (TRUE const-decl "bool" booleans nil)
    (nmod_mult formula-decl nil mod_nat "ints/")
    (div const-decl "upto(n)" div_nat "ints/")
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (rat_plus_rat_is_rat application-judgement "rat" rationals nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (d_nth def-decl "below[10]" radix_sort_nat nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nmod const-decl "below(m)" mod_nat "ints/")
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (n_digits_power 0
  (n_digits_power-1 nil 3794850568
   ("" (measure-induct "m" "m")
    (("" (skeep* :preds? t)
      (("" (expand "n_digits" 1)
        (("" (lift-if)
          (("" (prop)
            (("1" (hide -4)
              (("1" (expand "^")
                (("1" (expand "expt")
                  (("1" (use "expt_pos_aux")
                    (("1" (assert)
                      (("1" (case "expt(10, x) >= 1")
                        (("1" (assert) nil nil)
                         ("2" (assert)
                          (("2" (grind)
                            (("2" (lemma "expt_ge1")
                              (("2"
                                (inst -1 "10" "x")
                                (("2"
                                  (expand "^")
                                  (("2" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (inst -3 "div(x_1, 10)")
              (("2" (prop)
                (("1" (inst -1 "x")
                  (("1"
                    (case "FORALL(a, b, n: nat): a < b AND n < 10 => 10 * a + n < 10 * b")
                    (("1"
                      (inst -1 "div(x_1, 10)"
                       "10 ^ (n_digits(div(x_1, 10)) + x)"
                       "nmod(x_1, 10)")
                      (("1" (assert)
                        (("1" (prop)
                          (("1" (expand "^")
                            (("1" (expand "expt" 2)
                              (("1"
                                (expand "nmod")
                                (("1" (propax) nil nil))
                                nil))
                              nil))
                            nil)
                           ("2" (typepred "nmod(x_1, 10)")
                            (("2" (propax) nil nil)) nil))
                          nil))
                        nil))
                      nil)
                     ("2" (hide-all-but 1)
                      (("2" (skeep) (("2" (assert) nil nil)) nil))
                      nil))
                    nil))
                  nil)
                 ("2" (use "div_smaller") (("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (div const-decl "upto(n)" div_nat "ints/")
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (div_smaller formula-decl nil div_nat "ints/")
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (nmod const-decl "below(m)" mod_nat "ints/")
    (below type-eq-decl nil naturalnumbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (expt def-decl "real" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (expt_ge1 formula-decl nil exponentiation nil)
    (above nonempty-type-eq-decl nil integers nil)
    (posreal nonempty-type-eq-decl nil real_types nil)
    (nonneg_real nonempty-type-eq-decl nil real_types nil)
    (expt_pos_aux formula-decl nil exponentiation nil)
    (n_digits def-decl "posnat" radix_sort_nat nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (d_nth_nmod_TCC1 0
  (d_nth_nmod_TCC1-1 nil 3794745814 ("" (subtype-tcc) nil nil) nil
   nil))
 (d_nth_nmod 0
  (d_nth_nmod-1 nil 3794745861
   ("" (skeep* :preds? t)
    (("" (lemma "d_nth_rem")
      (("" (inst-cp -1 "x - 1" "m" "j - x")
        (("" (assert)
          (("" (inst -1 "x - 1" "m" "n_digits(m)")
            (("" (assert)
              (("" (replaces -2 1 :dir rl)
                (("" (lemma "nmod_lt_nat")
                  (("" (case-replace "m=0" :hide? t)
                    (("1" (use "nmod_zero")
                      (("1" (replaces -1) nil nil)) nil)
                     ("2" (inst -1 "10 ^ (n_digits(m) + x)" "m")
                      (("2" (assert)
                        (("2" (lemma "n_digits_power")
                          (("2" (lemma "nmod_lt_nat")
                            (("2"
                              (inst -1 "10 ^ (n_digits(m) + x)" "m")
                              (("2" (inst -2 "m" "x") nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((d_nth_rem formula-decl nil radix_sort_nat nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (nmod_lt_nat formula-decl nil mod_nat "ints/")
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (n_digits_power formula-decl nil radix_sort_nat nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nmod_zero formula-decl nil mod_nat "ints/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (n_digits def-decl "posnat" radix_sort_nat nil)
    (<= const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (n_digits_monotone 0
  (n_digits_monotone-1 nil 3795005312
   ("" (measure-induct+ "a+b" ("a" "b"))
    (("" (expand "n_digits" 1)
      (("" (lift-if)
        (("" (lift-if)
          (("" (lift-if)
            (("" (prop)
              (("1" (assert) nil nil) ("2" (assert) nil nil)
               ("3" (assert) nil nil)
               ("4" (inst -1 "div(x!1,10)" "div(x!2,10)")
                (("4" (grind) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (div const-decl "upto(n)" div_nat "ints/")
    (= const-decl "[T, T -> boolean]" equalities nil)
    (n_digits def-decl "posnat" radix_sort_nat nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (<= const-decl "bool" reals nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   shostak))
 (n_digits_ten_power_TCC1 0
  (n_digits_ten_power_TCC1-1 nil 3795006779
   ("" (skeep :preds? t)
    (("" (expand "^")
      (("" (expand "expt")
        (("" (lemma "expt_ge1")
          (("" (inst -1 "10" "x-1")
            (("" (assert) (("" (grind) nil nil)) nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((^ const-decl "real" exponentiation nil)
    (expt_ge1 formula-decl nil exponentiation nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (above nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (expt def-decl "real" exponentiation nil)
    (posnat_expt application-judgement "posnat" exponentiation nil))
   nil))
 (n_digits_ten_power 0
  (n_digits_ten_power-1 nil 3795005603
   ("" (induct "x")
    (("1" (assert) nil nil) ("2" (assert) nil nil)
     ("3" (skeep*)
      (("3" (prop)
        (("1" (expand "^")
          (("1" (expand "expt" 1)
            (("1" (expand "n_digits" 1)
              (("1" (lift-if)
                (("1" (prop)
                  (("1" (grind) nil nil)
                   ("2" (expand "div")
                    (("2"
                      (case "floor((10 * expt(10, j) - 1) / 10)=expt(10, j) - 1")
                      (("1" (assert) nil nil)
                       ("2" (hide-all-but (1 -2))
                        (("2" (hide -1)
                          (("2" (name-replace "one" "1")
                            (("2"
                              (case "(10 * expt(10, j) - one) / 10 = expt(10, j) - one / 10")
                              (("1"
                                (replaces -1)
                                (("1"
                                  (lemma "floor_plus_int")
                                  (("1"
                                    (inst -1 "expt(10, j)" "-one / 10")
                                    (("1"
                                      (replaces -1)
                                      (("1"
                                        (grind)
                                        (("1"
                                          (expand "one")
                                          (("1" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (grind) nil nil))
        nil))
      nil)
     ("4" (skeep)
      (("4" (lemma "expt_ge1")
        (("4" (inst?) (("4" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((above nonempty-type-eq-decl nil integers nil)
    (expt_ge1 formula-decl nil exponentiation nil)
    (TRUE const-decl "bool" booleans nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (nzrat_div_nzrat_is_nzrat application-judgement "nzrat" rationals
     nil)
    (integer nonempty-type-from-decl nil integers nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (floor const-decl "{i | i <= x & x < i + 1}" floor_ceil nil)
    (nznum nonempty-type-eq-decl nil number_fields nil)
    (/ const-decl "[numfield, nznum -> numfield]" number_fields nil)
    (* const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (floor_plus_int formula-decl nil floor_ceil nil)
    (one skolem-const-decl "posint" radix_sort_nat nil)
    (nzint_times_nzint_is_nzint application-judgement "nzint" integers
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (- const-decl "[numfield -> numfield]" number_fields nil)
    (minus_odd_is_odd application-judgement "odd_int" integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posint nonempty-type-eq-decl nil integers nil)
    (div const-decl "upto(n)" div_nat "ints/")
    (expt def-decl "real" exponentiation nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (n_digits def-decl "posnat" radix_sort_nat nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_exp application-judgement "posint" exponentiation nil))
   shostak))
 (n_digits_nmod_leq 0
  (n_digits_nmod_leq-1 nil 3794936843
   ("" (skeep)
    (("" (case "nmod(n, 10 ^ x) <= 10^x-1")
      (("1" (lemma "n_digits_monotone")
        (("1" (inst?)
          (("1" (rewrite "n_digits_ten_power") (("1" (assert) nil nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil)
       ("2" (hide 2)
        (("2" (typepred "nmod(n, 10 ^ x)")
          (("2" (typepred "x")
            (("2"
              (case "forall(x : posnat): exists(m : nat): 10 ^ x = m")
              (("1" (inst -1 "x")
                (("1" (skeep)
                  (("1" (replaces -1) (("1" (assert) nil nil)) nil))
                  nil))
                nil)
               ("2" (hide-all-but 1)
                (("2" (skeep) (("2" (inst 1 "10 ^ x!1") nil nil)) nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nmod const-decl "below(m)" mod_nat "ints/")
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (<= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (x skolem-const-decl "posnat" radix_sort_nat nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (n_digits_ten_power formula-decl nil radix_sort_nat nil)
    (n_digits_monotone formula-decl nil radix_sort_nat nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (leq_N_TCC1 0
  (leq_N_TCC1-1 nil 3795166700 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (< const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (N const-decl "nat" radix_sort_nat nil)
    (below type-eq-decl nil nat_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (reflexive? const-decl "bool" relations nil)
    (transitive? const-decl "bool" relations nil)
    (preorder? const-decl "bool" orders nil)
    (dichotomous? const-decl "bool" orders nil)
    (total_preorder? const-decl "bool" total_preorder nil))
   nil))
 (lex_preserves_TCC1 0
  (lex_preserves_TCC1-1 nil 3795166700 ("" (subtype-tcc) nil nil) nil
   nil))
 (lex_preserves 0
  (lex_preserves-1 nil 3795166733
   ("" (induct "i")
    (("1" (prop)
      (("1" (skeep :preds? t)
        (("1" (expand "lex") (("1" (propax) nil nil)) nil)) nil))
      nil)
     ("2" (skeep*)
      (("2" (typepred "jb" "j")
        (("2" (inst -4 "m" "n" "j")
          (("2" (expand "lex" 1)
            (("2" (expand "leq_N")
              (("2" (lemma "d_nth_nmod")
                (("2" (inst-cp -1 "jb + 1" "m" "j")
                  (("2" (inst -1 "jb + 1" "n" "j")
                    (("2" (assert)
                      (("2" (replaces -1 :dir rl)
                        (("2" (replaces -1 :dir rl)
                          (("2" (prop) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((TRUE const-decl "bool" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (d_nth_nmod formula-decl nil radix_sort_nat nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (below_induction formula-decl nil bounded_nat_inductions nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (N const-decl "nat" radix_sort_nat nil)
    (^ const-decl "real" exponentiation nil)
    (/= const-decl "boolean" notequal nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (nmod const-decl "below(m)" mod_nat "ints/")
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (lex inductive-decl "bool" radix_sort nil)
    (leq_N const-decl "[below[N] -> (total_preorder?[nat])]"
     radix_sort_nat nil)
    (total_preorder? const-decl "bool" total_preorder nil)
    (PRED type-eq-decl nil defined_types nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (pred type-eq-decl nil defined_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (posint_exp application-judgement "posint" exponentiation nil))
   nil))
 (lex_nat_works_aux_TCC1 0
  (lex_nat_works_aux_TCC1-1 nil 3795166700 ("" (subtype-tcc) nil nil)
   nil nil))
 (lex_nat_works_aux 0
  (lex_nat_works_aux-1 nil 3795166757
   (""
    (measure-induct+ "j+max(n_digits(m), n_digits(n))"
     ("m" "n" "i" "j"))
    (("1" (expand "lex" -3)
      (("1" (prop)
        (("1" (assert) nil nil)
         ("2" (expand "leq_N")
          (("2" (typepred "x!3")
            (("2" (typepred "x!4")
              (("2" (lemma "d_nth_digits")
                (("2" (inst -1 "x!1" "x!2" "x!4")
                  (("2" (assert) nil nil)) nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (expand "leq_N")
          (("3" (case "x!4= x!3")
            (("1"
              (case "nmod(x!1, 10^(x!4 - 1)) <= nmod(x!2, 10^(x!4-1))")
              (("1" (replaces -2)
                (("1" (hide -4 -6)
                  (("1" (lemma "d_exp_dec")
                    (("1" (inst-cp -1 "x!1" "x!3 - 1")
                      (("1" (inst -1 "x!2" "x!3 - 1")
                        (("1" (assert)
                          (("1" (lemma "nmod_lt_nat")
                            (("1" (inst-cp -1 "10 ^ (x!3)" "x!2")
                              (("1"
                                (inst -1 "10 ^ (x!3)" "x!1")
                                (("1"
                                  (assert)
                                  (("1"
                                    (lemma "n_digits_power")
                                    (("1"
                                      (inst-cp
                                       -1
                                       "x!2"
                                       "x!3 - n_digits(x!2)")
                                      (("1"
                                        (inst
                                         -1
                                         "x!1"
                                         "x!3 - n_digits(x!1)")
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (assert) nil nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (replaces -1)
                (("2"
                  (inst -5 "nmod(x!1, 10^(x!3 - 1))"
                   "nmod(x!2, 10^(x!3 - 1))" "x!3 - 1" "x!3 - 1")
                  (("1" (assert)
                    (("1" (prop)
                      (("1" (lemma "n_digits_nmod_leq")
                        (("1" (case-replace "x!3 = 1" :hide? t)
                          (("1" (assert) (("1" (grind) nil nil)) nil)
                           ("2" (inst-cp -1 "x!1" "x!3 - 1")
                            (("1" (inst -1 "x!2" "x!3 - 1")
                              (("1" (grind) nil nil)
                               ("2" (assert) nil nil))
                              nil)
                             ("2" (assert) nil nil))
                            nil))
                          nil))
                        nil)
                       ("2" (use "lex_preserves")
                        (("2" (assert) nil nil)) nil)
                       ("3" (both-sides "-" "x!3" 1)
                        (("1" (assert)
                          (("1" (case-replace "x!3 = 1" :hide? t)
                            (("1" (assert)
                              (("1"
                                (expand "^")
                                (("1"
                                  (expand "expt")
                                  (("1"
                                    (expand "nmod")
                                    (("1"
                                      (rewrite* "div_by_one")
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2"
                              (case "nmod(x!1, 10 ^ (x!3 - 1)) <= x!1 AND nmod(x!2, 10 ^ (x!3 - 1)) <= x!2")
                              (("1"
                                (flatten)
                                (("1"
                                  (lemma "n_digits_monotone")
                                  (("1"
                                    (inst-cp
                                     -1
                                     "nmod(x!1, 10 ^ (x!3 - 1))"
                                     "x!1")
                                    (("1"
                                      (inst
                                       -1
                                       "nmod(x!2, 10 ^ (x!3 - 1))"
                                       "x!2")
                                      (("1" (grind) nil nil)
                                       ("2" (grind) nil nil))
                                      nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil)
                               ("2" (grind) nil nil)
                               ("3" (grind) nil nil)
                               ("4" (grind) nil nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil) ("3" (assert) nil nil)
                   ("4" (grind) nil nil))
                  nil))
                nil)
               ("3" (grind) nil nil))
              nil)
             ("2" (typepred "x!3" "x!4")
              (("2" (inst -8 "x!1" "x!2" "x!3" "x!4 - 1")
                (("1" (prop) (("1" (assert) nil nil)) nil)
                 ("2" (assert) nil nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (assert) nil nil) ("3" (assert) nil nil))
    nil)
   ((nnrat_exp application-judgement "nnrat" exponentiation nil)
    (posrat_exp application-judgement "posrat" exponentiation nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nmod const-decl "below(m)" mod_nat "ints/")
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (/= const-decl "boolean" notequal nil)
    (^ const-decl "real" exponentiation nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (nnrat_times_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (nnrat_plus_nnrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (posint_exp application-judgement "posint" exponentiation nil)
    (n_digits_power formula-decl nil radix_sort_nat nil)
    (nmod_lt_nat formula-decl nil mod_nat "ints/")
    (d_exp_dec formula-decl nil radix_sort_nat nil)
    (TRUE const-decl "bool" booleans nil)
    (expt def-decl "real" exponentiation nil)
    (div const-decl "upto(n)" div_nat "ints/")
    (nnrat_div_posrat_is_nnrat application-judgement "nonneg_rat"
     rationals nil)
    (nonneg_floor_is_nat application-judgement "nat" floor_ceil nil)
    (mult_divides2 application-judgement "(divides(m))" divides nil)
    (mult_divides1 application-judgement "(divides(n))" divides nil)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (posrat_div_posrat_is_posrat application-judgement "posrat"
     rationals nil)
    (posnat_expt application-judgement "posnat" exponentiation nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (minus_even_is_even application-judgement "even_int" integers nil)
    (minus_nzint_is_nzint application-judgement "nzint" integers nil)
    (d_nth def-decl "below[10]" radix_sort_nat nil)
    (posint_times_posint_is_posint application-judgement "posint"
     integers nil)
    (even_times_int_is_even application-judgement "even_int" integers
     nil)
    (n_digits_nmod_leq formula-decl nil radix_sort_nat nil)
    (lex_preserves formula-decl nil radix_sort_nat nil)
    (n_digits_monotone formula-decl nil radix_sort_nat nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (div_by_one formula-decl nil div_nat "ints/")
    (both_sides_plus_lt1 formula-decl nil real_props nil)
    (both_sides_plus_le1 formula-decl nil real_props nil)
    (both_sides_minus_lt1 formula-decl nil real_props nil)
    (rat_div_nzrat_is_rat application-judgement "rat" rationals nil)
    (rat_times_rat_is_rat application-judgement "rat" rationals nil)
    (rat_minus_rat_is_rat application-judgement "rat" rationals nil)
    (minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (x!3 skolem-const-decl "nat" radix_sort_nat nil)
    (x!4 skolem-const-decl "{j: below[N + 1] | x!3 <= j}"
     radix_sort_nat nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (d_nth_digits formula-decl nil radix_sort_nat nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posrat_max application-judgement "{s: posrat | s >= q AND s >= r}"
     real_defs nil)
    (posint_max application-judgement "{k: posint | i <= k AND j <= k}"
     real_defs nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (lex inductive-decl "bool" radix_sort nil)
    (leq_N const-decl "[below[N] -> (total_preorder?[nat])]"
     radix_sort_nat nil)
    (total_preorder? const-decl "bool" total_preorder nil)
    (PRED type-eq-decl nil defined_types nil)
    (upto nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (wf_nat formula-decl nil naturalnumbers nil)
    (n_digits def-decl "posnat" radix_sort_nat nil)
    (posnat nonempty-type-eq-decl nil integers nil)
    (> const-decl "bool" reals nil)
    (nonneg_int nonempty-type-eq-decl nil integers nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (naturalnumber type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (N const-decl "nat" radix_sort_nat nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (measure_induction formula-decl nil measure_induction nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil))
   nil))
 (lex_nat_works_TCC1 0
  (lex_nat_works_TCC1-1 nil 3795166700 ("" (subtype-tcc) nil nil) nil
   nil))
 (lex_nat_works 0
  (lex_nat_works-1 nil 3795166790
   ("" (skeep)
    (("" (lemma "lex_nat_works_aux")
      (("" (inst -1 "m" "n" "N" "N") (("" (assert) nil nil)) nil))
      nil))
    nil)
   ((lex_nat_works_aux formula-decl nil radix_sort_nat nil)
    (posrat_max application-judgement "{s: posrat | s >= q AND s >= r}"
     real_defs nil)
    (posint_max application-judgement "{k: posint | i <= k AND j <= k}"
     real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (< const-decl "bool" reals nil)
    (N const-decl "nat" radix_sort_nat nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil))
 (radixsort_nat_works_TCC1 0
  (radixsort_nat_works_TCC1-1 nil 3795166700 ("" (grind) nil nil)
   ((AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (leq_N const-decl "[below[N] -> (total_preorder?[nat])]"
     radix_sort_nat nil)
    (total_preorder? const-decl "bool" total_preorder nil)
    (PRED type-eq-decl nil defined_types nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (N const-decl "nat" radix_sort_nat nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (radixsort const-decl "list[T]" radix_sort nil)
    (permutations const-decl "bool" sorting_aux nil))
   nil))
 (radixsort_nat_works 0
  (radixsort_nat_works-1 nil 3795166817
   ("" (skeep)
    (("" (lemma "radixsort_permutes")
      (("" (inst -1 "l")
        (("" (assert)
          (("" (prop)
            (("1" (expand "is_sorted?")
              (("1" (skeep :preds? t)
                (("1" (hide 1)
                  (("1" (expand "permutations")
                    (("1" (use "same_occurrences_same_length[nat]")
                      (("1" (prop) (("1" (grind) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (use "radixsort_sorts")
              (("2" (expand "is_sorted?")
                (("2" (skeep)
                  (("2" (inst?)
                    (("2" (assert)
                      (("2" (lemma "lex_nat_works")
                        (("2"
                          (inst -1 "nth(radixsort(l), k)"
                           "nth(radixsort(l), 1 + k)")
                          (("2" (assert)
                            (("2"
                              (lemma
                               "permutations_preserve_contents[nat]")
                              (("2"
                                (inst -1 "radixsort(l)" "l" "_")
                                (("2"
                                  (inst-cp -1 "k")
                                  (("2"
                                    (inst -1 "1+k")
                                    (("2"
                                      (assert)
                                      (("2"
                                        (skeep*)
                                        (("2"
                                          (replaces -1 :dir rl)
                                          (("2"
                                            (replaces -1 :dir rl)
                                            (("2"
                                              (lemma
                                               "max_digits_works")
                                              (("2"
                                                (inst -1 "l" "_")
                                                (("2"
                                                  (inst-cp -1 "j!1")
                                                  (("2"
                                                    (inst -1 "j")
                                                    (("2"
                                                      (grind)
                                                      nil
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((leq_N const-decl "[below[N] -> (total_preorder?[nat])]"
     radix_sort_nat nil)
    (total_preorder? const-decl "bool" total_preorder nil)
    (PRED type-eq-decl nil defined_types nil)
    (below type-eq-decl nil nat_types nil)
    (< const-decl "bool" reals nil)
    (N const-decl "nat" radix_sort_nat nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (radixsort_permutes formula-decl nil radix_sort nil)
    (radixsort_sorts formula-decl nil radix_sort nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nth def-decl "T" list_props nil)
    (permutations_preserve_contents formula-decl nil sorting_aux nil)
    (max_digits_works formula-decl nil radix_sort_nat nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (radixsort_aux def-decl "list[T]" radix_sort nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (real_minus_real_is_real application-judgement "real" reals nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (TRUE const-decl "bool" booleans nil)
    (posint_max application-judgement "{k: posint | i <= k AND j <= k}"
     real_defs nil)
    (posrat_max application-judgement "{s: posrat | s >= q AND s >= r}"
     real_defs nil)
    (lex_nat_works formula-decl nil radix_sort_nat nil)
    (is_sorted? const-decl "bool" sorting nil)
    (same_occurrences_same_length formula-decl nil sorting_aux nil)
    (radixsort const-decl "list[T]" radix_sort nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (occurrences def-decl "nat" sorting_aux nil)
    (length def-decl "nat" list_props nil)
    (permutations const-decl "bool" sorting_aux nil)
    (list type-decl nil list_adt nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil))
   nil)))

