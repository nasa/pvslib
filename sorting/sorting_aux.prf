(sorting_aux (elim_list_TCC1 0 (elim_list_TCC1-1 nil 3582282533 ("" (tcc)) nil nil (elim_list subtype "sorting_aux.l" "(list_adt[sorting_aux.T].cons?)"))) (elim_list_TCC2 0 (elim_list_TCC2-1 nil 3582282533 ("" (tcc)) ((T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (member def-decl "bool" list_props nil)) nil (elim_list subtype "list_adt[sorting_aux.T].cdr(sorting_aux.l)" "{l: list_adt[sorting_aux.T].list | (booleans.NOT)(list_adt[sorting_aux.T].null?(l))}"))) (elim_list_TCC3 0 (elim_list_TCC3-1 nil 3582282533 ("" (tcc)) ((T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (member def-decl "bool" list_props nil)) nil (elim_list subtype "sorting_aux.x" "{x: sorting_aux.T | list_props[sorting_aux.T].member(x, list_adt[sorting_aux.T].cdr(sorting_aux.l))}"))) (elim_list_TCC4 0 (elim_list_TCC4-1 nil 3654356775 ("" (termination-tcc) nil nil) ((length def-decl "nat" list_props nil)) nil (elim_list termination "sorting_aux.elim_list(list_adt[sorting_aux.T].cdr(sorting_aux.l), sorting_aux.x)" "nil"))) (elim_list_length_TCC1 0 (elim_list_length_TCC1-1 nil 3620640559 ("" (skeep) (("" (grind) nil nil)) nil) ((member def-decl "bool" list_props nil)) nil (elim_list_length subtype "sorting_aux.l" "{l: list_adt[sorting_aux.T].list | (booleans.NOT)(list_adt[sorting_aux.T].null?(l))}"))) (elim_list_length 0 (elim_list_length-2 "" 3804612450 ("" (measure-induct+ "length(l)" "l") (("1" (skeep) (("1" (case "null?(x!1)") (("1" (hide -2 1) (("1" (grind) nil nil)) nil) ("2" (expand "elim_list" 2) (("2" (lift-if) (("2" (prop) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (expand "length" 2 1) (("2" (expand "length" 2 2) (("2" (assert) (("2" (inst?) (("2" (prop) (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil) ("3" (hide -1 2 3) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil) ("3" (hide +) (("3" (grind) nil nil)) nil)) nil) nil shostak) (elim_list_length-1 nil 3620640571 ("" (measure-induct+ "length(l)" "l") (("1" (skeep) (("1" (case "null?(x!1)") (("1" (hide -2 1) (("1" (grind) nil nil)) nil) ("2" (expand "elim_list" 2) (("2" (lift-if) (("2" (prop) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (expand "length" 2 1) (("2" (expand "length" 2 2) (("2" (assert) (("2" (inst?) (("2" (prop) (("1" (assert) nil nil) ("2" (hide 3) (("2" (expand "member" -1) (("2" (propax) nil nil)) nil)) nil) ("3" (hide -1 2 3) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3)) (("2" (grind) nil nil)) nil) ("3" (hide +) (("3" (grind) nil nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (elim_list def-decl "list[T]" sorting_aux nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (preservation_contents_TCC1 0 (preservation_contents_TCC1-1 nil 3517307925 ("" (tcc)) nil shostak (preservation_contents subtype "sorting_aux.l" "(list_adt[sorting_aux.T].cons?)"))) (preservation_contents 0 (preservation_contents-1 nil 3517308006 ("" (skeep) (("" (skeep) (("" (inst -1 "k+1") (("1" (grind) nil nil) ("2" (typepred "k") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ((nth def-decl "T" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (l skolem-const-decl "{l: list[T] | NOT null?(l)}" sorting_aux nil) (below type-eq-decl nil nat_types nil) (k skolem-const-decl "below[length(cdr(l))]" sorting_aux nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak)) (nth_implies_member 0 (nth_implies_member-1 nil 3532265876 ("" (measure-induct+ "length(l)" ("l")) (("1" (case "null?(x!1)") (("1" (skeep) (("1" (hide -2 1) (("1" (expand "nth") (("1" (typepred "k") (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (skosimp*) (("2" (case "k!1 = 0") (("1" (replace -1) (("1" (expand "member" 2) (("1" (assert) (("1" (prop) (("1" (hide 3) (("1" (expand "nth" -3) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "cdr(x!1)") (("1" (inst -1 "i!1" "k!1 - 1") (("1" (prop) (("1" (expand "nth" -2) (("1" (assert) (("1" (expand "member" 3) (("1" (propax) nil nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (grind) nil nil)) nil) ("3" (hide -1 2 4) (("3" (expand "length" 1 2) (("3" (assert) nil nil)) nil)) nil)) nil) ("2" (typepred "k!1") (("2" (hide 4) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (hide -1 2 4) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "k!1") (("2" (hide -2 -3 2) (("2" (grind) nil nil)) nil)) nil) ("3" (typepred "k!1") (("3" (hide 2) (("3" (grind) nil nil)) nil)) nil)) nil) ((null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (k!1 skolem-const-decl "below[length(x!1)]" sorting_aux nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (x!1 skolem-const-decl "list[T]" sorting_aux nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (member def-decl "bool" list_props nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (member_implies_exists_nth 0 (member_implies_exists_nth-1 nil 3532297042 ("" (measure-induct+ "l`length" ("l")) (("1" (skeep) (("1" (expand "member" -2) (("1" (case "i = car(x!1)") (("1" (inst 1 0) (("1" (expand "nth" 1) (("1" (assert) nil nil)) nil) ("2" (hide -) (("2" (typepred "x!1") (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst -1 "cdr(x!1)") (("1" (inst -1 "i") (("1" (lemma "length_dec") (("1" (inst -1 "x!1") (("1" (prop) (("1" (skosimp*) (("1" (inst 2 "k!1 + 1") (("1" (expand "nth" 2) (("1" (propax) nil nil)) nil) ("2" (typepred "k!1") (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide +) (("2" (expand "member") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but 1) (("2" (skeep) (("2" (typepred "k") (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide-all-but 1) (("3" (skeep) (("3" (typepred "k") (("3" (grind) nil nil)) nil)) nil)) nil)) nil) ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (x!1 skolem-const-decl "{l: list[T] | NOT null?(l)}" sorting_aux nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (k!1 skolem-const-decl "below[length(cdr(x!1))]" sorting_aux nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (length def-decl "nat" list_props nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (nth_of_list_is_nth_append_list_TCC1 0 (nth_of_list_is_nth_append_list_TCC1-1 nil 3532297029 ("" (skeep :preds? t) (("" (rewrite "length_append") (("" (assert) nil nil)) nil)) nil) ((length_append formula-decl nil list_props nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) shostak (nth_of_list_is_nth_append_list subtype "sorting_aux.k" "below[length[T](append[T](l1, l2))]"))) (nth_of_list_is_nth_append_list 0 (nth_of_list_is_nth_append_list-1 nil 3532297584 ("" (measure-induct "l1`length" ("l1")) (("1" (skeep) (("1" (skeep) (("1" (case "null?(x)") (("1" (hide -2) (("1" (typepred "k") (("1" (hide +) (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (case-replace "k=0" :hide? t) (("1" (hide -) (("1" (expand "nth" 2 1) (("1" (expand "append") (("1" (assert) (("1" (expand "nth") (("1" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "cdr(x)") (("1" (expand "list2finseq") (("1" (expand "length" -1 2) (("1" (assert) (("1" (inst -1 "l2" "k - 1") (("1" (expand "nth" 3 1) (("1" (replace -1 3) (("1" (expand "append" 3 2) (("1" (expand "nth" 3 2) (("1" (propax) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "k") (("2" (hide 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (skeep :preds? t) (("2" (expand "list2finseq") (("2" (rewrite "length_append") (("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("3" (hide 2) (("3" (skeep :preds? t) (("3" (expand "list2finseq") (("3" (propax) nil nil)) nil)) nil)) nil)) nil) ((length_append formula-decl nil list_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (x skolem-const-decl "list[T]" sorting_aux nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (k skolem-const-decl "below[length(x)]" sorting_aux nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (append def-decl "list[T]" list_props nil) (length def-decl "nat" list_props nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (nth_of_cons_TCC1 0 (nth_of_cons_TCC1-1 nil 3620472388 ("" (skeep) (("" (grind) nil nil)) nil) ((length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (nth_of_cons subtype "sorting_aux.x" "below[length[T](cons[T](k, l))]"))) (nth_of_cons_TCC2 0 (nth_of_cons_TCC2-1 nil 3620472388 ("" (grind) nil nil) ((length def-decl "nat" list_props nil)) nil (nth_of_cons subtype "sorting_aux.x" "below[length[T](cons[T](k, l))]"))) (nth_of_cons_TCC3 0 (nth_of_cons_TCC3-1 nil 3620472388 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (nth_of_cons subtype "(number_fields.-)(sorting_aux.x, 1)" "below[length[T](l)]"))) (nth_of_cons 0 (nth_of_cons-1 nil 3620472389 ("" (skeep) (("" (prop) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ((nth def-decl "T" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak)) (nth_of_append_TCC1 0 (nth_of_append_TCC1-1 nil 3620462305 ("" (skeep) (("" (rewrite "length_append") (("" (assert) nil nil)) nil)) nil) ((length_append formula-decl nil list_props nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (nth_of_append subtype "sorting_aux.i" "below[length[T](append[T](l1, l2))]"))) (nth_of_append_TCC2 0 (nth_of_append_TCC2-1 nil 3620462305 ("" (subtype-tcc) nil nil) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (nth_of_append subtype "(number_fields.-)(sorting_aux.i, list_props[sorting_aux.T].length(sorting_aux.l1))" "below[length[T](l2)]"))) (nth_of_append 0 (nth_of_append-1 nil 3620462306 ("" (measure-induct "l1`length" ("l1")) (("1" (skeep) (("1" (skeep) (("1" (case "null?(x)") (("1" (hide -2) (("1" (grind) nil nil)) nil) ("2" (case "null?(l2)") (("1" (hide -2) (("1" (lift-if) (("1" (prop) (("1" (lemma "nth_of_list_is_nth_append_list") (("1" (inst -1 "x" "l2" "i") (("1" (assert) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil) ("2" (typepred "i") (("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "i=0") (("1" (replace -1) (("1" (hide -) (("1" (lift-if) (("1" (prop) (("1" (grind) nil nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "cdr(x)") (("1" (auto-rewrite "list2finseq") (("1" (assert) (("1" (prop) (("1" (lift-if) (("1" (prop) (("1" (inst -2 "l2" "i - 1") (("1" (lemma "nth_of_list_is_nth_append_list") (("1" (inst -1 "x" "l2" "i") (("1" (assert) nil nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (inst -2 "l2" "i-1") (("1" (lift-if) (("1" (assert) (("1" (expand "append" 2) (("1" (lemma "nth_of_cons") (("1" (inst -1 "append(cdr(x),l2)" "car(x)" "i") (("1" (assert) (("1" (replaces -1) (("1" (expand "length" 2) (("1" (assert) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" -1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 5) (("2" (expand "length" 1 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (grind) nil nil)) nil) ("3" (hide 2) (("3" (skeep) (("3" (typepred "i") (("3" (rewrite "length_append") nil nil)) nil)) nil)) nil)) nil) ((length_append formula-decl nil list_props nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (i skolem-const-decl "below[length(l2) + length(x)]" sorting_aux nil) (l2 skolem-const-decl "list[T]" sorting_aux nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nth_of_cons formula-decl nil sorting_aux nil) (int_plus_int_is_int application-judgement "int" integers nil) (TRUE const-decl "bool" booleans nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (x skolem-const-decl "list[T]" sorting_aux nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth_of_list_is_nth_append_list formula-decl nil sorting_aux nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IF const-decl "[boolean, T, T -> T]" if_def nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (append def-decl "list[T]" list_props nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (list2finseq const-decl "finseq[T]" list2finseq nil) (finseq type-eq-decl nil finite_sequences nil) (below type-eq-decl nil nat_types nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (null_rev_null 0 (null_rev_null-1 nil 3518528061 ("" (grind) nil nil) ((reverse def-decl "list[T]" list_props nil)) shostak)) (nth_member_TCC1 0 (nth_member_TCC1-1 nil 3532267079 ("" (tcc)) nil nil (nth_member subtype "sorting_aux.m" "below[length[T](l)]"))) (nth_member 0 (nth_member-1 nil 3518785192 ("" (measure-induct+ "m" "m") (("" (skosimp*) (("" (case "x!1=0") (("1" (hide -2) (("1" (typepred "l!1") (("1" (replace -3) (("1" (expand "nth") (("1" (case "cons?(l!1)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" -2) (("2" (assert) (("2" (inst -1 "x!1-1") (("2" (assert) (("2" (inst -1 "cdr(l!1)" k!1) (("1" (assert) (("1" (expand "member" 2) (("1" (case "cons?(l!1)") (("1" (assert) nil nil) ("2" (typepred "l!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (typepred "l!1") (("2" (case "cons?(l!1)") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (x!1 skolem-const-decl "nat" sorting_aux nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (l!1 skolem-const-decl "{l: list[T] | x!1 < length(l)}" sorting_aux nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (length def-decl "nat" list_props nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (car_rev_TCC1 0 (car_rev_TCC1-1 nil 3518961800 ("" (tcc)) ((boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (car_rev subtype "sorting_aux.l" "(list_adt[sorting_aux.T].cons?)"))) (car_rev_TCC2 0 (car_rev_TCC2-1 nil 3518961800 ("" (skeep) (("" (typepred "l") (("" (lemma "length_reverse") (("" (inst -1 "cdr(l)") (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (> const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length_reverse formula-decl nil list_props nil)) shostak (car_rev subtype "list_props[sorting_aux.T].reverse(list_adt[sorting_aux.T].cdr(sorting_aux.l))" "(list_adt[sorting_aux.T].cons?)"))) (car_rev_TCC3 0 (car_rev_TCC3-1 nil 3518961800 ("" (subtype-tcc) (("" (hide -1) (("" (lemma "length_reverse") (("" (inst -1 "l!1") (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((length_reverse formula-decl nil list_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (> const-decl "bool" reals nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil)) shostak (car_rev subtype "list_props[sorting_aux.T].reverse(sorting_aux.l)" "(list_adt[sorting_aux.T].cons?)"))) (car_rev 0 (car_rev-1 nil 3518961800 ("" (skolem!) (("" (expand "reverse" 1 2) (("" (case "null?(l!1)") (("1" (typepred "l!1") (("1" (hide 1) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) (("2" (expand "append") (("2" (typepred "l!1") (("2" (case "null?(cdr(l!1))") (("1" (hide 1 2) (("1" (grind) nil nil)) nil) ("2" (lift-if) (("2" (prop) (("1" (lemma "null_rev_null") (("1" (inst -1 "reverse(cdr(l!1))") (("1" (lemma "reverse_reverse[T]") (("1" (inst?) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((reverse def-decl "list[T]" list_props nil) (null_rev_null formula-decl nil sorting_aux nil) (reverse_reverse formula-decl nil list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (append def-decl "list[T]" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (bool nonempty-type-eq-decl nil booleans nil) (> const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil)) shostak)) (nth_rev_zero_TCC1 0 (nth_rev_zero_TCC1-1 nil 3518522428 ("" (tcc)) ((T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (length def-decl "nat" list_props nil)) nil (nth_rev_zero subtype "0" "below[length[T](l)]"))) (nth_rev_zero_TCC2 0 (nth_rev_zero_TCC2-1 nil 3518522428 ("" (subtype-tcc) (("1" (hide -1) (("1" (lemma "length_reverse") (("1" (inst -1 "l!1") (("1" (grind) nil nil)) nil)) nil)) nil) ("2" (hide -1) (("2" (grind) nil nil)) nil)) nil) ((length_reverse formula-decl nil list_props nil) (reverse def-decl "list[T]" list_props nil) (length def-decl "nat" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak (nth_rev_zero subtype "(number_fields.-)(list_props[sorting_aux.T].length(sorting_aux.l), 1)" "below[length[T](reverse[T](l))]"))) (nth_rev_zero 0 (nth_rev_zero-1 nil 3518522429 ("" (measure-induct+ "length(l)" "l") (("1" (expand "nth" 1 1) (("1" (expand "nth" 1) (("1" (case "length(x!1) - 1 = 0") (("1" (assert) (("1" (hide -2) (("1" (expand "reverse") (("1" (case "null?(cdr(x!1))") (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) (("2" (inst -1 "reverse(cdr(reverse(x!1)))") (("1" (lemma "reverse_reverse") (("1" (inst?) (("1" (replace -1) (("1" (expand "nth" -2 1) (("1" (lemma "length_reverse") (("1" (inst-cp -1 "x!1") (("1" (prop) (("1" (inst -2 "cdr(reverse(x!1))") (("1" (lemma "car_rev") (("1" (inst -1 "reverse(x!1)") (("1" (lemma "reverse_reverse") (("1" (inst -1 "x!1") (("1" (assert) (("1" (replaces -1) (("1" (replaces -3) (("1" (expand "length" -3 1) (("1" (lift-if) (("1" (prop) (("1" (hide -4 -5 2) (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-3 1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (inst -1 "cdr(reverse(x!1))") (("2" (replaces -1) (("2" (expand "length" -1 1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (case "null?(cdr[T](reverse[T](x!1)))") (("1" (expand "length" 1) (("1" (hide -2 -3 2) (("1" (case "length(x!1)=1") (("1" (grind) nil nil) ("2" (case "length(reverse(x!1))=1") (("1" (lemma "length_reverse") (("1" (inst?) (("1" (assert) nil nil)) nil)) nil) ("2" (case "length(cdr(reverse(x!1)))=0") (("1" (expand "length" 1) (("1" (typepred "x!1") (("1" (lemma "null_rev_null") (("1" (inst -1 "reverse(x!1)") (("1" (lemma "reverse_reverse") (("1" (inst?) (("1" (replace -1) (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (name-replace "ma" "cdr[T](reverse[T](x!1))") (("2" (hide 2 3) (("2" (lemma "length_reverse") (("2" (inst?) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 2) (("2" (rewrite "length_reverse") (("2" (grind) nil nil)) nil)) nil) ("3" (typepred "l!1") (("3" (grind) nil nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (append def-decl "list[T]" list_props nil) (x!1 skolem-const-decl "{l: list[T] | NOT null?(l)}" sorting_aux nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (> const-decl "bool" reals nil) (TRUE const-decl "bool" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (car_rev formula-decl nil sorting_aux nil) (length_reverse formula-decl nil list_props nil) (reverse_reverse formula-decl nil list_props nil) (null_rev_null formula-decl nil sorting_aux nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (reverse def-decl "list[T]" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (nth_rev_last_TCC1 0 (nth_rev_last_TCC1-1 nil 3525021198 ("" (tcc)) ((T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (length def-decl "nat" list_props nil)) nil (nth_rev_last subtype "(number_fields.-)(list_props[sorting_aux.T].length(sorting_aux.l), 1)" "below[length[T](l)]"))) (nth_rev_last_TCC2 0 (nth_rev_last_TCC2-1 nil 3525021198 ("" (subtype-tcc) (("" (hide -) (("" (lemma "length_reverse") (("" (inst -1 "l!1") (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((length_reverse formula-decl nil list_props nil) (reverse def-decl "list[T]" list_props nil) (length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (boolean nonempty-type-decl nil booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil)) shostak (nth_rev_last subtype "0" "below[length[T](reverse[T](l))]"))) (nth_rev_last 0 (nth_rev_last-1 nil 3525021200 ("" (skosimp*) (("" (lemma "nth_rev_zero") (("" (case "length(l!1) = 0") (("1" (hide -2) (("1" (grind) nil nil)) nil) ("2" (lemma "nth_rev_zero") (("2" (lemma "reverse_reverse") (("2" (inst -2 "reverse(l!1)") (("1" (inst -1 "l!1") (("1" (replace -1 -2) (("1" (lemma "length_reverse") (("1" (inst -1 "l!1") (("1" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -3 2) (("2" (lemma "length_reverse") (("2" (inst -1 "l!1") (("2" (replace -1 1 rl) (("2" (hide -1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nth_rev_zero formula-decl nil sorting_aux nil) (reverse def-decl "list[T]" list_props nil) (l!1 skolem-const-decl "{l: list[T] | NOT null?(l)}" sorting_aux nil) (int_minus_int_is_int application-judgement "int" integers nil) (length_reverse formula-decl nil list_props nil) (reverse_reverse formula-decl nil list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)) shostak)) (nth_append_TCC1 0 (nth_append_TCC1-1 nil 3519203110 ("" (skeep) (("" (lemma "length_append") (("" (inst -1 "l" "p") (("" (typepred "m") (("" (typepred "l" "p") (("" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil sorting_aux nil) (length_append formula-decl nil list_props nil) (append def-decl "list[T]" list_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (< const-decl "bool" reals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (list type-decl nil list_adt nil)) shostak (nth_append subtype "sorting_aux.m" "below[length[T](append[T](l, p))]"))) (nth_append_TCC2 0 (nth_append_TCC2-1 nil 3655720139 ("" (subtype-tcc) nil nil) nil nil (nth_append subtype "sorting_aux.m" "below[length[T](l)]"))) (nth_append 0 (nth_append-1 nil 3519203110 ("" (induct "m") (("1" (grind) nil nil) ("2" (skosimp*) (("2" (expand "nth" 1) (("2" (inst -1 "cdr(l!1)" "p!1") (("1" (grind) nil nil) ("2" (typepred "l!1") (("2" (hide 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (skosimp*) (("3" (lemma "length_append") (("3" (inst?) (("3" (replaces -1) (("3" (typepred "m!2") (("3" (typepred "l!1" "p!1") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (TRUE const-decl "bool" booleans nil) (length_append formula-decl nil list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (j!1 skolem-const-decl "nat" sorting_aux nil) (l!1 skolem-const-decl "{l: list[T] | NOT null?(l) AND 1 + j!1 < length(l)}" sorting_aux nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nat_induction formula-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (pred type-eq-decl nil defined_types nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (append def-decl "list[T]" list_props nil)) shostak)) (nth_rev_TCC1 0 (nth_rev_TCC1-1 nil 3518521656 ("" (subtype-tcc) (("" (hide -2) (("" (case "null?(l!1)") (("1" (propax) nil nil) ("2" (lemma "length_reverse") (("2" (inst -1 "l!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ((length_reverse formula-decl nil list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (reverse def-decl "list[T]" list_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (>= const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil)) shostak (nth_rev subtype "(number_fields.-)((number_fields.-)(list_props[sorting_aux.T].length(sorting_aux.l), 1), sorting_aux.m)" "below[length[T](reverse[T](l))]"))) (nth_rev 0 (nth_rev-1 nil 3518521657 ("" (measure-induct+ "m" "m") (("1" (skolem!) (("1" (case "x!1=0") (("1" (lemma "nth_rev_zero") (("1" (inst?) (("1" (hide -3) (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (case "x!1=length(l!1)-1") (("1" (replace -1) (("1" (assert) (("1" (lemma "nth_rev_zero") (("1" (inst -1 "reverse(l!1)") (("1" (lemma "reverse_reverse") (("1" (inst?) (("1" (lemma "length_reverse") (("1" (inst?) (("1" (hide -5) (("1" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "l!1") (("2" (hide-all-but (-2 1)) (("2" (lemma "null_rev_null") (("2" (inst -1 "reverse(l!1)") (("2" (lemma "reverse_reverse") (("2" (inst?) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "nth" 3) (("2" (assert) (("2" (inst -1 "x!1-1") (("2" (assert) (("2" (inst -1 "cdr(l!1)") (("1" (expand "length" 3) (("1" (expand "nth" -1 2) (("1" (expand "length" 1) (("1" (assert) (("1" (expand "reverse" 3) (("1" (lemma "nth_append") (("1" (inst -1 "length(cdr(l!1)) -x!1" "reverse(cdr(l!1))" "cons(car(l!1),null)") (("1" (expand "nth" -1) (("1" (assert) nil nil)) nil) ("2" (lemma "length_reverse") (("2" (inst -1 "cdr(l!1)") (("2" (typepred "l!1") (("2" (hide -3 5) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (typepred "l!1") (("3" (hide -2 5) (("3" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "l!1") (("2" (hide 5) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (typepred "l!1") (("2" (lemma "length_reverse") (("2" (inst?) (("2" (hide-all-but (-1 2)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (lemma "length_reverse") (("3" (inst?) (("3" (grind) nil nil)) nil)) nil)) nil) ((x!1 skolem-const-decl "nat" sorting_aux nil) (l!1 skolem-const-decl "{l: list[T] | NOT null?(l) AND x!1 < length(l)}" sorting_aux nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (length_reverse formula-decl nil list_props nil) (reverse_reverse formula-decl nil list_props nil) (null_rev_null formula-decl nil sorting_aux nil) (null adt-constructor-decl "(null?)" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (nth_append formula-decl nil sorting_aux nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (nth_rev_zero formula-decl nil sorting_aux nil) (odd_minus_odd_is_even application-judgement "even_int" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (= const-decl "[T, T -> boolean]" equalities nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (length def-decl "nat" list_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (reverse def-decl "list[T]" list_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (occurrences_TCC1 0 (occurrences_TCC1-1 nil 3652111426 ("" (termination-tcc) nil nil) nil nil (occurrences subtype "sorting_aux.l" "(list_adt[sorting_aux.T].cons?)"))) (occurrences_TCC2 0 (occurrences_TCC2-1 nil 3778233903 ("" (termination-tcc) nil nil) ((length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (occurrences termination "sorting_aux.occurrences(list_adt[sorting_aux.T].cdr(sorting_aux.l))" "nil"))) (occurrences_TCC3 0 (occurrences_TCC3-1 nil 3778233903 ("" (termination-tcc) nil nil) ((length def-decl "nat" list_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil)) nil (occurrences termination "sorting_aux.occurrences(list_adt[sorting_aux.T].cdr(sorting_aux.l))" "nil"))) (occurrences_of_nth_element 0 (occurrences_of_nth_element-1 nil 3620571726 ("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (case "null?(cdr(x!1))") (("1" (hide -2) (("1" (grind) (("1" (typepred "i") (("1" (case "i=0") (("1" (grind) nil nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil) ("2" (expand "occurrences" 3) (("2" (expand "nth" 3) (("2" (lift-if) (("2" (lift-if) (("2" (assert) (("2" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil) ("3" (inst -1 "cdr(x!1)") (("3" (inst -1 "i-1") (("1" (prop) (("1" (hide-all-but (1 6)) (("1" (grind) nil nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (assert) nil nil)) nil)) nil)) nil) ((i skolem-const-decl "below[length(x!1)]" sorting_aux nil) (x!1 skolem-const-decl "list[T]" sorting_aux nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nth def-decl "T" list_props nil) (occurrences def-decl "nat" sorting_aux nil) (> const-decl "bool" reals nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (NOT const-decl "[bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (below type-eq-decl nil nat_types nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (occurrences_of_app 0 (occurrences_of_app-1 nil 3558777610 ("" (measure-induct+ "length(l1)" ("l1")) (("" (skeep) (("" (expand "occurrences" 1 2) (("" (lift-if) (("" (prop) (("1" (expand "append" 1) (("1" (lift-if) (("1" (assert) nil nil)) nil)) nil) ("2" (inst -2 "cdr(x!1)") (("2" (inst -2 "l2" "x") (("2" (prop) (("1" (expand "occurrences" 1 1) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but (-1 2)) (("1" (grind) nil nil)) nil) ("2" (expand "append" 1 1) (("2" (grind) nil nil)) nil) ("3" (grind) nil nil)) nil)) nil)) nil) ("2" (hide -1 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (inst -1 "cdr(x!1)") (("3" (inst -1 "l2" "x") (("3" (prop) (("1" (grind) nil nil) ("2" (hide 2 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (append def-decl "list[T]" list_props nil) (occurrences def-decl "nat" sorting_aux nil) (= const-decl "[T, T -> boolean]" equalities nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (cons_of_perm_is_permutation 0 (cons_of_perm_is_permutation-1 nil 3558375026 ("" (skeep) (("" (expand "permutations") (("" (skeep) (("" (inst -1 "x_1") (("" (expand "occurrences" 1) (("" (lift-if) (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((permutations const-decl "bool" sorting_aux nil) (T formal-type-decl nil sorting_aux nil) (occurrences def-decl "nat" sorting_aux nil)) shostak)) (ocurrence_list_has_element 0 (ocurrence_list_has_element-1 nil 3556904709 ("" (measure-induct+ "length(l)" "l") (("" (skosimp) (("" (expand "occurrences" 1) (("" (lift-if) (("" (prop) (("1" (inst 3 0) (("1" (expand "nth" 3) (("1" (propax) nil nil)) nil) ("2" (hide -1 -2 2) (("2" (grind) nil nil)) nil)) nil) ("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "x!2") (("2" (prop) (("1" (skosimp) (("1" (inst 4 "i!1+1") (("1" (replace -1 4 rl) (("1" (hide -1 1 2) (("1" (grind) nil nil)) nil)) nil) ("2" (hide -1 2 3) (("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (hide 2 3 5) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (i!1 skolem-const-decl "below[length(cdr(x!1))]" sorting_aux nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (x!1 skolem-const-decl "list[T]" sorting_aux nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (occurrences def-decl "nat" sorting_aux nil) (/= const-decl "boolean" notequal nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (no_occurrence_implies 0 (no_occurrence_implies-1 nil 3556906761 ("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (skosimp) (("" (expand "occurrences" -2) (("" (lift-if) (("" (prop) (("1" (hide -2) (("1" (typepred "i!1") (("1" (grind) nil nil)) nil)) nil) ("2" (hide-all-but (-2 1)) (("2" (grind) nil nil)) nil) ("3" (inst -2 "cdr(x!1)") (("3" (inst -2 "x") (("3" (prop) (("1" (case "i!1=0") (("1" (hide -2 -3) (("1" (expand "nth") (("1" (assert) nil nil)) nil)) nil) ("2" (inst -1 "i!1-1") (("1" (hide -2) (("1" (grind) nil nil)) nil) ("2" (hide -1 -2 3) (("2" (prop) (("1" (assert) nil nil) ("2" (typepred "i!1") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (1 3)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (i!1 skolem-const-decl "below[length(x!1)]" sorting_aux nil) (x!1 skolem-const-decl "list[T]" sorting_aux nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (nth def-decl "T" list_props nil) (/= const-decl "boolean" notequal nil) (below type-eq-decl nil nat_types nil) (occurrences def-decl "nat" sorting_aux nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (member_implies_pos_occurrences 0 (member_implies_pos_occurrences-1 nil 3557217933 ("" (measure-induct+ "length(l)" ("l")) (("" (lemma "no_occurrence_implies") (("" (skeep) (("" (copy -1) (("" (hide -1) (("" (inst -1 "x!1" "x") (("" (assert) (("" (expand "member" -3) (("" (case "null?(x!1)") (("1" (assert) nil nil) ("2" (assert) (("2" (expand "occurrences" 2) (("2" (lift-if) (("2" (prop) (("1" (hide-all-but 1) (("1" (assert) nil nil)) nil) ("2" (assert) nil nil) ("3" (assert) nil nil) ("4" (inst -3 "cdr(x!1)") (("4" (inst -3 "x") (("4" (prop) (("4" (hide-all-but (1 4)) (("4" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((no_occurrence_implies formula-decl nil sorting_aux nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (occurrences def-decl "nat" sorting_aux nil) (> const-decl "bool" reals nil) (member def-decl "bool" list_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (occurrences_implies_member 0 (occurrences_implies_member-1 nil 3620566562 ("" (measure-induct+ "length(l)" "l") (("" (skeep) (("" (expand "member" 1) (("" (lift-if) (("" (prop) (("1" (grind) nil nil) ("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "x") (("2" (prop) (("1" (expand "occurrences" -1) (("1" (assert) nil nil)) nil) ("2" (hide -1 3 4) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (member def-decl "bool" list_props nil) (occurrences def-decl "nat" sorting_aux nil) (> const-decl "bool" reals nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (permutations_preserve_contents 0 (permutations_preserve_contents-1 nil 3556900259 ("" (skosimp) (("" (expand "permutations") (("" (typepred "i!1") (("" (inst -2 "nth(l1!1, i!1)") (("" (lemma "ocurrence_list_has_element") (("" (inst -1 "l2!1" "nth(l1!1, i!1)") (("" (prop) (("" (lemma "member_implies_pos_occurrences") (("" (inst -1 "l1!1" "nth(l1!1, i!1)") (("" (prop) (("1" (assert) nil nil) ("2" (lemma "nth_implies_member") (("2" (inst -1 "l1!1" "nth(l1!1, i!1)" i!1) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((permutations const-decl "bool" sorting_aux nil) (nth def-decl "T" list_props nil) (member_implies_pos_occurrences formula-decl nil sorting_aux nil) (real_gt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nth_implies_member formula-decl nil sorting_aux nil) (ocurrence_list_has_element formula-decl nil sorting_aux nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil)) shostak)) (permutations_is_commutative 0 (permutations_is_commutative-1 nil 3556822643 ("" (skeep) (("" (prop) (("1" (expand "permutations") (("1" (skeep) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil)) nil)) nil) ("2" (expand "permutations") (("2" (skeep) (("2" (inst -1 "x") (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((T formal-type-decl nil sorting_aux nil) (permutations const-decl "bool" sorting_aux nil)) shostak)) (permutations_is_transitive 0 (permutations_is_transitive-1 nil 3556895251 ("" (skeep) (("" (expand "permutations") (("" (skeep) (("" (inst -1 "x") (("" (inst -2 "x") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((permutations const-decl "bool" sorting_aux nil) (T formal-type-decl nil sorting_aux nil)) shostak)) (cons_elim_is_permutation 0 (cons_elim_is_permutation-2 "" 3804612651 ("" (measure-induct+ "length(l)" "l") (("1" (skeep) (("1" (expand "elim_list" 1) (("1" (lift-if) (("1" (prop) (("1" (replace -1) (("1" (hide -) (("1" (case "x!1 = cons(car(x!1), cdr(x!1))") (("1" (grind) nil nil) ("2" (decompose-equality) nil nil)) nil)) nil)) nil) ("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "x") (("2" (prop) (("1" (lemma "cons_of_perm_is_permutation") (("1" (inst -1 "cons(x, elim_list(cdr(x!1), x))" "cdr(x!1)" "car(x!1)") (("1" (assert) (("1" (case "permutations(cons(x, cons(car(x!1), elim_list(cdr(x!1), x))), cons(car(x!1), cons(x, elim_list(cdr(x!1), x))))") (("1" (case "  cons(car(x!1), cdr(x!1)) = x!1") (("1" (replace -1) (("1" (prop) (("1" (rewrite "permutations_is_commutative") (("1" (rewrite "permutations_is_commutative" -3) (("1" (hide -2 -4 -5 1) (("1" (lemma "permutations_is_transitive") (("1" (inst -1 "x!1" "cons(car(x!1), cons(x, elim_list(cdr(x!1), x)))" "cons(x, cons(car(x!1), elim_list(cdr(x!1), x)))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "permutations_is_commutative" -3) nil nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (decompose-equality) nil nil)) nil)) nil) ("2" (assert) (("2" (name-replace "nnn" "elim_list(cdr(x!1), x)") (("2" (hide -1 -2 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (grind) (("2" (expand "member" -1) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (expand "member") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-2 -3)) (("2" (grind) nil nil)) nil) ("3" (hide +) (("3" (grind) nil nil)) nil)) nil) nil shostak) (cons_elim_is_permutation-1 nil 3620638024 ("" (measure-induct+ "length(l)" "l") (("1" (skeep) (("1" (expand "elim_list" 1) (("1" (lift-if) (("1" (prop) (("1" (replace -1) (("1" (hide -) (("1" (case "x!1 = cons(car(x!1), cdr(x!1))") (("1" (grind) nil nil) ("2" (decompose-equality) nil nil)) nil)) nil)) nil) ("2" (inst -1 "cdr(x!1)") (("2" (inst -1 "x") (("2" (prop) (("1" (lemma "cons_of_perm_is_permutation") (("1" (inst -1 "cons(x, elim_list(cdr(x!1), x))" "cdr(x!1)" "car(x!1)") (("1" (assert) (("1" (case "permutations(cons(x, cons(car(x!1), elim_list(cdr(x!1), x))), cons(car(x!1), cons(x, elim_list(cdr(x!1), x))))") (("1" (case "  cons(car(x!1), cdr(x!1)) = x!1") (("1" (replace -1) (("1" (prop) (("1" (rewrite "permutations_is_commutative") (("1" (rewrite "permutations_is_commutative" -3) (("1" (hide -2 -4 -5 1) (("1" (lemma "permutations_is_transitive") (("1" (inst -1 "x!1" "cons(car(x!1), cons(x, elim_list(cdr(x!1), x)))" "cons(x, cons(car(x!1), elim_list(cdr(x!1), x)))") (("1" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "permutations_is_commutative" -3) nil nil)) nil)) nil) ("2" (hide-all-but (-4 1)) (("2" (decompose-equality) nil nil)) nil)) nil) ("2" (assert) (("2" (name-replace "nnn" "elim_list(cdr(x!1), x)") (("2" (hide -1 -2 3) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide 3) (("2" (grind) (("2" (expand "member" -1) (("2" (grind) nil nil)) nil)) nil)) nil) ("3" (hide 2 3) (("3" (expand "member") (("3" (assert) (("3" (lift-if) (("3" (prop) (("1" (hide -) (("1" (grind) nil nil)) nil) ("2" (hide -) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 -3)) (("2" (grind) nil nil)) nil) ("3" (hide +) (("3" (grind) nil nil)) nil)) nil) ((pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (measure_induction formula-decl nil measure_induction nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (boolean nonempty-type-decl nil booleans nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (bool nonempty-type-eq-decl nil booleans nil) (>= const-decl "bool" reals nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (length def-decl "nat" list_props nil) (< const-decl "bool" reals nil) (wf_nat formula-decl nil naturalnumbers nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (member def-decl "bool" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (elim_list def-decl "list[T]" sorting_aux nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (permutations const-decl "bool" sorting_aux nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (list_cons_extensionality formula-decl nil list_adt nil) (occurrences def-decl "nat" sorting_aux nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (= const-decl "[T, T -> boolean]" equalities nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cons_of_perm_is_permutation formula-decl nil sorting_aux nil) (permutations_is_transitive formula-decl nil sorting_aux nil) (permutations_is_commutative formula-decl nil sorting_aux nil)) shostak)) (same_occurrences_same_length 0 (same_occurrences_same_length-1 nil 3620636365 ("" (measure-induct+ "length(l1)" "l1") (("" (measure-induct+ "length(l)" "l") (("" (case "null?(x!1)") (("1" (hide -2 -4) (("1" (expand "length" 1 2) (("1" (assert) (("1" (expand "length" 1) (("1" (assert) (("1" (inst -2 "car(x!2)") (("1" (expand "occurrences" -2) (("1" (lift-if) (("1" (prop) (("1" (hide-all-but -1) (("1" (grind) nil nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (expand "length" 2 2) (("2" (assert) (("2" (lemma "ocurrence_list_has_element") (("2" (inst -1 "x!2" "car(x!1)") (("2" (prop) (("1" (skeep) (("1" (lemma "cons_elim_is_permutation") (("1" (hide -3) (("1" (inst?) (("1" (inst -1 "car(x!1)") (("1" (prop) (("1" (expand "permutations" -1) (("1" (inst -4 "cdr(x!1)") (("1" (inst -4 "elim_list(x!2, car(x!1))") (("1" (prop) (("1" (hide -2 -4) (("1" (lemma "elim_list_length") (("1" (lemma "nth_implies_member") (("1" (inst -1 "x!2" "car(x!1)" "i") (("1" (assert) (("1" (inst -2 "car(x!1)" "x!2") (("1" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (skeep) (("2" (inst -1 "x") (("2" (inst -3 "x") (("2" (replaces -1) (("2" (expand "occurrences" -2) (("2" (lift-if) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 2)) (("3" (grind) nil nil)) nil)) nil) ("2" (hide -1 -3) (("2" (lemma "nth_implies_member") (("2" (inst?) (("2" (inst?) (("1" (assert) nil nil) ("2" (typepred "i") (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide -2) (("3" (inst -3 "car(x!1)") (("3" (hide -2 2) (("3" (expand "occurrences") (("3" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide-all-but (-1 1)) (("2" (lemma "nth_implies_member") (("2" (inst?) (("2" (inst?) (("1" (assert) nil nil) ("2" (typepred "i") (("2" (hide -2 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (hide -2 -4) (("2" (inst -2 "car(x!1)") (("2" (expand "occurrences" -2 2) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((ocurrence_list_has_element formula-decl nil sorting_aux nil) (cons_elim_is_permutation formula-decl nil sorting_aux nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (elim_list_length formula-decl nil sorting_aux nil) (below type-eq-decl nil nat_types nil) (nth_implies_member formula-decl nil sorting_aux nil) (TRUE const-decl "bool" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (elim_list def-decl "list[T]" sorting_aux nil) (x!1 skolem-const-decl "list[T]" sorting_aux nil) (member def-decl "bool" list_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (permutations const-decl "bool" sorting_aux nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (x!2 skolem-const-decl "list[T]" sorting_aux nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (null? adt-recognizer-decl "[list -> boolean]" list_adt nil) (occurrences def-decl "nat" sorting_aux nil) (= const-decl "[T, T -> boolean]" equalities nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (permutations_is_ext_reflexive_TCC1 0 (permutations_is_ext_reflexive_TCC1-1 nil 3639231787 ("" (subtype-tcc) nil nil) nil nil (permutations_is_ext_reflexive subtype "sorting_aux.i" "below[length[T](l1)]"))) (permutations_is_ext_reflexive 0 (permutations_is_ext_reflexive-1 nil 3639231947 ("" (measure-induct+ "length(l)" ("l")) (("" (skeep) (("" (expand "permutations") (("" (skeep) (("" (expand "occurrences" 1) (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (lift-if) (("" (prop) (("1" (hide -3 -4) (("1" (typepred "l1" "x!1") (("1" (grind) nil nil)) nil)) nil) ("2" (typepred "l1" "x!1") (("2" (hide -3 -4) (("2" (grind) nil nil)) nil)) nil) ("3" (hide -3 -4) (("3" (grind) (("3" (typepred "l1" "x!1") (("3" (grind) nil nil)) nil)) nil)) nil) ("4" (inst -3 "cdr(x!1)") (("4" (inst -3 "cdr(l1)") (("1" (prop) (("1" (inst -1 "x") (("1" (assert) nil nil)) nil) ("2" (skeep) (("2" (expand "nth" -3) (("2" (inst -3 "i + 1") (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil)) nil) ("2" (typepred "i") (("2" (hide-all-but (-1 1 5)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 4)) (("3" (grind) nil nil)) nil)) nil) ("2" (typepred "l1") (("2" (hide -4 2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("5" (hide -2) (("5" (inst -2 0) (("1" (expand "nth") (("1" (assert) nil nil)) nil) ("2" (grind) nil nil)) nil)) nil) ("6" (typepred "l1") (("6" (hide -3 -4) (("6" (grind) nil nil)) nil)) nil) ("7" (hide -2) (("7" (inst -2 0) (("1" (grind) nil nil) ("2" (grind) nil nil)) nil)) nil) ("8" (inst -1 "cdr(x!1)") (("8" (inst -1 "cdr(l1)") (("1" (prop) (("1" (inst -1 "x") nil nil) ("2" (hide 3) (("2" (skeep) (("2" (inst -1 "i+1") (("1" (expand "nth" -1) (("1" (propax) nil nil)) nil) ("2" (typepred "i") (("2" (grind) nil nil)) nil)) nil)) nil)) nil) ("3" (hide-all-but (1 6)) (("3" (grind) nil nil)) nil)) nil) ("2" (typepred "l1" "x!1") (("2" (hide-all-but (-1 1 4 6)) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((NOT const-decl "[bool -> bool]" booleans nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (x!1 skolem-const-decl "list[T]" sorting_aux nil) (l1 skolem-const-decl "{l1: list[T] | length(l1) = length(x!1)}" sorting_aux nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (i skolem-const-decl "below[length(cdr(x!1))]" sorting_aux nil) (int_minus_int_is_int application-judgement "int" integers nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (i skolem-const-decl "below[length(cdr(x!1))]" sorting_aux nil) (occurrences def-decl "nat" sorting_aux nil) (permutations const-decl "bool" sorting_aux nil) (nth def-decl "T" list_props nil) (below type-eq-decl nil nat_types nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (suffix_TCC1 0 (suffix_TCC1-1 nil 3639212212 ("" (subtype-tcc) (("" (grind) nil nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil)) nil (suffix subtype "sorting_aux.l" "(list_adt[sorting_aux.T].cons?)"))) (suffix_TCC2 0 (suffix_TCC2-1 nil 3639212212 ("" (subtype-tcc) (("" (grind) (("" (expand "length") (("" (lift-if) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (odd_plus_even_is_odd application-judgement "odd_int" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil)) nil (suffix subtype "(number_fields.-)(sorting_aux.n, 1)" "below[1 + length[T](cdr[T](l))]"))) (suffix_TCC3 0 (suffix_TCC3-1 nil 3639212212 ("" (termination-tcc) (("" (grind) (("" (expand "length" 2 2) (("" (lift-if) (("" (grind) nil nil)) nil)) nil)) nil)) nil) ((nnint_plus_posint_is_posint application-judgement "posint" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil)) nil (suffix termination "sorting_aux.suffix(list_adt[sorting_aux.T].cdr(sorting_aux.l), (number_fields.-)(sorting_aux.n, 1))" "nil"))) (app_prefix_suffix 0 (app_prefix_suffix-1 nil 3639212631 ("" (measure-induct+ "length(l)" ("l")) (("" (skeep) (("" (expand "prefix" 1) (("" (lift-if) (("" (prop) (("1" (replace -1) (("1" (hide -2) (("1" (grind) nil nil)) nil)) nil) ("2" (expand "suffix" 2) (("2" (lift-if) (("2" (assert) (("2" (expand "append" 2) (("2" (inst? -1) (("2" (prop) (("1" (replace -1 2 rl) (("1" (hide -1) (("1" (decompose-equality 2) nil nil)) nil)) nil) ("2" (hide 3) (("2" (grind) (("2" (expand "length" 1 2) (("2" (grind) (("2" (typepred "n") (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (list_cons_extensionality formula-decl nil list_adt nil) (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil) (car adt-accessor-decl "[(cons?) -> T]" list_adt nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (suffix def-decl "list[T]" sorting_aux nil) (prefix def-decl "list[T]" sorting_aux nil) (append def-decl "list[T]" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (below type-eq-decl nil nat_types nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (wf_nat formula-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (length def-decl "nat" list_props nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (length_suffix 0 (length_suffix-1 nil 3639217290 ("" (measure-induct+ "n" ("l" "n")) (("" (expand "suffix" 1) (("" (lift-if) (("" (prop) (("1" (assert) nil nil) ("2" (inst? -1) (("1" (prop) (("1" (replace -1 2) (("1" (hide -) (("1" (expand "length" 2 2) (("1" (lift-if) (("1" (prop) (("1" (typepred "x!2") (("1" (grind) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil) ((int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (x!2 skolem-const-decl "below[1 + length(x!1)]" sorting_aux nil) (x!1 skolem-const-decl "list[T]" sorting_aux nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (suffix def-decl "list[T]" sorting_aux nil) (= const-decl "[T, T -> boolean]" equalities nil) (wf_nat formula-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (length_prefix 0 (length_prefix-1 nil 3639217549 ("" (measure-induct+ "n" ("l" "n")) (("" (expand "prefix" 1) (("" (lift-if) (("" (prop) (("1" (hide -2) (("1" (grind) nil nil)) nil) ("2" (expand "length" 2) (("2" (inst? -1) (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil) ((real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (x!1 skolem-const-decl "list[T]" sorting_aux nil) (x!2 skolem-const-decl "below[1 + length(x!1)]" sorting_aux nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (prefix def-decl "list[T]" sorting_aux nil) (= const-decl "[T, T -> boolean]" equalities nil) (wf_nat formula-decl nil naturalnumbers nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (bool nonempty-type-eq-decl nil booleans nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (boolean nonempty-type-decl nil booleans nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (measure_induction formula-decl nil measure_induction nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil)) shostak)) (contents_suffix_TCC1 0 (contents_suffix_TCC1-1 nil 3639217934 ("" (subtype-tcc) nil nil) nil nil (contents_suffix subtype "(number_fields.-)(list_props[sorting_aux.T].length(sorting_aux.l), sorting_aux.n)" "nat"))) (contents_suffix_TCC2 0 (contents_suffix_TCC2-1 nil 3639219203 ("" (subtype-tcc) (("" (rewrite "length_suffix") nil nil)) nil) ((length_suffix formula-decl nil sorting_aux nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil)) nil (contents_suffix subtype "sorting_aux.i" "below[length[T](suffix(l, n))]"))) (contents_suffix_TCC3 0 (contents_suffix_TCC3-1 nil 3639219203 ("" (subtype-tcc) nil nil) nil nil (contents_suffix subtype "(number_fields.+)(sorting_aux.i, sorting_aux.n)" "below[length[T](l)]"))) (contents_suffix 0 (contents_suffix-1 nil 3639220160 ("" (with-tccs (measure-induct+ "n" ("l" "n"))) (("1" (skeep) (("1" (typepred "x!2" "i") (("1" (expand "suffix" 1) (("1" (lift-if) (("1" (prop) (("1" (assert) nil nil) ("2" (expand "nth" 2 2) (("2" (lift-if) (("2" (prop) (("1" (assert) nil nil) ("2" (inst -3 "cdr(x!1)" "x!2 - 1") (("1" (inst -3 "i") (("1" (prop) (("1" (assert) nil nil) ("2" (assert) nil nil)) nil) ("2" (assert) (("2" (hide 3) (("2" (grind) (("2" (expand "length" -2) (("2" (grind) nil nil)) nil)) nil)) nil)) nil)) nil) ("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_suffix") (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (rewrite "length_suffix") (("3" (assert) nil nil)) nil)) nil) ("4" (skeep) (("4" (rewrite "length_suffix") (("4" (assert) nil nil)) nil)) nil) ("5" (rewrite "length_suffix") (("5" (assert) nil nil)) nil) ("6" (assert) nil nil) ("7" (assert) nil nil) ("8" (skeep) (("8" (rewrite "length_suffix") (("8" (assert) nil nil)) nil)) nil) ("9" (assert) nil nil) ("10" (rewrite "length_suffix") (("10" (assert) nil nil)) nil)) nil) ((length_suffix formula-decl nil sorting_aux nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (x!1 skolem-const-decl "list[T]" sorting_aux nil) (x!2 skolem-const-decl "below[1 + length(x!1)]" sorting_aux nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (nnint_plus_posint_is_posint application-judgement "posint" integers nil) (even_minus_odd_is_odd application-judgement "odd_int" integers nil) (int_plus_int_is_int application-judgement "int" integers nil) (i skolem-const-decl "below[length(x!1) - x!2]" sorting_aux nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (NOT const-decl "[bool -> bool]" booleans nil) (pred type-eq-decl nil defined_types nil) (well_founded? const-decl "bool" orders nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (wf_nat formula-decl nil naturalnumbers nil) (nth def-decl "T" list_props nil) (= const-decl "[T, T -> boolean]" equalities nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (bijective? const-decl "bool" functions nil) (id const-decl "(bijective?[T, T])" identity nil) (TRUE const-decl "bool" booleans nil) (suffix def-decl "list[T]" sorting_aux nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (below type-eq-decl nil nat_types nil) (length def-decl "nat" list_props nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (numfield nonempty-type-eq-decl nil number_fields nil) (< const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (>= const-decl "bool" reals nil) (int nonempty-type-eq-decl nil integers nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (rational nonempty-type-from-decl nil rationals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (real nonempty-type-from-decl nil reals nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (number_field nonempty-type-from-decl nil number_fields nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number nonempty-type-decl nil numbers nil) (list type-decl nil list_adt nil) (T formal-type-decl nil sorting_aux nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (int_minus_int_is_int application-judgement "int" integers nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak)) (contents_prefix_TCC1 0 (contents_prefix_TCC1-1 nil 3639219203 ("" (subtype-tcc) (("" (rewrite "length_prefix") nil nil)) nil) ((length_prefix formula-decl nil sorting_aux nil) (int_minus_int_is_int application-judgement "int" integers nil) (posint_plus_nnint_is_posint application-judgement "posint" integers nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (boolean nonempty-type-decl nil booleans nil) (bool nonempty-type-eq-decl nil booleans nil) (NOT const-decl "[bool -> bool]" booleans nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (< const-decl "bool" reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil)) nil (contents_prefix subtype "sorting_aux.i" "below[length[T](prefix(l, n))]"))) (contents_prefix_TCC2 0 (contents_prefix_TCC2-1 nil 3639219203 ("" (subtype-tcc) nil nil) nil nil (contents_prefix subtype "sorting_aux.i" "below[length[T](l)]"))) (contents_prefix 0 (contents_prefix-2 "" 3804612779 ("" (with-tccs (measure-induct+ "n" ("l" "n"))) (("1" (typepred "x!2") (("1" (skeep) (("1" (typepred "i") (("1" (expand "prefix" 1) (("1" (case "i=0") (("1" (replace -1) (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst? -3) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_prefix") (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (rewrite "length_prefix") (("3" (assert) nil nil)) nil)) nil) ("4" (skeep :preds? t) (("4" (typepred "x!1`2") (("4" (assert) nil nil)) nil)) nil) ("5" (typepred "x!1`2") (("5" (assert) nil nil)) nil) ("6" (rewrite "length_prefix") (("6" (assert) nil nil)) nil) ("7" (skeep :preds? t) (("7" (rewrite "length_prefix") nil nil)) nil) ("8" (typepred "x!1`2") (("8" (typepred "i!1") (("8" (assert) nil nil)) nil)) nil) ("9" (rewrite "length_prefix") (("9" (typepred "x!1`2") (("9" (assert) nil nil)) nil)) nil) ("10" (skeep :preds? t) (("10" (typepred "y!1`2") (("10" (assert) nil nil)) nil)) nil) ("11" (skeep :preds? t) (("11" (rewrite "length_prefix") nil nil)) nil)) nil) nil shostak) (contents_prefix-1 nil 3639217936 ("" (with-tccs (measure-induct+ "n" ("l" "n"))) (("1" (typepred "x!2") (("1" (skeep) (("1" (typepred "i") (("1" (expand "prefix" 1) (("1" (case "i=0") (("1" (replace -1) (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)) nil) ("2" (expand "nth" 2) (("2" (assert) (("2" (inst? -3) (("2" (prop) (("2" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ("2" (rewrite "length_prefix") (("2" (assert) nil nil)) nil) ("3" (skeep) (("3" (rewrite "length_prefix") (("3" (assert) nil nil)) nil)) nil) ("4" (skeep :preds? t) (("4" (typepred "i1") (("4" (typepred "x!1`2") (("4" (assert) nil nil)) nil)) nil)) nil) ("5" (typepred "x!1`2") (("5" (assert) nil nil)) nil) ("6" (rewrite "length_prefix") (("6" (assert) nil nil)) nil) ("7" (skeep :preds? t) (("7" (rewrite "length_prefix") nil nil)) nil) ("8" (typepred "x!1`2") (("8" (typepred "i!1") (("8" (assert) nil nil)) nil)) nil) ("9" (rewrite "length_prefix") (("9" (typepred "x!1`2") (("9" (assert) nil nil)) nil)) nil) ("10" (skeep :preds? t) (("10" (typepred "y!1`2") (("10" (assert) nil nil)) nil)) nil) ("11" (skeep :preds? t) (("11" (rewrite "length_prefix") nil nil)) nil) ("12" (assert) (("12" (rewrite "length_prefix") (("12" (typepred "n!1") (("12" (typepred "i!1") (("12" (propax) nil nil)) nil)) nil)) nil)) nil)) nil) ((posint_plus_nnint_is_posint application-judgement "posint" integers nil) (AND const-decl "[bool, bool -> bool]" booleans nil) (T formal-type-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (number nonempty-type-decl nil numbers nil) (number_field_pred const-decl "[number -> boolean]" number_fields nil) (number_field nonempty-type-from-decl nil number_fields nil) (real_pred const-decl "[number_field -> boolean]" reals nil) (real nonempty-type-from-decl nil reals nil) (rational_pred const-decl "[real -> boolean]" rationals nil) (rational nonempty-type-from-decl nil rationals nil) (integer_pred const-decl "[rational -> boolean]" integers nil) (int nonempty-type-eq-decl nil integers nil) (>= const-decl "bool" reals nil) (nat nonempty-type-eq-decl nil naturalnumbers nil) (< const-decl "bool" reals nil) (numfield nonempty-type-eq-decl nil number_fields nil) (+ const-decl "[numfield, numfield -> numfield]" number_fields nil) (length def-decl "nat" list_props nil) (below type-eq-decl nil nat_types nil) (prefix def-decl "list[T]" sorting_aux nil) (TRUE const-decl "bool" booleans nil) (id const-decl "(bijective?[T, T])" identity nil) (bijective? const-decl "bool" functions nil) (bool nonempty-type-eq-decl nil booleans nil) (boolean nonempty-type-decl nil booleans nil) (IMPLIES const-decl "[bool, bool -> bool]" booleans nil) (= const-decl "[T, T -> boolean]" equalities nil) (nth def-decl "T" list_props nil) (wf_nat formula-decl nil naturalnumbers nil) (measure_induction formula-decl nil measure_induction nil) (naturalnumber type-eq-decl nil naturalnumbers nil) (well_founded? const-decl "bool" orders nil) (pred type-eq-decl nil defined_types nil) (real_ge_is_total_order name-judgement "(total_order?[real])" real_props nil) (- const-decl "[numfield, numfield -> numfield]" number_fields nil) (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil) (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) (real_lt_is_strict_total_order name-judgement "(strict_total_order?[real])" real_props nil) (int_minus_int_is_int application-judgement "int" integers nil) (NOT const-decl "[bool -> bool]" booleans nil) (length_prefix formula-decl nil sorting_aux nil)) shostak)) (permutations_of_appends 0 (permutations_of_appends-1 nil 3639213348 ("" (skeep) (("" (expand "permutations" -) (("" (expand "permutations") (("" (skeep) (("" (inst?) (("" (inst?) (("" (rewrite "occurrences_of_app") (("" (rewrite "occurrences_of_app") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((permutations const-decl "bool" sorting_aux nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (list type-decl nil list_adt nil) (occurrences_of_app formula-decl nil sorting_aux nil) (T formal-type-decl nil sorting_aux nil)) shostak)) (permutations_of_app_suff 0 (permutations_of_app_suff-1 nil 3639213831 ("" (skeep) (("" (expand "permutations") (("" (skeep) (("" (inst?) (("" (inst?) (("" (assert) (("" (rewrite "occurrences_of_app") (("" (rewrite "occurrences_of_app") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((permutations const-decl "bool" sorting_aux nil) (T formal-type-decl nil sorting_aux nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil) (list type-decl nil list_adt nil) (occurrences_of_app formula-decl nil sorting_aux nil)) shostak)) (permutations_of_app_pref 0 (permutations_of_app_pref-1 nil 3639216066 ("" (skeep) (("" (expand "permutations") (("" (skeep) (("" (inst?) (("" (inst?) (("" (rewrite "occurrences_of_app") (("" (rewrite "occurrences_of_app") (("" (assert) nil nil)) nil)) nil)) nil)) nil)) nil)) nil)) nil) ((permutations const-decl "bool" sorting_aux nil) (T formal-type-decl nil sorting_aux nil) (occurrences_of_app formula-decl nil sorting_aux nil) (list type-decl nil list_adt nil) (nnint_plus_nnint_is_nnint application-judgement "nonneg_int" integers nil)) shostak)))
