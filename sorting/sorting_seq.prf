(|sorting_seq| (|occurrences_TCC1| 0 (|occurrences_TCC1-1| |nil| 3651245593 ("" (SUBTYPE-TCC) NIL NIL) ((|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|occurrences| SUBTYPE "0" "below[length(h)]"))) (|occurrences_TCC2| 0 (|occurrences_TCC2-1| |nil| 3651245593 ("" (SUBTYPE-TCC) NIL NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL)) NIL (|occurrences| SUBTYPE "(number_fields.-)(length(sorting_seq.h), 1)" "nat"))) (|occurrences_TCC3| 0 (|occurrences_TCC3-1| |nil| 3651245593 ("" (TERMINATION-TCC) NIL NIL) ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|empty_seq| CONST-DECL "finseq" |finite_sequences| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (^ CONST-DECL "finseq" |finite_sequences| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|occurrences| TERMINATION "sorting_seq.occurrences(finite_sequences[sorting_seq.T].^(sorting_seq.h, (1, (number_fields.-)(length(sorting_seq.h), 1))))" "NIL"))) (|occurrences_TCC4| 0 (|occurrences_TCC4-1| |nil| 3651245593 ("" (SUBTYPE-TCC) NIL NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL)) NIL (|occurrences| SUBTYPE "(number_fields.-)(length(sorting_seq.h), 1)" "nat"))) (|occurrences_TCC5| 0 (|occurrences_TCC5-1| |nil| 3651245593 ("" (TERMINATION-TCC) NIL NIL) ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|empty_seq| CONST-DECL "finseq" |finite_sequences| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (^ CONST-DECL "finseq" |finite_sequences| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|occurrences| TERMINATION "sorting_seq.occurrences(finite_sequences[sorting_seq.T].^(sorting_seq.h, (1, (number_fields.-)(length(sorting_seq.h), 1))))" "NIL"))) (|finseq2list_rec_equivalence_TCC1| 0 (|finseq2list_rec_equivalence_TCC1-1| |nil| 3651472064 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|finseq2list_rec_equivalence| SUBTYPE "(number_fields.-)(sorting_seq.h`length, 1)" "nat"))) (|finseq2list_rec_equivalence_TCC2| 0 (|finseq2list_rec_equivalence_TCC2-1| |nil| 3651472064 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (^ CONST-DECL "finseq" |finite_sequences| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|finseq2list_rec_equivalence| SUBTYPE "sorting_seq.i" "{n: naturalnumbers.nat | reals.<=(n, length(finite_sequences[sorting_seq.T].^(sorting_seq.h, (sorting_seq.k, (number_fields.-)(sorting_seq.h`length, 1)))))}"))) (|finseq2list_rec_equivalence_TCC3| 0 (|finseq2list_rec_equivalence_TCC3-1| |nil| 3651472064 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|finseq2list_rec_equivalence| SUBTYPE "sorting_seq.i" "{n: naturalnumbers.nat | reals.<=(n, length(sorting_seq.h))}"))) (|finseq2list_rec_equivalence| 0 (|finseq2list_rec_equivalence-3| "" 3884901730 ("" (SKOLEM 1 ("h" "_" "_")) (("" (INDUCT "i") (("1" (PROP) (("1" (GRIND) NIL NIL)) NIL) ("2" (SKOLEM 1 "j") (("2" (PROP) (("2" (SKEEP) (("2" (INST -2 "k") (("2" (ASSERT) (("2" (EXPAND "finseq2list_rec" 1) (("2" (EXPAND "^" 1 (1 2)) (("2" (EXPAND "min") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (HIDE 2) (("3" (EXPAND "^" 1) (("3" (EXPAND "min") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|finseq2list_rec_equivalence-2| |nil| 3652026673 ("" (SKOLEM 1 ("h" "_" "_")) (("" (INDUCT I) (("1" (PROP) (("1" (GRIND) NIL NIL)) NIL) ("2" (SKOLEM 1 "j") (("2" (PROP) (("2" (SKEEP) (("2" (INST -2 "k") (("2" (ASSERT) (("2" (EXPAND "finseq2list_rec" 1) (("2" (EXPAND "^" 1 (1 2)) (("2" (EXPAND "min") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (HIDE 2) (("3" (EXPAND "^" 1) (("3" (EXPAND "min") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|finseq2list_rec| DEF-DECL "list[T]" |list2finseq| NIL) (^ CONST-DECL "finseq" |finite_sequences| NIL) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (<= CONST-DECL "bool" |reals| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|h| SKOLEM-CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (< CONST-DECL "bool" |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below_induction| FORMULA-DECL NIL |bounded_nat_inductions| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL)) NIL) (|finseq2list_rec_equivalence-1| |nil| 3651472068 ("" (SKOLEM 1 ("h" "_" "_")) (("" (INDUCT I) (("1" (PROP) (("1" (GRIND) NIL NIL)) NIL) ("2" (SKOLEM 1 J) (("2" (PROP) (("2" (SKEEP) (("2" (INST -2 "k") (("2" (ASSERT) (("2" (EXPAND "finseq2list_rec" 1) (("2" (EXPAND "^" 1 (1 2)) (("2" (EXPAND "min") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (HIDE 2) (("3" (EXPAND ^ 1) (("3" (EXPAND "min") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|finseq2lists_for_suffixes_TCC1| 0 (|finseq2lists_for_suffixes_TCC1-1| |nil| 3651415934 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|finseq2lists_for_suffixes| SUBTYPE "(number_fields.-)(length(sorting_seq.h), 1)" "nat"))) (|finseq2lists_for_suffixes_TCC2| 0 (|finseq2lists_for_suffixes_TCC2-1| |nil| 3651415934 ("" (SUBTYPE-TCC) NIL NIL) ((|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (^ CONST-DECL "finseq" |finite_sequences| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|finseq2lists_for_suffixes| SUBTYPE "(number_fields.-)(length(sorting_seq.h), sorting_seq.i)" "{n: naturalnumbers.nat | reals.<=(n, length(finite_sequences[sorting_seq.T].^(sorting_seq.h, (sorting_seq.i, (number_fields.-)(length(sorting_seq.h), 1)))))}"))) (|finseq2lists_for_suffixes_TCC3| 0 (|finseq2lists_for_suffixes_TCC3-1| |nil| 3651415934 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|finseq2lists_for_suffixes| SUBTYPE "(number_fields.-)(length(sorting_seq.h), sorting_seq.i)" "{n: naturalnumbers.nat | reals.<=(n, length(sorting_seq.h))}"))) (|finseq2lists_for_suffixes| 0 (|finseq2lists_for_suffixes-2| |nil| 3652026727 ("" (SKOLEM 1 ("h" "_")) (("" (INDUCT "i") (("1" (FLATTEN) (("1" (ASSERT) (("1" (CASE "h ^ (0, length(h) - 1) = h") (("1" (ASSERT) NIL NIL) ("2" (HIDE 2) (("2" (EXPAND "^") (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (GRIND) NIL NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "finseq2list_rec_equivalence") (("2" (INST -1 "h" "length(h) - (jb + 1)" "jb+1") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ((|below| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|finseq2list_rec| DEF-DECL "list[T]" |list2finseq| NIL) (^ CONST-DECL "finseq" |finite_sequences| NIL) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (<= CONST-DECL "bool" |reals| NIL) (|h| SKOLEM-CONST-DECL "{h | length(h) > 0}" |sorting_seq| NIL) (< CONST-DECL "bool" |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (> CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below_induction| FORMULA-DECL NIL |bounded_nat_inductions| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nat_min| APPLICATION-JUDGEMENT "{k: nat | k <= i AND k <= j}" |real_defs| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|finseq2list_rec_equivalence| FORMULA-DECL NIL |sorting_seq| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|jb| SKOLEM-CONST-DECL "below(length(h))" |sorting_seq| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL)) NIL) (|finseq2lists_for_suffixes-1| |nil| 3651416609 ("" (SKOLEM 1 ("h" "_")) (("" (INDUCT "i") (("1" (FLATTEN) (("1" (ASSERT) (("1" (CASE "h ^ (0, length(h) - 1) = h") (("1" (ASSERT) NIL NIL) ("2" (HIDE 2) (("2" (EXPAND "^") (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (GRIND) NIL NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (LEMMA "finseq2list_rec_equivalence") (("2" (INST -1 "h" "length(h) - (jb + 1)" "jb+1") (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE 2) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|subseq_is_cdr_TCC1| 0 (|subseq_is_cdr_TCC1-1| |nil| 3651379346 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|subseq_is_cdr| SUBTYPE "(number_fields.-)(length(sorting_seq.h), 1)" "nat"))) (|subseq_is_cdr_TCC2| 0 (|subseq_is_cdr_TCC2-1| |nil| 3651379346 ("" (SKEEP) (("" (TYPEPRED "h") (("" (GRIND) NIL NIL)) NIL)) NIL) ((|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (> CONST-DECL "bool" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|finseq2list_rec| DEF-DECL "list[T]" |list2finseq| NIL) (|finseq2list| CONST-DECL "list[T]" |list2finseq| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL)) NIL (|subseq_is_cdr| SUBTYPE "list2finseq[sorting_seq.T].finseq2list(sorting_seq.h)" "(list_adt[sorting_seq.T].cons?)"))) (|subseq_is_cdr| 0 (|subseq_is_cdr-2| |nil| 3652026777 ("" (SKEEP) (("" (EXPAND "finseq2list") (("" (EXPAND "finseq2list_rec" 1 2) (("" (EXPAND "^" 1 2) (("" (LIFT-IF) (("" (PROP) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (EXPAND "min") (("3" (LEMMA "finseq2lists_for_suffixes") (("3" (INST -1 "h" "1") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|finseq2list| CONST-DECL "list[T]" |list2finseq| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (^ CONST-DECL "finseq" |finite_sequences| NIL) (|empty_seq| CONST-DECL "finseq" |finite_sequences| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_min| APPLICATION-JUDGEMENT "{k: int | k <= i AND k <= j}" |real_defs| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|finseq2lists_for_suffixes| FORMULA-DECL NIL |sorting_seq| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (< CONST-DECL "bool" |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (> CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|h| SKOLEM-CONST-DECL "{h | length(h) > 0}" |sorting_seq| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (|finseq2list_rec| DEF-DECL "list[T]" |list2finseq| NIL)) NIL) (|subseq_is_cdr-1| |nil| 3651411775 ("" (SKEEP) (("" (EXPAND "finseq2list") (("" (EXPAND "finseq2list_rec" 1 2) (("" (EXPAND "^" 1 2) (("" (LIFT-IF) (("" (PROP) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (EXPAND "min") (("3" (LEMMA "finseq2lists_for_suffixes") (("3" (INST -1 "h" "1") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|same_occ_fseq_list| 0 (|same_occ_fseq_list-4| |nil| 3652453907 ("" (MEASURE-INDUCT+ "length(h)" ("h")) (("" (SKEEP) (("" (EXPAND "occurrences" 1 1) (("" (LIFT-IF) (("" (PROP) (("1" (HIDE -2) (("1" (GRIND) NIL))) ("2" (EXPAND "occurrences" 1 2) (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE -3) (("1" (GRIND) NIL))) ("2" (INST -3 "x!1 ^ (1, length(x!1) - 1)") (("1" (INST -3 "x") (("1" (PROP) (("1" (REWRITE "subseq_is_cdr") (("1" (ASSERT) NIL))) ("2" (HIDE-ALL-BUT (1 4)) (("2" (GRIND) NIL))))))) ("2" (HIDE-ALL-BUT (1 4)) (("2" (GRIND) NIL))))) ("3" (HIDE -2 2) (("3" (GRIND) NIL))))))))) ("3" (EXPAND "occurrences" 2 2) (("3" (LIFT-IF) (("3" (PROP) (("1" (HIDE-ALL-BUT (-1 3)) (("1" (GRIND) NIL))) ("2" (HIDE-ALL-BUT (-1 3 4)) (("2" (GRIND) NIL))) ("3" (INST -1 "x!1 ^ (1, length(x!1) - 1)") (("1" (INST -1 "x") (("1" (PROP) (("1" (REWRITE "subseq_is_cdr") NIL) ("2" (HIDE-ALL-BUT (1 6)) (("2" (GRIND) NIL))))))) ("2" (HIDE-ALL-BUT (1 6)) (("2" (GRIND) NIL)))))))))))))))))))) NIL) ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_min| APPLICATION-JUDGEMENT "{k: int | k <= i AND k <= j}" |real_defs| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (^ CONST-DECL "finseq" |finite_sequences| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (|empty_seq| CONST-DECL "finseq" |finite_sequences| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|subseq_is_cdr| FORMULA-DECL NIL |sorting_seq| NIL) (> CONST-DECL "bool" |reals| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|x!1| SKOLEM-CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (|finseq2list_rec| DEF-DECL "list[T]" |list2finseq| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|occurrences| DEF-DECL "nat" |sorting_seq| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|occurrences| DEF-DECL "nat" |sorting_aux| NIL) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|finseq2list| CONST-DECL "list[T]" |list2finseq| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)) NIL) (|same_occ_fseq_list-3| |nil| 3652453048 ("" (MEASURE-INDUCT+ "length(h)" ("h")) (("" (SKEEP) (("" (EXPAND "occurrences" 1 1) (("" (LIFT-IF) (("" (PROP) (("1" (HIDE -2) (("1" (GRIND) NIL))) ("2" (EXPAND "occurrences" 1 2) (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE -3) (("1" (GRIND) NIL))) ("2" (INST -3 "x!1 ^ (1, length(x!1) - 1)") (("1" (INST -3 "x") (("1" (PROP) (("1" (REWRITE "subseq_is_cdr") (("1" (ASSERT) NIL))) ("2" (HIDE-ALL-BUT (1 4)) (("2" (GRIND) NIL))))))) ("2" (HIDE-ALL-BUT (1 4)) (("2" (GRIND) NIL))))) ("3" (HIDE -2 2) (("3" (GRIND) NIL))))))))) ("3" (EXPAND "occurrences" 2 2) (("3" (LIFT-IF) (("3" (PROP) (("1" (HIDE-ALL-BUT (-1 3)) (("1" (GRIND) NIL))) ("2" (HIDE-ALL-BUT (-1 3 4)) (("2" (GRIND) NIL))) ("3" (INST -1 "x!1 ^ (1, length(x!1) - 1)") (("1" (INST -1 "x") (("1" (PROP) (("1" (REWRITE "subseq_is_cdr") NIL) ("2" (HIDE-ALL-BUT (1 6)) (("2" (GRIND) NIL))))))) ("2" (HIDE-ALL-BUT (1 6)) (("2" (GRIND) NIL)))))))))))))))))))) NIL) NIL NIL) (|same_occ_fseq_list-2| |nil| 3652111906 ("" (MEASURE-INDUCT+ "length(h)" ("h")) (("" (SKEEP) (("" (EXPAND "occurrences" 1 1) (("" (LIFT-IF) (("" (PROP) (("1" (HIDE -2) (("1" (GRIND) NIL NIL)) NIL) ("2" (EXPAND "occurrences" 1 2) (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE -3) (("1" (GRIND) NIL NIL)) NIL) ("2" (INST -3 "x!1 ^ (1, length(x!1) - 1)") (("1" (INST -3 "x") (("1" (PROP) (("1" (REWRITE "subseq_is_cdr") (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT (1 4)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 4)) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (HIDE -2 2) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "occurrences" 2 2) (("3" (LIFT-IF) (("3" (PROP) (("1" (HIDE-ALL-BUT (-1 3)) (("1" (GRIND) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 3 4)) (("2" (GRIND) NIL NIL)) NIL) ("3" (INST -1 "x!1 ^ (1, length(x!1) - 1)") (("1" (INST -1 "x") (("1" (PROP) (("1" (REWRITE "subseq_is_cdr") NIL NIL) ("2" (HIDE-ALL-BUT (1 6)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 6)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL) (|same_occ_fseq_list-1| |nil| 3651245600 ("" (MEASURE-INDUCT+ "length(h)" ("h")) (("" (SKEEP) (("" (EXPAND "occurrences" 1 1) (("" (LIFT-IF) (("" (PROP) (("1" (HIDE -2) (("1" (GRIND) NIL NIL)) NIL) ("2" (EXPAND "occurrences" 1) (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE -3) (("1" (GRIND) NIL NIL)) NIL) ("2" (INST -3 "x!1 ^ (1, length(x!1) - 1)") (("1" (INST -3 "x") (("1" (PROP) (("1" (REWRITE "subseq_is_cdr") (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT (1 4)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 4)) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (HIDE -2 2) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "occurrences" 2) (("3" (LIFT-IF) (("3" (PROP) (("1" (HIDE-ALL-BUT (-1 3)) (("1" (GRIND) NIL NIL)) NIL) ("2" (HIDE-ALL-BUT (-1 3 4)) (("2" (GRIND) NIL NIL)) NIL) ("3" (INST -1 "x!1 ^ (1, length(x!1) - 1)") (("1" (INST -1 "x") (("1" (PROP) (("1" (REWRITE "subseq_is_cdr") NIL NIL) ("2" (HIDE-ALL-BUT (1 6)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 6)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|perm_fsq_iff_perm_list| 0 (|perm_fsq_iff_perm_list-1| |nil| 3651503041 ("" (SKEEP) (("" (SPLIT) (("1" (FLATTEN) (("1" (EXPAND "permutations" 1) (("1" (EXPAND "permutations") (("1" (LEMMA "same_occ_fseq_list") (("1" (LEMMA "same_occ_fseq_list") (("1" (SKEEP) (("1" (INST?) (("1" (INST -2 "h2" "x") (("1" (INST?) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (FLATTEN) (("2" (EXPAND "permutations") (("2" (SKEEP) (("2" (INST?) (("2" (LEMMA "same_occ_fseq_list") (("2" (LEMMA "same_occ_fseq_list") (("2" (INST?) (("2" (INST -2 "h2" "x") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|permutations| CONST-DECL "bool" |sorting_aux| NIL) (|same_occ_fseq_list| FORMULA-DECL NIL |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|permutations| CONST-DECL "bool" |sorting_seq| NIL)) SHOSTAK)) (|permutations_equiv| 0 (|permutations_equiv-1| |nil| 3651505343 ("" (SPLIT) (("1" (EXPAND "reflexive?") (("1" (SKEEP) (("1" (EXPAND "permutations") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "symmetric?") (("2" (SKEEP) (("2" (EXPAND "permutations") (("2" (SKEEP) (("2" (INST?) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "transitive?") (("3" (SKEEP) (("3" (LEMMA "permutations_is_transitive") (("3" (LEMMA "perm_fsq_iff_perm_list") (("3" (COPY -1) (("3" (COPY -1) (("3" (INST?) (("3" (INST -2 "y" "z") (("3" (INST -3 "x" "z") (("3" (INST -4 "finseq2list(x)" "finseq2list(y)" "finseq2list(z)") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|transitive?| CONST-DECL "bool" |relations| NIL) (|permutations_is_transitive| FORMULA-DECL NIL |sorting_aux| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|finseq2list| CONST-DECL "list[T]" |list2finseq| NIL) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|list| TYPE-DECL NIL |list_adt| NIL) (|perm_fsq_iff_perm_list| FORMULA-DECL NIL |sorting_seq| NIL) (|symmetric?| CONST-DECL "bool" |relations| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|reflexive?| CONST-DECL "bool" |relations| NIL) (|permutations| CONST-DECL "bool" |sorting_seq| NIL)) SHOSTAK)) (|psorted_TCC1| 0 (|psorted_TCC1-1| |nil| 3651167506 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (<= CONST-DECL "bool" |reals| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|psorted| SUBTYPE "(number_fields.+)(sorting_seq.k, 1)" "below[length(h)]"))) (|is_sorted?_TCC1| 0 (|is_sorted?_TCC1-1| |nil| 3797620238 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL)) NIL (|is_sorted?| SUBTYPE "(number_fields.+)(sorting_seq.k, 1)" "below[length(h)]"))) (|is_sorted_equiv| 0 (|is_sorted_equiv-2| |nil| 3797759809 ("" (AUTO-REWRITE "finseq_appl") (("" (SKEEP) (("" (PROP) (("1" (MEASURE-INDUCT+ "j-i" ("i" "j")) (("1" (ASSERT) (("1" (CASE-REPLACE "x!1 = x!2") (("1" (TYPEPRED "leq") (("1" (GRIND) NIL NIL)) NIL) ("2" (INST -1 "x!1+1" "x!2") (("1" (PROP) (("1" (EXPAND "is_sorted?") (("1" (INST -2 "x!1") (("1" (TYPEPRED "leq") (("1" (PROP) (("1" (EXPAND "finseq_appl") (("1" (EXPAND "total_preorder?") (("1" (FLATTEN) (("1" (EXPAND "preorder?") (("1" (FLATTEN) (("1" (EXPAND "transitive?") (("1" (INST -3 "h`seq(x!1)" "h`seq(1 + x!1)" "h`seq(x!2)") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "x!1") (("2" (TYPEPRED "x!2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "is_sorted?") (("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "is_sorted?") (("2" (SKEEP) (("2" (ASSERT) (("2" (INST -1 "k" "k+1") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (<= CONST-DECL "bool" |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|total_preorder?| CONST-DECL "bool" |total_preorder| NIL) (|leq| FORMAL-CONST-DECL "(total_preorder?[T])" |sorting_seq| NIL) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|is_sorted?| CONST-DECL "bool" |sorting_seq| NIL) (|dichotomous?| CONST-DECL "bool" |orders| NIL) (|preorder?| CONST-DECL "bool" |orders| NIL) (|transitive?| CONST-DECL "bool" |relations| NIL) (|reflexive?| CONST-DECL "bool" |relations| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|x!2| SKOLEM-CONST-DECL "{j: below[length(h)] | x!1 <= j}" |sorting_seq| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|h| SKOLEM-CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (|x!1| SKOLEM-CONST-DECL "below[length(h)]" |sorting_seq| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL)) NIL) (|is_sorted_equiv-1| |nil| 3797620676 ("" (AUTO-REWRITE "finseq_appl") (("" (SKEEP) (("" (PROP) (("1" (MEASURE-INDUCT+ "j-i" ("i" "j")) (("1" (ASSERT) (("1" (CASE-REPLACE "x!1 = x!2") (("1" (TYPEPRED "<=") (("1" (GRIND) NIL NIL)) NIL) ("2" (INST -1 "x!1+1" "x!2") (("1" (PROP) (("1" (EXPAND "is_sorted?") (("1" (INST -2 "x!1") (("1" (TYPEPRED "<=") (("1" (PROP) (("1" (EXPAND "finseq_appl") (("1" (EXPAND "total_preorder?") (("1" (FLATTEN) (("1" (EXPAND "preorder?") (("1" (FLATTEN) (("1" (EXPAND "transitive?") (("1" (INST -3 "h`seq(x!1)" "h`seq(1 + x!1)" "h`seq(x!2)") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (TYPEPRED "x!1") (("2" (TYPEPRED "x!2") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "is_sorted?") (("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "is_sorted?") (("2" (SKEEP) (("2" (ASSERT) (("2" (INST -1 "k" "k+1") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL)) (|ind_parent_TCC1| 0 (|ind_parent_TCC1-1| |nil| 3651167506 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|ind_parent| SUBTYPE "floor_ceil.floor(number_fields./(((number_fields.-)(sorting_seq.k, 1)), 2))" "nat"))) (|left_child_TCC1| 0 (|left_child_TCC1-1| |nil| 3651167506 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|even_plus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|ind_lc| CONST-DECL "nat" |sorting_seq| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL)) NIL (|left_child| SUBTYPE "sorting_seq.ind_lc(sorting_seq.i)" "below[length(h)]"))) (|right_child_TCC1| 0 (|right_child_TCC1-1| |nil| 3651167506 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|even_plus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|ind_rc| CONST-DECL "nat" |sorting_seq| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL)) NIL (|right_child| SUBTYPE "sorting_seq.ind_rc(sorting_seq.i)" "below[length(h)]"))) (|is_p_heap_TCC1| 0 (|is_p_heap_TCC1-1| |nil| 3651243919 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|is_p_heap| SUBTYPE "(number_fields.-)(length(sorting_seq.h), 1)" "nat"))) (|is_p_heap_TCC2| 0 (|is_p_heap_TCC2-1| |nil| 3651243919 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|is_p_heap| SUBTYPE "sorting_seq.k" "{i: nat_types[length(sorting_seq.h)].below | reals.<=(i, sorting_seq.j)}"))) (|is_p_heap_TCC3| 0 (|is_p_heap_TCC3-1| |nil| 3651243919 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (<= CONST-DECL "bool" |reals| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|even_plus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|ind_lc| CONST-DECL "nat" |sorting_seq| NIL) (|is_parent| CONST-DECL "bool" |sorting_seq| NIL) (|one_child| CONST-DECL "bool" |sorting_seq| NIL) (|both_childs| CONST-DECL "bool" |sorting_seq| NIL) (|ind_rc| CONST-DECL "nat" |sorting_seq| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL)) NIL (|is_p_heap| SUBTYPE "sorting_seq.k" "{i: naturalnumbers.nat | reals.<(sorting_seq.ind_lc(i), length(sorting_seq.h))}"))) (|is_p_heap_TCC4| 0 (|is_p_heap_TCC4-1| |nil| 3651243919 ("" (SUBTYPE-TCC) NIL NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (<= CONST-DECL "bool" |reals| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|even_plus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|converse| CONST-DECL "pred[[T2, T1]]" |relation_defs| NIL) (|left_child| CONST-DECL "T" |sorting_seq| NIL) (|ind_lc| CONST-DECL "nat" |sorting_seq| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|geq| CONST-DECL "pred[[T, T]]" |sorting| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|total_preorder?| CONST-DECL "bool" |total_preorder| NIL) (|leq| FORMAL-CONST-DECL "(total_preorder?[T])" |sorting_seq| NIL) (|is_parent| CONST-DECL "bool" |sorting_seq| NIL) (|one_child| CONST-DECL "bool" |sorting_seq| NIL) (|both_childs| CONST-DECL "bool" |sorting_seq| NIL) (|ind_rc| CONST-DECL "nat" |sorting_seq| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL)) NIL (|is_p_heap| SUBTYPE "sorting_seq.k" "{i: naturalnumbers.nat | reals.<(sorting_seq.ind_rc(i), length(sorting_seq.h))}"))) (|is_p_heap_TCC5| 0 (|is_p_heap_TCC5-1| |nil| 3651243919 ("" (SUBTYPE-TCC) NIL NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (<= CONST-DECL "bool" |reals| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|even_plus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|right_child| CONST-DECL "T" |sorting_seq| NIL) (|converse| CONST-DECL "pred[[T2, T1]]" |relation_defs| NIL) (|left_child| CONST-DECL "T" |sorting_seq| NIL) (|ind_lc| CONST-DECL "nat" |sorting_seq| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|geq| CONST-DECL "pred[[T, T]]" |sorting| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|total_preorder?| CONST-DECL "bool" |total_preorder| NIL) (|leq| FORMAL-CONST-DECL "(total_preorder?[T])" |sorting_seq| NIL) (|is_parent| CONST-DECL "bool" |sorting_seq| NIL) (|one_child| CONST-DECL "bool" |sorting_seq| NIL) (|both_childs| CONST-DECL "bool" |sorting_seq| NIL) (|ind_rc| CONST-DECL "nat" |sorting_seq| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL)) NIL (|is_p_heap| SUBTYPE "sorting_seq.k" "{i: naturalnumbers.nat | reals.<(sorting_seq.ind_lc(i), length(sorting_seq.h))}"))) (|is_heap_TCC1| 0 (|is_heap_TCC1-1| |nil| 3797689628 ("" (SUBTYPE-TCC) NIL NIL) ((|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|is_heap| SUBTYPE "0" "below[length(h)]"))) (|is_heap_TCC2| 0 (|is_heap_TCC2-1| |nil| 3797689628 ("" (SUBTYPE-TCC) NIL NIL) ((|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|is_heap| SUBTYPE "(number_fields.-)(length(sorting_seq.h), 1)" "{j: nat_types[length(sorting_seq.h)].below | reals.<=(0, j)}"))) (|root_is_greatest_in_p_heap_TCC1| 0 (|root_is_greatest_in_p_heap_TCC1-1| |nil| 3651945337 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|root_is_greatest_in_p_heap| SUBTYPE "0" "below[length(h)]"))) (|root_is_greatest_in_p_heap_TCC2| 0 (|root_is_greatest_in_p_heap_TCC2-1| |nil| 3651945337 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|root_is_greatest_in_p_heap| SUBTYPE "sorting_seq.n" "{j: nat_types[length(sorting_seq.h)].below | reals.<=(0, j)}"))) (|root_is_greatest_in_p_heap_TCC3| 0 (|root_is_greatest_in_p_heap_TCC3-1| |nil| 3651945337 ("" (SUBTYPE-TCC) NIL NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|is_p_heap| CONST-DECL "bool" |sorting_seq| NIL) (|right_child| CONST-DECL "T" |sorting_seq| NIL) (|converse| CONST-DECL "pred[[T2, T1]]" |relation_defs| NIL) (|left_child| CONST-DECL "T" |sorting_seq| NIL) (|ind_lc| CONST-DECL "nat" |sorting_seq| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|geq| CONST-DECL "pred[[T, T]]" |sorting| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|total_preorder?| CONST-DECL "bool" |total_preorder| NIL) (|leq| FORMAL-CONST-DECL "(total_preorder?[T])" |sorting_seq| NIL) (|is_parent| CONST-DECL "bool" |sorting_seq| NIL) (|one_child| CONST-DECL "bool" |sorting_seq| NIL) (|both_childs| CONST-DECL "bool" |sorting_seq| NIL) (|ind_rc| CONST-DECL "nat" |sorting_seq| NIL)) NIL (|root_is_greatest_in_p_heap| SUBTYPE "sorting_seq.i" "below[length(h)]"))) (|root_is_greatest_in_p_heap| 0 (|root_is_greatest_in_p_heap-4| |nil| 3797759953 ("" (AUTO-REWRITE "finseq_appl") (("" (SKOLEM 1 ("h" "n" "_")) (("" (MEASURE-INDUCT+ "i" ("i")) (("" (CASE "x!1 = 0") (("1" (HIDE -2 -3) (("1" (GRIND) (("1" (TYPEPRED "leq") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (INST -1 "ind_parent(x!1)") (("1" (PROP) (("1" (EXPAND "is_p_heap") (("1" (EXPAND "finseq_appl") (("1" (INST -2 "ind_parent(x!1)") (("1" (PROP) (("1" (EXPAND "ind_parent") (("1" (EXPAND "left_child") (("1" (EXPAND "right_child") (("1" (EXPAND "finseq_appl") (("1" (EXPAND "ind_lc") (("1" (EXPAND "ind_rc") (("1" (CASE "x!1 = 1 + 2 * floor((x!1 - 1) / 2) OR x!1 = 2 + 2 * floor((x!1 - 1) / 2)") (("1" (SPLIT) (("1" (REPLACE -1 -3 RL) (("1" (HIDE -1 -2 -4) (("1" (EXPAND "geq") (("1" (EXPAND "converse") (("1" (TYPEPRED "leq") (("1" (EXPAND "total_preorder?") (("1" (FLATTEN) (("1" (EXPAND "preorder?") (("1" (FLATTEN) (("1" (EXPAND "transitive?") (("1" (INST -2 "h`seq(x!1)" "h`seq(floor((x!1 - 1) / 2))" "h`seq(0)") (("1" (ASSERT) NIL NIL) ("2" (HIDE -) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -1 -4 RL) (("2" (HIDE -1 -2 -3) (("2" (TYPEPRED "leq") (("2" (EXPAND "total_preorder?") (("2" (FLATTEN) (("2" (EXPAND "preorder?") (("2" (FLATTEN) (("2" (EXPAND "transitive?") (("2" (EXPAND "geq") (("2" (EXPAND "converse") (("2" (INST -2 "h`seq(x!1)" "h`seq(floor((x!1 - 1) / 2))" "h`seq(0)") (("1" (ASSERT) NIL NIL) ("2" (HIDE -) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE - 3) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "ind_parent") (("2" (EXPAND "left_child") (("2" (EXPAND "ind_lc") (("2" (EXPAND "finseq_appl") (("2" (TYPEPRED "leq") (("2" (EXPAND "total_preorder?") (("2" (FLATTEN) (("2" (EXPAND "preorder?") (("2" (FLATTEN) (("2" (HIDE -1) (("2" (EXPAND "transitive?") (("2" (EXPAND "geq") (("2" (EXPAND "converse") (("2" (CASE "1 + 2 * floor((x!1 - 1) / 2) = x!1") (("1" (REPLACES -1) (("1" (INST -1 "h`seq(x!1)" "h`seq(floor((x!1 - 1) / 2))" "h`seq(0)") (("1" (ASSERT) NIL NIL) ("2" (HIDE -) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "ind_parent") (("3" (EXPAND "is_parent") (("3" (EXPAND "both_childs") (("3" (EXPAND "one_child") (("3" (EXPAND "ind_rc") (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE -1 3) (("4" (EXPAND "ind_parent") (("4" (TYPEPRED "x!1") (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE -1 3) (("2" (EXPAND "ind_parent") (("2" (TYPEPRED "x!1" "n") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE -1 3) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|converse| CONST-DECL "pred[[T2, T1]]" |relation_defs| NIL) (|dichotomous_converse| APPLICATION-JUDGEMENT "(dichotomous?[T])" |relation_converse_props| NIL) (|preorder_converse| APPLICATION-JUDGEMENT "(preorder?[T])" |relation_converse_props| NIL) (|dichotomous?| CONST-DECL "bool" |orders| NIL) (|preorder?| CONST-DECL "bool" |orders| NIL) (|transitive?| CONST-DECL "bool" |relations| NIL) (|reflexive?| CONST-DECL "bool" |relations| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|left_child| CONST-DECL "T" |sorting_seq| NIL) (|ind_rc| CONST-DECL "nat" |sorting_seq| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (OR CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (* CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|integer| NONEMPTY-TYPE-FROM-DECL NIL |integers| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|floor| CONST-DECL "{i | i <= x & x < i + 1}" |floor_ceil| NIL) (/= CONST-DECL "boolean" |notequal| NIL) (|nznum| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (/ CONST-DECL "[numfield, nznum -> numfield]" |number_fields| NIL) (|even_plus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|ind_lc| CONST-DECL "nat" |sorting_seq| NIL) (|right_child| CONST-DECL "T" |sorting_seq| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|one_child| CONST-DECL "bool" |sorting_seq| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|is_parent| CONST-DECL "bool" |sorting_seq| NIL) (|both_childs| CONST-DECL "bool" |sorting_seq| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|ind_parent| CONST-DECL "nat" |sorting_seq| NIL) (> CONST-DECL "bool" |reals| NIL) (|h| SKOLEM-CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (|n| SKOLEM-CONST-DECL "below[length(h)]" |sorting_seq| NIL) (|x!1| SKOLEM-CONST-DECL "below[1 + n]" |sorting_seq| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|geq| CONST-DECL "pred[[T, T]]" |sorting| NIL) (|leq| FORMAL-CONST-DECL "(total_preorder?[T])" |sorting_seq| NIL) (|total_preorder?| CONST-DECL "bool" |total_preorder| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|is_p_heap| CONST-DECL "bool" |sorting_seq| NIL) (<= CONST-DECL "bool" |reals| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)) NIL) (|root_is_greatest_in_p_heap-3| |nil| 3797759890 ("" (AUTO-REWRITE "finseq_appl") (("" (SKOLEM 1 ("h" "n" "_")) (("" (MEASURE-INDUCT+ "i" ("i")) (("" (CASE "x!1 = 0") (("1" (HIDE -2 -3) (("1" (GRIND) (("1" (TYPEPRED "<=") (("1" (GRIND) NIL))))))) ("2" (INST -1 "ind_parent(x!1)") (("1" (PROP) (("1" (EXPAND "is_p_heap") (("1" (EXPAND "finseq_appl") (("1" (INST -2 "ind_parent(x!1)") (("1" (PROP) (("1" (EXPAND "ind_parent") (("1" (EXPAND "left_child") (("1" (EXPAND "right_child") (("1" (EXPAND "finseq_appl") (("1" (EXPAND "ind_lc") (("1" (EXPAND "ind_rc") (("1" (CASE "x!1 = 1 + 2 * floor((x!1 - 1) / 2) OR x!1 = 2 + 2 * floor((x!1 - 1) / 2)") (("1" (SPLIT) (("1" (REPLACE -1 -3 RL) (("1" (HIDE -1 -2 -4) (("1" (EXPAND "geq") (("1" (EXPAND "converse") (("1" (TYPEPRED "leq") (("1" (EXPAND "total_preorder?") (("1" (FLATTEN) (("1" (EXPAND "preorder?") (("1" (FLATTEN) (("1" (EXPAND "transitive?") (("1" (INST -2 "h`seq(x!1)" "h`seq(floor((x!1 - 1) / 2))" "h`seq(0)") (("1" (ASSERT) NIL) ("2" (HIDE -) (("2" (GRIND) NIL))))))))))))))))))))))))) ("2" (REPLACE -1 -4 RL) (("2" (HIDE -1 -2 -3) (("2" (TYPEPRED "leq") (("2" (EXPAND "total_preorder?") (("2" (FLATTEN) (("2" (EXPAND "preorder?") (("2" (FLATTEN) (("2" (EXPAND "transitive?") (("2" (EXPAND "geq") (("2" (EXPAND "converse") (("2" (INST -2 "h`seq(x!1)" "h`seq(floor((x!1 - 1) / 2))" "h`seq(0)") (("1" (ASSERT) NIL) ("2" (HIDE -) (("2" (GRIND) NIL))))))))))))))))))))))))))) ("2" (HIDE - 3) (("2" (GRIND) NIL))))))))))))))))) ("2" (EXPAND "ind_parent") (("2" (EXPAND "left_child") (("2" (EXPAND "ind_lc") (("2" (EXPAND "finseq_appl") (("2" (TYPEPRED "leq") (("2" (EXPAND "total_preorder?") (("2" (FLATTEN) (("2" (EXPAND "preorder?") (("2" (FLATTEN) (("2" (HIDE -1) (("2" (EXPAND "transitive?") (("2" (EXPAND "geq") (("2" (EXPAND "converse") (("2" (CASE "1 + 2 * floor((x!1 - 1) / 2) = x!1") (("1" (REPLACES -1) (("1" (INST -1 "h`seq(x!1)" "h`seq(floor((x!1 - 1) / 2))" "h`seq(0)") (("1" (ASSERT) NIL) ("2" (HIDE -) (("2" (GRIND) NIL))))))) ("2" (GRIND) NIL))))))))))))))))))))))))))))) ("3" (EXPAND "ind_parent") (("3" (EXPAND "is_parent") (("3" (EXPAND "both_childs") (("3" (EXPAND "one_child") (("3" (EXPAND "ind_rc") (("3" (GRIND) NIL))))))))))) ("4" (HIDE -1 3) (("4" (EXPAND "ind_parent") (("4" (TYPEPRED "x!1") (("4" (GRIND) NIL))))))))) ("2" (HIDE -1 3) (("2" (EXPAND "ind_parent") (("2" (TYPEPRED "x!1" "n") (("2" (GRIND) NIL))))))))))))) ("2" (HIDE -1 3) (("2" (GRIND) NIL))))) ("2" (HIDE 2) (("2" (GRIND) NIL))) ("3" (ASSERT) NIL)))))))))) NIL) NIL NIL) (|root_is_greatest_in_p_heap-2| |nil| 3652719850 ("" (AUTO-REWRITE "finseq_appl") (("" (SKOLEM 1 ("h" "n" "_")) (("" (MEASURE-INDUCT+ "i" ("i")) (("" (CASE "x!1 = 0") (("1" (HIDE -2 -3) (("1" (GRIND) (("1" (TYPEPRED "<=") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (INST -1 "ind_parent(x!1)") (("1" (PROP) (("1" (EXPAND "is_p_heap") (("1" (EXPAND "finseq_appl") (("1" (INST -2 "ind_parent(x!1)") (("1" (PROP) (("1" (EXPAND "ind_parent") (("1" (EXPAND "left_child") (("1" (EXPAND "right_child") (("1" (EXPAND "finseq_appl") (("1" (EXPAND "ind_lc") (("1" (EXPAND "ind_rc") (("1" (CASE "x!1 = 1 + 2 * floor((x!1 - 1) / 2) OR x!1 = 2 + 2 * floor((x!1 - 1) / 2)") (("1" (SPLIT) (("1" (REPLACE -1 -3 RL) (("1" (HIDE -1 -2 -4) (("1" (EXPAND ">=") (("1" (EXPAND "converse") (("1" (TYPEPRED "<=") (("1" (EXPAND "total_preorder?") (("1" (FLATTEN) (("1" (EXPAND "preorder?") (("1" (FLATTEN) (("1" (EXPAND "transitive?") (("1" (INST -2 "h`seq(x!1)" "h`seq(floor((x!1 - 1) / 2))" "h`seq(0)") (("1" (ASSERT) NIL NIL) ("2" (HIDE -) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACE -1 -4 RL) (("2" (HIDE -1 -2 -3) (("2" (TYPEPRED "<=") (("2" (EXPAND "total_preorder?") (("2" (FLATTEN) (("2" (EXPAND "preorder?") (("2" (FLATTEN) (("2" (EXPAND "transitive?") (("2" (EXPAND ">=") (("2" (EXPAND "converse") (("2" (INST -2 "h`seq(x!1)" "h`seq(floor((x!1 - 1) / 2))" "h`seq(0)") (("1" (ASSERT) NIL NIL) ("2" (HIDE -) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE - 3) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "ind_parent") (("2" (EXPAND "left_child") (("2" (EXPAND "ind_lc") (("2" (EXPAND "finseq_appl") (("2" (TYPEPRED "<=") (("2" (EXPAND "total_preorder?") (("2" (FLATTEN) (("2" (EXPAND "preorder?") (("2" (FLATTEN) (("2" (HIDE -1) (("2" (EXPAND "transitive?") (("2" (EXPAND ">=") (("2" (EXPAND "converse") (("2" (CASE "1 + 2 * floor((x!1 - 1) / 2) = x!1") (("1" (REPLACES -1) (("1" (INST -1 "h`seq(x!1)" "h`seq(floor((x!1 - 1) / 2))" "h`seq(0)") (("1" (ASSERT) NIL NIL) ("2" (HIDE -) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "ind_parent") (("3" (EXPAND "is_parent") (("3" (EXPAND "both_childs") (("3" (EXPAND "one_child") (("3" (EXPAND "ind_rc") (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE -1 3) (("4" (EXPAND "ind_parent") (("4" (TYPEPRED "x!1") (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE -1 3) (("2" (EXPAND "ind_parent") (("2" (TYPEPRED "x!1" "n") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE -1 3) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL) (|root_is_greatest_in_p_heap-1| |nil| 3651945338 ("" (SKOLEM 1 ("h" "n" "_")) (("" (INDUCT "i") (("1" (PROP) (("1" (ASSERT) NIL NIL)) NIL) ("2" (SKEEP) (("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|root_is_greatest_in_heap_TCC1| 0 (|root_is_greatest_in_heap_TCC1-1| |nil| 3653754711 ("" (SUBTYPE-TCC) NIL NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|is_heap| CONST-DECL "bool" |sorting_seq| NIL) (|is_p_heap| CONST-DECL "bool" |sorting_seq| NIL) (|right_child| CONST-DECL "T" |sorting_seq| NIL) (|converse| CONST-DECL "pred[[T2, T1]]" |relation_defs| NIL) (|left_child| CONST-DECL "T" |sorting_seq| NIL) (|ind_lc| CONST-DECL "nat" |sorting_seq| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|geq| CONST-DECL "pred[[T, T]]" |sorting| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|total_preorder?| CONST-DECL "bool" |total_preorder| NIL) (|leq| FORMAL-CONST-DECL "(total_preorder?[T])" |sorting_seq| NIL) (|is_parent| CONST-DECL "bool" |sorting_seq| NIL) (|one_child| CONST-DECL "bool" |sorting_seq| NIL) (|both_childs| CONST-DECL "bool" |sorting_seq| NIL) (|ind_rc| CONST-DECL "nat" |sorting_seq| NIL)) NIL (|root_is_greatest_in_heap| SUBTYPE "0" "below[length(h)]"))) (|root_is_greatest_in_heap| 0 (|root_is_greatest_in_heap-1| |nil| 3653754896 ("" (EXPAND "finseq_appl") (("" (SKEEP) (("" (LEMMA "root_is_greatest_in_p_heap") (("" (EXPAND "finseq_appl") (("" (INST?) (("" (EXPAND "is_heap") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|is_heap| CONST-DECL "bool" |sorting_seq| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (< CONST-DECL "bool" |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|root_is_greatest_in_p_heap| FORMULA-DECL NIL |sorting_seq| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL)) SHOSTAK)) (|parent_TCC1| 0 (|parent_TCC1-1| |nil| 3651167506 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nonneg_int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|posnat| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|rat_div_nzrat_is_rat| APPLICATION-JUDGEMENT "rat" |rationals| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|parent| SUBTYPE "floor_ceil.floor(number_fields./(((number_fields.-)(sorting_seq.k, 1)), 2))" "below[length(h)]"))) (|ind_gc_TCC1| 0 (|ind_gc_TCC1-1| |nil| 3651167506 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|ind_gc| SUBTYPE "sorting_seq.i" "{i: nat_types[length(sorting_seq.h)].below | reals.<=(i, sorting_seq.n)}"))) (|ind_gc_TCC2| 0 (|ind_gc_TCC2-1| |nil| 3651167506 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (<= CONST-DECL "bool" |reals| NIL) (|is_parent| CONST-DECL "bool" |sorting_seq| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|even_plus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|one_child| CONST-DECL "bool" |sorting_seq| NIL) (|ind_rc| CONST-DECL "nat" |sorting_seq| NIL) (|both_childs| CONST-DECL "bool" |sorting_seq| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL)) NIL (|ind_gc| SUBTYPE "sorting_seq.i" "{i: naturalnumbers.nat | reals.<(sorting_seq.ind_rc(i), length(sorting_seq.h))}"))) (|ind_gc_TCC3| 0 (|ind_gc_TCC3-1| |nil| 3651167506 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (<= CONST-DECL "bool" |reals| NIL) (|is_parent| CONST-DECL "bool" |sorting_seq| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|even_plus_even_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|one_child| CONST-DECL "bool" |sorting_seq| NIL) (|ind_lc| CONST-DECL "nat" |sorting_seq| NIL) (|both_childs| CONST-DECL "bool" |sorting_seq| NIL) (|ind_rc| CONST-DECL "nat" |sorting_seq| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL)) NIL (|ind_gc| SUBTYPE "sorting_seq.i" "{i: naturalnumbers.nat | reals.<(sorting_seq.ind_lc(i), length(sorting_seq.h))}"))) (|swap_of_p_heap_TCC1| 0 (|swap_of_p_heap_TCC1-1| |nil| 3651945177 ("" (SUBTYPE-TCC) NIL NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|swap| CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (|is_p_heap| CONST-DECL "bool" |sorting_seq| NIL) (|right_child| CONST-DECL "T" |sorting_seq| NIL) (|converse| CONST-DECL "pred[[T2, T1]]" |relation_defs| NIL) (|left_child| CONST-DECL "T" |sorting_seq| NIL) (|ind_lc| CONST-DECL "nat" |sorting_seq| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|geq| CONST-DECL "pred[[T, T]]" |sorting| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|total_preorder?| CONST-DECL "bool" |total_preorder| NIL) (|leq| FORMAL-CONST-DECL "(total_preorder?[T])" |sorting_seq| NIL) (|is_parent| CONST-DECL "bool" |sorting_seq| NIL) (|one_child| CONST-DECL "bool" |sorting_seq| NIL) (|both_childs| CONST-DECL "bool" |sorting_seq| NIL) (|ind_rc| CONST-DECL "nat" |sorting_seq| NIL)) NIL (|swap_of_p_heap| SUBTYPE "sorting_seq.n" "below[length(swap(h)(n, 0))]"))) (|swap_of_p_heap| 0 (|swap_of_p_heap-1| |nil| 3651945178 ("" (SKEEP) (("" (EXPAND "finseq_appl") (("" (EXPAND "swap") (("" (EXPAND "finseq_appl") (("" (LEMMA "root_is_greatest_in_p_heap") (("" (INST?) (("" (INST -1 "i") (("" (ASSERT) (("" (EXPAND "finseq_appl") (("" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (> CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (|root_is_greatest_in_p_heap| FORMULA-DECL NIL |sorting_seq| NIL) (|swap| CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK)) (|swap_commutes| 0 (|swap_commutes-1| |nil| 3651841474 ("" (SKEEP) (("" (EXPAND "swap") (("" (DECOMPOSE-EQUALITY) (("" (LIFT-IF) (("" (LIFT-IF) (("" (PROP) (("" (EXPAND "finseq_appl") (("" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|swap| CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (< CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL)) SHOSTAK)) (|occ_replaces_at_j_TCC1| 0 (|occ_replaces_at_j_TCC1-1| |nil| 3653078999 ("" (SUBTYPE-TCC) NIL NIL) ((|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (< CONST-DECL "bool" |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL)) NIL (|occ_replaces_at_j| SUBTYPE "sorting_seq.hp" "finite_sequence[T]"))) (|occ_replaces_at_j| 0 (|occ_replaces_at_j-1| |nil| 3653082224 ("" (EXPAND "finseq_appl") (("" (MEASURE-INDUCT+ "length(h)" ("h")) (("" (SKEEP) (("" (CASE "j = 0") (("1" (REPLACES -1) (("1" (LIFT-IF) (("1" (HIDE -1) (("1" (CASE "(# length := length(x!1),
                                           seq
                                             := LAMBDA (k: below[length(x!1)]):
                                                  IF k = 0 THEN x!1`seq(0)
                                                  ELSE x!1`seq(k)
                                                  ENDIF #) = x!1") (("1" (CASE "(# length := length(x!1),
                                           seq
                                             := LAMBDA (k: below[length(x!1)]):
                                                  IF k = 0 THEN x ELSE x!1`seq(k) ENDIF #)
                                         ^ (1, length(x!1) - 1) = x!1 ^ (1, length(x!1) - 1)") (("1" (PROP) (("1" (REPLACES -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (REPLACES -1) (("2" (EXPAND "occurrences" 1) (("2" (EXPAND "finseq_appl") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "occurrences" 1) (("3" (EXPAND "finseq_appl") (("3" (ASSERT) NIL NIL)) NIL)) NIL) ("4" (EXPAND "occurrences" 2) (("4" (EXPAND "finseq_appl") (("4" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE -1 2) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE -1 2) (("2" (DECOMPOSE-EQUALITY) (("2" (DECOMPOSE-EQUALITY) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (INST -1 "x!1 ^ (1, length(x!1) -1)" "j - 1" "x" "y") (("1" (CASE "(# length := length(x!1 ^ (1, length(x!1) - 1)),
                                                 seq
                                                   := LAMBDA (k:
                                                                below
                                                                [length(x!1 ^ (1, length(x!1) - 1))]):
                                                        IF k = j - 1 THEN x
                                                        ELSE (x!1 ^ (1, length(x!1) - 1))`seq(k)
                                                        ENDIF #) = (# length := length(x!1),
                                                  seq
                                                    := LAMBDA (k: below[length(x!1)]):
                                                         IF k = j THEN x ELSE x!1`seq(k) ENDIF #)
                                                ^ (1, length(x!1) - 1)") (("1" (REPLACES -1) (("1" (SPLIT -1 1) (("1" (LIFT-IF) (("1" (PROP) (("1" (EXPAND "occurrences" 1) (("1" (EXPAND "finseq_appl") (("1" (ASSERT) (("1" (LIFT-IF) (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE -3 1) (("2" (GRIND) NIL NIL)) NIL) ("3" (HIDE -3 1) (("3" (GRIND) NIL NIL)) NIL) ("4" (HIDE -2 2) (("4" (GRIND) NIL NIL)) NIL) ("5" (HIDE -3 1) (("5" (GRIND) NIL NIL)) NIL) ("6" (REPLACES -1) (("6" (EXPAND "occurrences" 1) (("6" (EXPAND "finseq_appl") (("6" (ASSERT) (("6" (LIFT-IF) (("6" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("7" (HIDE -2 -3 1) (("7" (GRIND) NIL NIL)) NIL) ("8" (EXPAND "occurrences" 1) (("8" (EXPAND "finseq_appl") (("8" (ASSERT) (("8" (LIFT-IF) (("8" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("9" (HIDE -2 2 6) (("9" (GRIND) NIL NIL)) NIL) ("10" (HIDE -2 1 2) (("10" (GRIND) NIL NIL)) NIL) ("11" (HIDE -2 1 6) (("11" (GRIND) NIL NIL)) NIL) ("12" (EXPAND "occurrences" 2) (("12" (EXPAND "finseq_appl") (("12" (ASSERT) (("12" (LIFT-IF) (("12" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2 3) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE - 2 3) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (SKEEP) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|occurrences| DEF-DECL "nat" |sorting_seq| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (>= CONST-DECL "bool" |reals| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL) (|int_min| APPLICATION-JUDGEMENT "{k: int | k <= i AND k <= j}" |real_defs| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (|empty_seq| CONST-DECL "finseq" |finite_sequences| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (^ CONST-DECL "finseq" |finite_sequences| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|j| SKOLEM-CONST-DECL "below[length(x!1)]" |sorting_seq| NIL) (|x!1| SKOLEM-CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL)) SHOSTAK)) (|swap_occ_at_0_TCC1| 0 (|swap_occ_at_0_TCC1-1| |nil| 3653031566 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|swap_occ_at_0| SUBTYPE "0" "below[length(h)]"))) (|swap_occ_at_0_TCC2| 0 (|swap_occ_at_0_TCC2-1| |nil| 3653031566 ("" (SUBTYPE-TCC) NIL NIL) NIL NIL (|swap_occ_at_0| SUBTYPE "(number_fields.-)(length(sorting_seq.h), 1)" "nat"))) (|swap_occ_at_0| 0 (|swap_occ_at_0-1| |nil| 3653037944 ("" (EXPAND "finseq_appl") (("" (SKEEP) (("" (LIFT-IF) (("" (PROP) (("1" (LEMMA "occ_replaces_at_j") (("1" (EXPAND "finseq_appl") (("1" (INST -1 "h ^ (1, length(h) - 1)" "j - 1" "h`seq(0)" "x") (("1" (LIFT-IF) (("1" (PROP) (("1" (EXPAND "^ " -1) (("1" (EXPAND "occurrences" 1 2) (("1" (EXPAND "finseq_appl") (("1" (ASSERT) (("1" (CASE "(# length := length(h ^ (1, length(h) - 1)),
                     seq
                       := LAMBDA (k:
                                    below[length(h ^ (1, length(h) - 1))]):
                            IF k = j - 1 THEN h`seq(0)
                            ELSE (h ^ (1, length(h) - 1))`seq(k)
                            ENDIF #) = swap(h)(0, j) ^ (1, length(h) - 1)") (("1" (ASSERT) NIL NIL) ("2" (HIDE -2 2) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE -2 2) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE -2 2) (("2" (GRIND) NIL NIL)) NIL) ("3" (EXPAND "^ " 2) (("3" (EXPAND "^ " -1) (("3" (EXPAND "occurrences" 3 2) (("3" (EXPAND "finseq_appl") (("3" (ASSERT) (("3" (CASE "(# length := length(h ^ (1, length(h) - 1)),
                     seq
                       := LAMBDA (k:
                                    below[length(h ^ (1, length(h) - 1))]):
                            IF k = j - 1 THEN h`seq(0)
                            ELSE (h ^ (1, length(h) - 1))`seq(k)
                            ENDIF #)  = swap(h)(0, j) ^ (1, length(h) - 1)") (("1" (ASSERT) NIL NIL) ("2" (HIDE -2 4) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE -2 4) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (HIDE -1 4) (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (LEMMA "occ_replaces_at_j") (("2" (EXPAND "finseq_appl") (("2" (ASSERT) (("2" (INST -1 "h ^ (1, length(h) - 1)" "j - 1" "h`seq(0)" "x") (("1" (LIFT-IF) (("1" (PROP) (("1" (EXPAND " ^ " -1) (("1" (EXPAND "occurrences" 2 2) (("1" (EXPAND "finseq_appl") (("1" (ASSERT) (("1" (CASE "(# length := length(h ^ (1, length(h) - 1)),
                     seq
                       := LAMBDA (k:
                                    below[length(h ^ (1, length(h) - 1))]):
                            IF k = j - 1 THEN h`seq(0)
                            ELSE (h ^ (1, length(h) - 1))`seq(k)
                            ENDIF #) = swap(h)(0, j) ^ (1, length(h) - 1)") (("1" (ASSERT) NIL NIL) ("2" (HIDE -2 3) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE -2 3) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "^ " 1) (("2" (EXPAND "occurrences" 3 2) (("2" (EXPAND "finseq_appl") (("2" (ASSERT) (("2" (CASE "(# length := length(h ^ (1, length(h) - 1)),
                     seq
                       := LAMBDA (k:
                                    below[length(h ^ (1, length(h) - 1))]):
                            IF k = j - 1 THEN h`seq(0)
                            ELSE (h ^ (1, length(h) - 1))`seq(k)
                            ENDIF #) = swap(h)(0, j) ^ (1, length(h) - 1)") (("1" (ASSERT) NIL NIL) ("2" (HIDE -2 4) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE -2 4) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE -2 4) (("3" (GRIND) NIL NIL)) NIL) ("4" (EXPAND "^ " 1) (("4" (EXPAND "^ " 3) (("4" (EXPAND " occurrences" 5 2) (("4" (EXPAND "finseq_appl") (("4" (ASSERT) (("4" (CASE "(# length := length(h ^ (1, length(h) - 1)),
                     seq
                       := LAMBDA (k:
                                    below[length(h ^ (1, length(h) - 1))]):
                            IF k = j - 1 THEN h`seq(0)
                            ELSE (h ^ (1, length(h) - 1))`seq(k)
                            ENDIF #) = swap(h)(0, j) ^ (1, length(h) - 1)") (("1" (ASSERT) NIL NIL) ("2" (HIDE -1 6) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE -1 6) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|swap| CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_min| APPLICATION-JUDGEMENT "{k: int | k <= i AND k <= j}" |real_defs| NIL) (|occurrences| DEF-DECL "nat" |sorting_seq| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (< CONST-DECL "bool" |reals| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|h| SKOLEM-CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (> CONST-DECL "bool" |reals| NIL) (|j| SKOLEM-CONST-DECL "{j: below[length(h)] | j > 0}" |sorting_seq| NIL) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (^ CONST-DECL "finseq" |finite_sequences| NIL) (|occ_replaces_at_j| FORMULA-DECL NIL |sorting_seq| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL)) SHOSTAK)) (|swap_permutes| 0 (|swap_permutes-3| |nil| 3653037248 ("" (MEASURE-INDUCT+ "length(h)" "h") (("" (SKEEP) (("" (TYPEPRED "i" "j") (("" (CASE "i = j") (("1" (HIDE -4) (("1" (REPLACES -1) (("1" (HIDE -) (("1" (CASE "x!1 = swap(x!1)(j,j)") (("1" (REPLACE -1 1 RL) (("1" (HIDE -) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (DECOMPOSE-EQUALITY 1) (("1" (EXPAND "swap") (("1" (PROPAX) NIL NIL)) NIL) ("2" (DECOMPOSE-EQUALITY 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "NOT i = 0 AND NOT j = 0") (("1" (FLATTEN) (("1" (EXPAND "permutations" 4) (("1" (SKEEP) (("1" (EXPAND "occurrences") (("1" (EXPAND "finseq_appl") (("1" (INST -3 "x!1 ^ (1, length(x!1) - 1)" "i-1" "j-1") (("1" (LIFT-IF) (("1" (EXPAND "permutations") (("1" (EXPAND "swap" 4 (1 4 6 7 10 12)) (("1" (LIFT-IF) (("1" (CASE "swap(x!1 ^ (1, length(x!1) - 1))(i - 1, j - 1) = swap(x!1)(i, j) ^ (1, length(x!1) - 1)") (("1" (REPLACES -1) (("1" (SPLIT -3) (("1" (INST?) (("1" (ASSERT) (("1" (LIFT-IF) (("1" (PROP) (("1" (HIDE -2) (("1" (GRIND) NIL NIL)) NIL) ("2" (HIDE -2 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE -3 5) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (HIDE -3 5) (("3" (GRIND) NIL NIL)) NIL) ("4" (HIDE -3 5) (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 5) (("2" (GRIND) NIL NIL)) NIL) ("3" (HIDE 5) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE -3) (("2" (SPLIT) (("1" (REPLACES -1) (("1" (EXPAND "permutations") (("1" (SKEEP) (("1" (LEMMA "swap_occ_at_0") (("1" (EXPAND "finseq_appl") (("1" (INST?) (("1" (INST?) (("1" (EXPAND "occurrences" 2) (("1" (EXPAND "finseq_appl") (("1" (EXPAND "swap" 2 (1 4 6)) (("1" (EXPAND "occurrences" -1 (2 3)) (("1" (EXPAND "finseq_appl") (("1" (LIFT-IF) (("1" (LIFT-IF) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (PROP) (("1" (ASSERT) NIL NIL) ("2" (HIDE -3 2) (("2" (GRIND) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL) ("4" (HIDE -1 2) (("4" (GRIND) NIL NIL)) NIL) ("5" (HIDE -4 1) (("5" (GRIND) NIL NIL)) NIL) ("6" (ASSERT) NIL NIL) ("7" (HIDE -2 1) (("7" (GRIND) NIL NIL)) NIL) ("8" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES -1) (("2" (EXPAND "permutations") (("2" (SKEEP) (("2" (LEMMA "swap_occ_at_0") (("2" (EXPAND "finseq_appl") (("2" (INST?) (("2" (INST?) (("1" (EXPAND "occurrences" 2) (("1" (EXPAND "finseq_appl") (("1" (EXPAND "swap" 2 (1 4 6)) (("1" (EXPAND "occurrences" -1 (2 3)) (("1" (EXPAND "finseq_appl") (("1" (LIFT-IF) (("1" (LIFT-IF) (("1" (LIFT-IF) (("1" (ASSERT) (("1" (PROP) (("1" (REWRITE "swap_commutes") (("1" (ASSERT) NIL NIL)) NIL) ("2" (HIDE -3 2) (("2" (GRIND) NIL NIL)) NIL) ("3" (REWRITE "swap_commutes") (("3" (ASSERT) NIL NIL)) NIL) ("4" (HIDE -1 2) (("4" (GRIND) NIL NIL)) NIL) ("5" (HIDE -4 1) (("5" (GRIND) NIL NIL)) NIL) ("6" (REWRITE "swap_commutes") (("6" (ASSERT) NIL NIL)) NIL) ("7" (HIDE -2 1) (("7" (GRIND) NIL NIL)) NIL) ("8" (REWRITE "swap_commutes") (("8" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|swap_commutes| FORMULA-DECL NIL |sorting_seq| NIL) (> CONST-DECL "bool" |reals| NIL) (|swap_occ_at_0| FORMULA-DECL NIL |sorting_seq| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|int_min| APPLICATION-JUDGEMENT "{k: int | k <= i AND k <= j}" |real_defs| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (|empty_seq| CONST-DECL "finseq" |finite_sequences| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (^ CONST-DECL "finseq" |finite_sequences| NIL) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|i| SKOLEM-CONST-DECL "below[length(x!1)]" |sorting_seq| NIL) (|x!1| SKOLEM-CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (|j| SKOLEM-CONST-DECL "below[length(x!1)]" |sorting_seq| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (|occurrences| DEF-DECL "nat" |sorting_seq| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|permutations| CONST-DECL "bool" |sorting_seq| NIL) (|swap| CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)) NIL) (|swap_permutes-2| |nil| 3651937530 ("" (MEASURE-INDUCT+ "length(h)" "h") (("" (SKEEP) (("" (TYPEPRED "i" "j") (("" (CASE "i = j") (("1" (HIDE -4) (("1" (REPLACES -1) (("1" (HIDE -) (("1" (CASE "x!1 = swap(x!1)(j,j)") (("1" (REPLACE -1 1 RL) (("1" (HIDE -) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (HIDE 2) (("2" (DECOMPOSE-EQUALITY 1) (("1" (EXPAND "swap") (("1" (PROPAX) NIL NIL)) NIL) ("2" (DECOMPOSE-EQUALITY 1) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "NOT i = 0 AND NOT j = 0") (("1" (FLATTEN) (("1" (EXPAND "permutations" 4) (("1" (SKEEP) (("1" (EXPAND "occurrences") (("1" (EXPAND "finseq_appl") (("1" (LIFT-IF) (("1" (PROP) (("1" (EXPAND "swap" 1 (1 4 6)) (("1" (EXPAND "swap" 1 1) (("1" (EXPAND "finseq_appl") (("1" (ASSERT) (("1" (INST -4 "x!1 ^ (1, length(x!1) - 1)" "i-1" "j-1") (("1" (PROP) (("1" (EXPAND "permutations") (("1" (INST?) (("1" (CASE "swap(x!1 ^ (1, length(x!1) - 1))(i - 1, j - 1) = swap(x!1)(i, j) ^ (1, length(x!1) - 1)") (("1" (ASSERT) NIL NIL) ("2" (HIDE -1 2) (("2" (DECOMPOSE-EQUALITY 1) (("1" (EXPAND "swap") (("1" (EXPAND "^" 1) (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (DECOMPOSE-EQUALITY 1) (("2" (EXPAND "swap") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "^ " 1) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (EXPAND "^ " 1) (("2" (GRIND) NIL NIL)) NIL) ("3" (EXPAND "^ " 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "swap" 2 (1 4 6)) (("2" (EXPAND "swap" 2 1) (("2" (EXPAND "finseq_appl") (("2" (ASSERT) (("2" (INST -3 "x!1 ^ (1, length(x!1) - 1)" "i-1" "j-1") (("1" (PROP) (("1" (EXPAND "permutations") (("1" (INST?) (("1" (CASE "swap(x!1 ^ (1, length(x!1) - 1))(i - 1, j - 1) = swap(x!1)(i, j) ^ (1, length(x!1) - 1)") (("1" (ASSERT) NIL NIL) ("2" (HIDE -1 3) (("2" (DECOMPOSE-EQUALITY 1) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY 1) (("2" (EXPAND "swap") (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "^" 1) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("2" (EXPAND "^" 1) (("2" (GRIND) NIL NIL)) NIL) ("3" (EXPAND "^" 1) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SPLIT) (("1" (REPLACES -1) (("1" (EXPAND "permutations") (("1" (SKEEP) (("1" (LEMMA "swap_occ_at_0") (("1" (EXPAND "finseq_appl") (("1" (INST?) (("1" (INST?) (("1" (EXPAND "occurrences" 2) (("1" (EXPAND "finseq_appl") (("1" (LIFT-IF) (("1" (LIFT-IF) (("1" (PROP) (("1" (EXPAND "swap" -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "swap" 1 2) (("2" (EXPAND "occurrences" -4 2) (("2" (EXPAND "finseq_appl") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "swap" 2 2) (("3" (EXPAND "occurrences" -3 2) (("3" (EXPAND "finseq_appl") (("3" (ASSERT) (("3" (EXPAND "swap" 1) (("3" (EXPAND "finseq_appl") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (LIFT-IF) (("4" (PROP) (("1" (EXPAND "swap" -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "occurrences" -3 2) (("2" (EXPAND "finseq_appl") (("2" (ASSERT) (("2" (EXPAND "swap" 1 2) (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "swap" 1) (("3" (EXPAND "finseq_appl") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("5" (EXPAND "swap" -1) (("5" (ASSERT) NIL NIL)) NIL) ("6" (EXPAND "swap " -1) (("6" (EXPAND "finseq_appl") (("6" (PROPAX) NIL NIL)) NIL)) NIL) ("7" (EXPAND "swap" 2 2) (("7" (EXPAND "occurrences" -2 2) (("7" (EXPAND "finseq_appl") (("7" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("8" (EXPAND "swap" 2 (1 2 6)) (("8" (EXPAND "finseq_appl") (("8" (ASSERT) (("8" (EXPAND "occurrences" -1 2) (("8" (EXPAND "finseq_appl") (("8" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (REPLACES -1) (("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL NIL) (|swap_permutes-1| |nil| 3651244150 ("" (EXPAND "permutations") (("" (EXPAND "swap") (("" (EXPAND "finseq_appl") (("" (MEASURE-INDUCT+ "length(h)" "h") (("" (CASE "length(x!1) = 0") (("1" (HIDE -2) (("1" (GRIND) NIL NIL)) NIL) ("2" (SKEEP) (("2" (SKEEP) (("2" (CASE "x!1`seq(i) = x!1`seq(j)") (("1" (HIDE -2) (("1" (CASE "x!1 = (# length := length(x!1),
                      seq
                        := LAMBDA (k: below[length(x!1)]):
                             IF k = i THEN x!1`seq(j)
                             ELSIF k = j THEN x!1`seq(i)
                             ELSE x!1`seq(k)
                             ENDIF #)") (("1" (ASSERT) NIL NIL) ("2" (HIDE 3) (("2" (DECOMPOSE-EQUALITY 1) (("2" (DECOMPOSE-EQUALITY 1) (("2" (LIFT-IF) (("2" (PROP) (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "NOT (i=0 OR j=0)") (("1" (FLATTEN) (("1" (INST -1 "x!1^(1,length(x!1)-1)") (("1" (INST -1 "i-1" "j-1") (("1" (ASSERT) (("1" (PROP) (("1" (INST -1 "x") (("1" (EXPAND "occurrences" 5) (("1" (LIFT-IF) (("1" (EXPAND "finseq_appl") (("1" (CASE "(# length := length(x!1 ^ (1, length(x!1) - 1)),
                      seq
                        := LAMBDA (k:
                                     below
                                     [length(x!1 ^ (1, length(x!1) - 1))]):
                             IF k = i - 1
                               THEN (x!1 ^ (1, length(x!1) - 1))`seq(j - 1)
                             ELSIF k = j - 1
                               THEN (x!1 ^ (1, length(x!1) - 1))`seq(i - 1)
                             ELSE (x!1 ^ (1, length(x!1) - 1))`seq(k)
                             ENDIF #) = (# length := length(x!1),
                      seq
                        := LAMBDA (k: below[length(x!1)]):
                             IF k = i THEN x!1`seq(j)
                             ELSIF k = j THEN x!1`seq(i)
                             ELSE x!1`seq(k)
                             ENDIF #)
                    ^ (1, length(x!1) - 1)") (("1" (REPLACE -1) (("1" (PROPAX) NIL NIL)) NIL) ("2" (HIDE -1 6) (("2" (EXPAND "^" 1 5) (("2" (SPLIT) (("1" (EXPAND "^") (("1" (PROPAX) NIL NIL)) NIL) ("2" (DECOMPOSE-EQUALITY) (("1" (LIFT-IF) (("1" (LIFT-IF) (("1" (LIFT-IF) (("1" (LIFT-IF) (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (SKEEP) (("2" (GRIND) NIL NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED "x!2") (("3" (GRIND) NIL NIL)) NIL)) NIL) ("4" (GRIND) NIL NIL) ("5" (SKEEP) (("5" (TYPEPRED "i") (("5" (GRIND) NIL NIL)) NIL)) NIL) ("6" (SKEEP) (("6" (TYPEPRED "j") (("6" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE -1 6) (("3" (SKEEP) (("3" (GRIND) NIL NIL)) NIL)) NIL) ("4" (HIDE -1 6) (("4" (GRIND) NIL NIL)) NIL) ("5" (HIDE -1 6) (("5" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 6) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE 6) (("2" (GRIND) NIL NIL)) NIL) ("3" (HIDE 6) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (CASE "length(x!1) = 1") (("1" (HIDE -3) (("1" (GRIND) NIL NIL)) NIL) ("2" (POSTPONE) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK)) (|swap_of_heap_TCC1| 0 (|swap_of_heap_TCC1-1| |nil| 3651335364 ("" (SUBTYPE-TCC) NIL NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|swap| CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (|is_heap| CONST-DECL "bool" |sorting_seq| NIL) (|is_p_heap| CONST-DECL "bool" |sorting_seq| NIL) (|right_child| CONST-DECL "T" |sorting_seq| NIL) (|converse| CONST-DECL "pred[[T2, T1]]" |relation_defs| NIL) (|left_child| CONST-DECL "T" |sorting_seq| NIL) (|ind_lc| CONST-DECL "nat" |sorting_seq| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|geq| CONST-DECL "pred[[T, T]]" |sorting| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|total_preorder?| CONST-DECL "bool" |total_preorder| NIL) (|leq| FORMAL-CONST-DECL "(total_preorder?[T])" |sorting_seq| NIL) (|is_parent| CONST-DECL "bool" |sorting_seq| NIL) (|one_child| CONST-DECL "bool" |sorting_seq| NIL) (|both_childs| CONST-DECL "bool" |sorting_seq| NIL) (|ind_rc| CONST-DECL "nat" |sorting_seq| NIL)) NIL (|swap_of_heap| SUBTYPE "(number_fields.-)(length(sorting_seq.h), 1)" "below[length(swap(h)(length(h) - 1, 0))]"))) (|swap_of_heap_TCC2| 0 (|swap_of_heap_TCC2-1| |nil| 3651335364 ("" (SUBTYPE-TCC) NIL NIL) ((|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|is_heap| CONST-DECL "bool" |sorting_seq| NIL) (|is_p_heap| CONST-DECL "bool" |sorting_seq| NIL) (|right_child| CONST-DECL "T" |sorting_seq| NIL) (|converse| CONST-DECL "pred[[T2, T1]]" |relation_defs| NIL) (|left_child| CONST-DECL "T" |sorting_seq| NIL) (|ind_lc| CONST-DECL "nat" |sorting_seq| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|geq| CONST-DECL "pred[[T, T]]" |sorting| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|total_preorder?| CONST-DECL "bool" |total_preorder| NIL) (|leq| FORMAL-CONST-DECL "(total_preorder?[T])" |sorting_seq| NIL) (|is_parent| CONST-DECL "bool" |sorting_seq| NIL) (|one_child| CONST-DECL "bool" |sorting_seq| NIL) (|both_childs| CONST-DECL "bool" |sorting_seq| NIL) (|ind_rc| CONST-DECL "nat" |sorting_seq| NIL)) NIL (|swap_of_heap| SUBTYPE "(number_fields.-)(length(sorting_seq.h), 1)" "below[length(h)]"))) (|swap_of_heap| 0 (|swap_of_heap-2| "" 3884901750 ("" (EXPAND "swap") (("" (EXPAND "finseq_appl") (("" (SKEEP) (("" (LEMMA "root_is_greatest_in_heap") (("" (INST -1 "h" "i") (("" (PROP) (("" (TYPEPRED "i") (("" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) NIL SHOSTAK) (|swap_of_heap-1| |nil| 3651335367 ("" (EXPAND "swap") (("" (EXPAND "finseq_appl") (("" (SKEEP) (("" (LEMMA "root_is_greatest_in_heap") (("" (INST -1 "h" "i") (("" (PROP) (("1" (TYPEPRED I) (("1" (GRIND) NIL NIL)) NIL) ("2" (EXPAND "finseq_appl") (("2" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|root_is_greatest_in_heap| FORMULA-DECL NIL |sorting_seq| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|dichotomous_converse| APPLICATION-JUDGEMENT "(dichotomous?[T])" |relation_converse_props| NIL) (|preorder_converse| APPLICATION-JUDGEMENT "(preorder?[T])" |relation_converse_props| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|even_times_int_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|nnint_times_nnint_is_nnint| APPLICATION-JUDGEMENT "nonneg_int" |integers| NIL) (|is_heap| CONST-DECL "bool" |sorting_seq| NIL) (|is_p_heap| CONST-DECL "bool" |sorting_seq| NIL) (|right_child| CONST-DECL "T" |sorting_seq| NIL) (|left_child| CONST-DECL "T" |sorting_seq| NIL) (|ind_lc| CONST-DECL "nat" |sorting_seq| NIL) (|is_parent| CONST-DECL "bool" |sorting_seq| NIL) (|one_child| CONST-DECL "bool" |sorting_seq| NIL) (|both_childs| CONST-DECL "bool" |sorting_seq| NIL) (|ind_rc| CONST-DECL "nat" |sorting_seq| NIL) (|converse| CONST-DECL "pred[[T2, T1]]" |relation_defs| NIL) (|geq| CONST-DECL "pred[[T, T]]" |sorting| NIL) (PRED TYPE-EQ-DECL NIL |defined_types| NIL) (|total_preorder?| CONST-DECL "bool" |total_preorder| NIL) (|leq| FORMAL-CONST-DECL "(total_preorder?[T])" |sorting_seq| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (< CONST-DECL "bool" |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (> CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|swap| CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) SHOSTAK)) (|occ_in_insert| 0 (|occ_in_insert-2| |nil| 3779122699 ("" (MEASURE-INDUCT+ "length(v)" "v") (("" (SKEEP) (("" (CASE "length(x!1)=0") (("1" (HIDE -2) (("1" (GRIND) NIL NIL)) NIL) ("2" (CASE "FORALL(v:finseq[T])(k:upto[length(v)])(y,x:T):occurrences(insert?(y, v, k))(x)
                                                             = occurrences(insert?(y, v, 0))(x)") (("1" (INST -1 "x!1" "k" "y" "x") (("1" (REPLACES -1 2) (("1" (PROP) (("1" (REPLACE -1) (("1" (EXPAND "occurrences" 1 1) (("1" (LIFT-IF) (("1" (PROP) (("1" (EXPAND "insert?" -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "finseq_appl") (("2" (REVEAL -4) (("2" (CASE "  occurrences(insert?(y, x!1, 0) ^ (1, length(insert?(y, x!1, 0)) - 1))
                                                                                                              (y) = occurrences(x!1)(y)") (("1" (REPLACES -1) NIL NIL) ("2" (HIDE-ALL-BUT (1 4)) (("2" (GRIND) NIL NIL)) NIL) ("3" (EXPAND "insert?" 1) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "finseq_appl") (("3" (EXPAND "insert?" 1) (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "occurrences" 2 1) (("2" (LIFT-IF) (("2" (PROP) (("1" (EXPAND "insert?" -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "finseq_appl") (("2" (EXPAND "insert?" -1) (("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (EXPAND "finseq_appl") (("3" (HIDE-ALL-BUT 2) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 2)) (("2" (MEASURE-INDUCT+ "length(v)" "v") (("1" (SKEEP) (("1" (SKEEP) (("1" (CASE "k!1=0") (("1" (REPLACES -1 1) NIL NIL) ("2" (EXPAND "occurrences" 2 1) (("2" (EXPAND "finseq_appl") (("2" (CASE "insert?(y!1, x!2^(1, length(x!2)-1), k!1 -1) = insert?(y!1, x!2, k!1) ^ (1, length(insert?(y!1, x!2, k!1))-1)") (("1" (INST -2 "x!2^(1,length(x!2)-1)") (("1" (INST -2 "k!1 - 1") (("1" (SPLIT) (("1" (INST -1 "y!1" "x!3") (("1" (REPLACES -2) (("1" (LIFT-IF) (("1" (PROP) (("1" (HIDE-ALL-BUT -1) (("1" (EXPAND "insert?") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (REPLACES -2) (("2" (EXPAND "occurrences" 1 2) (("2" (EXPAND "finseq_appl") (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE-ALL-BUT -1) (("1" (EXPAND "insert?") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "insert?(y!1, x!2, 0) ^(1, length(insert?(y!1, x!2, 0)) - 1) = x!2") (("1" (REPLACES -1) (("1" (CASE "occurrences(insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0))(x!3) = 1 + occurrences(x!2^(1,length(x!2)-1))(x!3)") (("1" (REPLACES -1) (("1" (EXPAND "insert?" -2) (("1" (EXPAND "finseq_appl") (("1" (ASSERT) (("1" (EXPAND "occurrences" 1) (("1" (EXPAND "finseq_appl") (("1" (LIFT-IF) (("1" (PROP) (("1" (EXPAND "^" -1) (("1" (EXPAND "empty_seq") (("1" (EXPAND "min") (("1" (LIFT-IF) (("1" (PROP) (("1" (CASE "length(x!2) = 1") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "^") (("1" (EXPAND "occurrences") (("1" (EXPAND "empty_seq") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (CASE "x!2`length = 1") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "^") (("1" (EXPAND "occurrences") (("1" (EXPAND "empty_seq") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "^" -1) (("2" (LIFT-IF) (("2" (PROP) (("1" (CASE "length(x!2)=1") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "^") (("1" (EXPAND "empty_seq") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) (("2" (CASE "length(x!2)=1") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "^") (("1" (EXPAND "empty_seq") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (EXPAND "insert?") (("3" (EXPAND "occurrences" 3 2) (("3" (EXPAND "finseq_appl") (("3" (LIFT-IF) (("3" (PROP) (("3" (ASSERT) (("3" (EXPAND "^") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "occurrences" 2 2) (("3" (EXPAND "finseq_appl") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE 3 4) (("2" (EXPAND "insert?" -1) (("2" (EXPAND "insert?" -2) (("2" (EXPAND "finseq_appl") (("2" (ASSERT) (("2" (EXPAND "occurrences" 1 1) (("2" (EXPAND "finseq_appl") (("2" (LIFT-IF) (("2" (PROP) (("1" (EXPAND "insert?") (("1" (ASSERT) NIL NIL)) NIL) ("2" (CASE "insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0) ^
                                                                                                                       (1,
                                                                                                                        length(insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0)) -
                                                                                                                         1) = x!2 ^ (1, length(x!2) - 1)") (("1" (REPLACES -1) NIL NIL) ("2" (HIDE -1 -2 -3 2 4 3 5) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT (1 6)) (("3" (EXPAND "insert?") (("3" (EXPAND "^") (("3" (LIFT-IF) (("3" (PROP) (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL) ("3" (EXPAND "min") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "insert?") (("3" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "^" 1) (("2" (LIFT-IF) (("2" (PROP) (("1" (EXPAND "insert?" -1) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "insert?" -1) (("2" (ASSERT) NIL NIL)) NIL) ("3" (HIDE-ALL-BUT (3 8)) (("3" (DECOMPOSE-EQUALITY) (("1" (EXPAND "min") (("1" (EXPAND "insert?") (("1" (PROPAX) NIL NIL)) NIL)) NIL) ("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL) ("3" (GRIND) NIL NIL)) NIL) ("3" (GRIND) NIL NIL) ("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (HIDE-ALL-BUT 1) (("3" (EXPAND "insert?") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("3" (CASE "occurrences(insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0))(x!3) =
                                                                                        occurrences(x!2 ^ (1, length(x!2) - 1))(x!3)") (("1" (REPLACES -1) (("1" (CASE "insert?(y!1, x!2, 0) ^
                                                                                                           (1, length(insert?(y!1, x!2, 0)) - 1) =  x!2") (("1" (REPLACES -1) (("1" (EXPAND "insert?" -1) (("1" (EXPAND "finseq_appl") (("1" (ASSERT) (("1" (EXPAND "occurrences" 2 2) (("1" (EXPAND "finseq_appl") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (DECOMPOSE-EQUALITY) (("1" (HIDE-ALL-BUT 1) (("1" (GRIND) NIL NIL)) NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (HIDE 3) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 2 -1 7)) (("2" (EXPAND "occurrences" 1 1) (("2" (EXPAND "finseq_appl") (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE-ALL-BUT -1) (("1" (EXPAND "insert?") (("1" (EXPAND "^") (("1" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL) ("3" (CASE "insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0) ^  (1,
                                                                                                                 length(insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0)) -
                                                                                                                  1) = x!2 ^ (1, length(x!2) - 1)") (("1" (REPLACES -1) NIL NIL) ("2" (REPLACES -1) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (ASSERT) (("3" (REPLACES -1) (("3" (EXPAND "occurrences" 2 2) (("3" (EXPAND "finseq_appl") (("3" (LIFT-IF) (("3" (PROP) (("1" (EXPAND "insert?") (("1" (PROPAX) NIL NIL)) NIL) ("2" (CASE "insert?(y!1, x!2, 0) ^
                                                                                                      (1, length(insert?(y!1, x!2, 0)) - 1) = x!2") (("1" (REPLACES -1) (("1" (EXPAND "occurrences" 1 1) (("1" (LIFT-IF) (("1" (PROP) (("1" (EXPAND "insert?") (("1" (EXPAND "^") (("1" (LIFT-IF) (("1" (PROP) (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL) ("3" (EXPAND "min") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "finseq_appl") (("2" (CASE "insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0) ^
                                                                                                                 (1,
                                                                                                                  length(insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0)) -
                                                                                                                   1) = x!2^(1,length(x!2)-1)") (("1" (REPLACES -1) (("1" (EXPAND "occurrences" 1 2) (("1" (EXPAND "finseq_appl") (("1" (ASSERT) (("1" (LIFT-IF) (("1" (PROP) (("1" (EXPAND "insert?") (("1" (EXPAND "finseq_appl") (("1" (PROPAX) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 8)) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT (1 7)) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL) ("3" (EXPAND "occurrences" 2 1) (("3" (LIFT-IF) (("3" (PROP) (("1" (EXPAND "insert?") (("1" (EXPAND "^") (("1" (EXPAND "finseq_appl") (("1" (LIFT-IF) (("1" (PROP) (("1" (ASSERT) NIL NIL) ("2" (ASSERT) NIL NIL) ("3" (EXPAND "min") (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "finseq_appl") (("2" (EXPAND "insert?") (("2" (PROPAX) NIL NIL)) NIL)) NIL) ("3" (EXPAND "finseq_appl") (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (ASSERT) NIL NIL)) NIL) ("2" (HIDE -1 3) (("2" (CASE "length(x!2)>=2") (("1" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL) ("2" (DECOMPOSE-EQUALITY 2) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (GRIND) NIL NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "insert?" 1) (("3" (ASSERT) NIL NIL)) NIL) ("4" (SPLIT) (("1" (ASSERT) NIL NIL) ("2" (EXPAND "^" 1) (("2" (EXPAND "min") (("2" (LIFT-IF 1) (("2" (PROP) (("1" (EXPAND "empty_seq") (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "empty_seq") (("2" (ASSERT) NIL NIL)) NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("5" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (ASSERT) NIL NIL) ("3" (ASSERT) NIL NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((TRUE CONST-DECL "bool" |booleans| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (|real_le_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (|k!1| SKOLEM-CONST-DECL "upto[length(x!2)]" |sorting_seq| NIL) (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|y!1| SKOLEM-CONST-DECL "T" |sorting_seq| NIL) (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|odd_plus_even_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|even_plus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|x!2| SKOLEM-CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_min| APPLICATION-JUDGEMENT "{k: int | k <= i AND k <= j}" |real_defs| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (^ CONST-DECL "finseq" |finite_sequences| NIL) (|empty_seq| CONST-DECL "finseq" |finite_sequences| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (<= CONST-DECL "bool" |reals| NIL) (|upto| NONEMPTY-TYPE-EQ-DECL NIL |nat_types| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|occurrences| DEF-DECL "nat" |sorting_seq| NIL) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|insert?| CONST-DECL "finseq" |seq_extras| |structures|) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)) NIL) (|occ_in_insert-1| |nil| 3779122620 ("" (MEASURE-INDUCT+ "length(v)" "v") (("" (SKEEP) (("" (CASE "length(x!1)=0") (("1" (HIDE -2) (("1" (GRIND) NIL))) ("2" (CASE "FORALL(v:finseq[nat])(k:upto[length(v)])(y,x:nat):occurrences(insert?(y, v, k))(x)
                                                    = occurrences(insert?(y, v, 0))(x)") (("1" (INST -1 "x!1" "k" "y" "x") (("1" (REPLACES -1 2) (("1" (PROP) (("1" (REPLACE -1) (("1" (EXPAND "occurrences" 1 1) (("1" (LIFT-IF) (("1" (PROP) (("1" (EXPAND "insert?" -1) (("1" (ASSERT) NIL))) ("2" (EXPAND "finseq_appl") (("2" (REVEAL -4) (("2" (CASE "  occurrences(insert?(y, x!1, 0) ^ (1, length(insert?(y, x!1, 0)) - 1))
                                                                                               (y) = occurrences(x!1)(y)") (("1" (REPLACES -1) NIL) ("2" (HIDE-ALL-BUT (1 4)) (("2" (GRIND) NIL))) ("3" (EXPAND "insert?" 1) (("3" (ASSERT) NIL))))))))) ("3" (EXPAND "finseq_appl") (("3" (EXPAND "insert?" 1) (("3" (PROPAX) NIL))))))))))))) ("2" (EXPAND "occurrences" 2 1) (("2" (LIFT-IF) (("2" (PROP) (("1" (EXPAND "insert?" -1) (("1" (ASSERT) NIL))) ("2" (EXPAND "finseq_appl") (("2" (EXPAND "insert?" -1) (("2" (ASSERT) NIL))))) ("3" (EXPAND "finseq_appl") (("3" (HIDE-ALL-BUT 2) (("3" (GRIND) NIL))))))))))))))))) ("2" (HIDE-ALL-BUT (1 2)) (("2" (MEASURE-INDUCT+ "length(v)" "v") (("1" (SKEEP) (("1" (SKEEP) (("1" (CASE "k!1=0") (("1" (REPLACES -1 1) NIL) ("2" (EXPAND "occurrences" 2 1) (("2" (EXPAND "finseq_appl") (("2" (CASE "insert?(y!1, x!2^(1, length(x!2)-1), k!1 -1) = insert?(y!1, x!2, k!1) ^ (1, length(insert?(y!1, x!2, k!1))-1)") (("1" (INST -2 "x!2^(1,length(x!2)-1)") (("1" (INST -2 "k!1 - 1") (("1" (SPLIT) (("1" (INST -1 "y!1" "x!3") (("1" (REPLACES -2) (("1" (LIFT-IF) (("1" (PROP) (("1" (HIDE-ALL-BUT -1) (("1" (EXPAND "insert?") (("1" (ASSERT) NIL))))) ("2" (REPLACES -2) (("2" (EXPAND "occurrences" 1 2) (("2" (EXPAND "finseq_appl") (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE-ALL-BUT -1) (("1" (EXPAND "insert?") (("1" (ASSERT) NIL))))) ("2" (CASE "insert?(y!1, x!2, 0) ^(1, length(insert?(y!1, x!2, 0)) - 1) = x!2") (("1" (REPLACES -1) (("1" (CASE "occurrences(insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0))(x!3) = 1 + occurrences(x!2^(1,length(x!2)-1))(x!3)") (("1" (REPLACES -1) (("1" (EXPAND "insert?" -2) (("1" (EXPAND "finseq_appl") (("1" (ASSERT) (("1" (EXPAND "occurrences" 1) (("1" (EXPAND "finseq_appl") (("1" (LIFT-IF) (("1" (PROP) (("1" (EXPAND "^" -1) (("1" (EXPAND "empty_seq") (("1" (EXPAND "min") (("1" (LIFT-IF) (("1" (PROP) (("1" (CASE "length(x!2) = 1") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "^") (("1" (EXPAND "occurrences") (("1" (EXPAND "empty_seq") (("1" (PROPAX) NIL))))))))))) ("2" (ASSERT) NIL))) ("2" (CASE "x!2`length = 1") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "^") (("1" (EXPAND "occurrences") (("1" (EXPAND "empty_seq") (("1" (PROPAX) NIL))))))))))) ("2" (ASSERT) NIL))) ("3" (ASSERT) NIL))))))))))) ("2" (EXPAND "^" -1) (("2" (LIFT-IF) (("2" (PROP) (("1" (CASE "length(x!2)=1") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "^") (("1" (EXPAND "empty_seq") (("1" (PROPAX) NIL))))))))) ("2" (ASSERT) NIL))) ("2" (ASSERT) (("2" (CASE "length(x!2)=1") (("1" (REPLACES -1) (("1" (ASSERT) (("1" (EXPAND "^") (("1" (EXPAND "empty_seq") (("1" (PROPAX) NIL))))))))) ("2" (ASSERT) NIL))))) ("3" (EXPAND "insert?") (("3" (EXPAND "occurrences" 3 2) (("3" (EXPAND "finseq_appl") (("3" (LIFT-IF) (("3" (PROP) (("3" (ASSERT) (("3" (EXPAND "^") (("3" (PROPAX) NIL))))))))))))))))))))) ("3" (EXPAND "occurrences" 2 2) (("3" (EXPAND "finseq_appl") (("3" (ASSERT) NIL))))))))))))))))))))) ("2" (HIDE 3 4) (("2" (EXPAND "insert?" -1) (("2" (EXPAND "insert?" -2) (("2" (EXPAND "finseq_appl") (("2" (ASSERT) (("2" (EXPAND "occurrences" 1 1) (("2" (EXPAND "finseq_appl") (("2" (LIFT-IF) (("2" (PROP) (("1" (EXPAND "insert?") (("1" (ASSERT) NIL))) ("2" (CASE "insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0) ^
                                                                                      (1,
                                                                                       length(insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0)) -
                                                                                        1) = x!2 ^ (1, length(x!2) - 1)") (("1" (REPLACES -1) NIL) ("2" (HIDE -1 -2 -3 2 4 3 5) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL) ("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL) ("2" (GRIND) NIL))) ("3" (GRIND) NIL))))) ("3" (HIDE-ALL-BUT (1 6)) (("3" (EXPAND "insert?") (("3" (EXPAND "^") (("3" (LIFT-IF) (("3" (PROP) (("1" (ASSERT) NIL) ("2" (ASSERT) NIL) ("3" (EXPAND "min") (("3" (ASSERT) NIL))))))))))))))) ("3" (EXPAND "insert?") (("3" (PROPAX) NIL))))))))))))))))))))))))) ("2" (EXPAND "^" 1) (("2" (LIFT-IF) (("2" (PROP) (("1" (EXPAND "insert?" -1) (("1" (ASSERT) NIL))) ("2" (EXPAND "insert?" -1) (("2" (ASSERT) NIL))) ("3" (HIDE-ALL-BUT (3 8)) (("3" (DECOMPOSE-EQUALITY) (("1" (EXPAND "min") (("1" (EXPAND "insert?") (("1" (PROPAX) NIL))))) ("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL) ("2" (GRIND) NIL) ("3" (GRIND) NIL))) ("3" (GRIND) NIL) ("4" (GRIND) NIL))))))))))) ("3" (HIDE-ALL-BUT 1) (("3" (EXPAND "insert?") (("3" (ASSERT) NIL))))))) ("3" (CASE "occurrences(insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0))(x!3) =
                                                             occurrences(x!2 ^ (1, length(x!2) - 1))(x!3)") (("1" (REPLACES -1) (("1" (CASE "insert?(y!1, x!2, 0) ^
                                                                              (1, length(insert?(y!1, x!2, 0)) - 1) =  x!2") (("1" (REPLACES -1) (("1" (EXPAND "insert?" -1) (("1" (EXPAND "finseq_appl") (("1" (ASSERT) (("1" (EXPAND "occurrences" 2 2) (("1" (EXPAND "finseq_appl") (("1" (PROPAX) NIL))))))))))))) ("2" (DECOMPOSE-EQUALITY) (("1" (HIDE-ALL-BUT 1) (("1" (GRIND) NIL))) ("2" (DECOMPOSE-EQUALITY) (("2" (HIDE 3) (("2" (GRIND) NIL))))))) ("3" (ASSERT) NIL))))) ("2" (HIDE-ALL-BUT (1 2 -1 7)) (("2" (EXPAND "occurrences" 1 1) (("2" (EXPAND "finseq_appl") (("2" (LIFT-IF) (("2" (PROP) (("1" (HIDE-ALL-BUT -1) (("1" (EXPAND "insert?") (("1" (EXPAND "^") (("1" (GRIND) NIL))))))) ("2" (GRIND) NIL) ("3" (CASE "insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0) ^  (1,
                                                                                  length(insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0)) -
                                                                                   1) = x!2 ^ (1, length(x!2) - 1)") (("1" (REPLACES -1) NIL) ("2" (REPLACES -1) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (GRIND) NIL))))))) ("3" (GRIND) NIL))))))))))))))))))))))))) ("3" (ASSERT) (("3" (REPLACES -1) (("3" (EXPAND "occurrences" 2 2) (("3" (EXPAND "finseq_appl") (("3" (LIFT-IF) (("3" (PROP) (("1" (EXPAND "insert?") (("1" (PROPAX) NIL))) ("2" (CASE "insert?(y!1, x!2, 0) ^
                                                                           (1, length(insert?(y!1, x!2, 0)) - 1) = x!2") (("1" (REPLACES -1) (("1" (EXPAND "occurrences" 1 1) (("1" (LIFT-IF) (("1" (PROP) (("1" (EXPAND "insert?") (("1" (EXPAND "^") (("1" (LIFT-IF) (("1" (PROP) (("1" (ASSERT) NIL) ("2" (ASSERT) NIL) ("3" (EXPAND "min") (("3" (ASSERT) NIL))))))))))) ("2" (EXPAND "finseq_appl") (("2" (CASE "insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0) ^
                                                                                  (1,
                                                                                   length(insert?(y!1, x!2 ^ (1, length(x!2) - 1), 0)) -
                                                                                    1) = x!2^(1,length(x!2)-1)") (("1" (REPLACES -1) (("1" (EXPAND "occurrences" 1 2) (("1" (EXPAND "finseq_appl") (("1" (ASSERT) (("1" (LIFT-IF) (("1" (PROP) (("1" (EXPAND "insert?") (("1" (EXPAND "finseq_appl") (("1" (PROPAX) NIL))))))))))))))))) ("2" (HIDE-ALL-BUT (1 8)) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL) ("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL) ("2" (GRIND) NIL))) ("3" (GRIND) NIL))))) ("3" (GRIND) NIL))))) ("3" (GRIND) NIL))))))))) ("2" (HIDE-ALL-BUT (1 7)) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL) ("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL) ("2" (GRIND) NIL))) ("3" (GRIND) NIL))))) ("3" (ASSERT) NIL))) ("3" (EXPAND "occurrences" 2 1) (("3" (LIFT-IF) (("3" (PROP) (("1" (EXPAND "insert?") (("1" (EXPAND "^") (("1" (EXPAND "finseq_appl") (("1" (LIFT-IF) (("1" (PROP) (("1" (ASSERT) NIL) ("2" (ASSERT) NIL) ("3" (EXPAND "min") (("3" (ASSERT) NIL))))))))))))) ("2" (EXPAND "finseq_appl") (("2" (EXPAND "insert?") (("2" (PROPAX) NIL))))) ("3" (EXPAND "finseq_appl") (("3" (GRIND) NIL))))))))))))))))))))))))))))) ("2" (GRIND) NIL))) ("2" (ASSERT) NIL))) ("2" (ASSERT) NIL))) ("2" (HIDE -1 3) (("2" (CASE "length(x!2)>=2") (("1" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL) ("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL) ("2" (GRIND) NIL))) ("3" (GRIND) NIL))) ("2" (DECOMPOSE-EQUALITY 2) (("1" (GRIND) NIL) ("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL) ("2" (GRIND) NIL))) ("3" (GRIND) NIL))))))) ("3" (EXPAND "insert?" 1) (("3" (ASSERT) NIL))) ("4" (SPLIT) (("1" (ASSERT) NIL) ("2" (EXPAND "^" 1) (("2" (EXPAND "min") (("2" (LIFT-IF 1) (("2" (PROP) (("1" (EXPAND "empty_seq") (("1" (ASSERT) NIL))) ("2" (EXPAND "empty_seq") (("2" (ASSERT) NIL))) ("3" (ASSERT) NIL))))))))))) ("5" (ASSERT) NIL))))))))))))) ("2" (ASSERT) NIL) ("3" (ASSERT) NIL))))) ("3" (SKEEP) (("3" (ASSERT) NIL)))))))))) NIL) NIL NIL)) (|occ_in_delete| 0 (|occ_in_delete-1| |nil| 3779122757 ("" (MEASURE-INDUCT+ "length(v)" "v") (("" (SKEEP) (("" (SKEEP) (("" (CASE "length(x!1) = 0") (("1" (HIDE -2) (("1" (TYPEPRED "i") (("1" (ASSERT) NIL NIL)) NIL)) NIL) ("2" (CASE "length(x!1) = 1") (("1" (HIDE -2) (("1" (GRIND) NIL NIL)) NIL) ("2" (HIDE 1 2) (("2" (CASE "i=0") (("1" (REPLACES -1) (("1" (EXPAND "finseq_appl") (("1" (EXPAND "delete" 1) (("1" (PROP) (("1" (EXPAND "finseq_appl") (("1" (CASE "(# length := x!1`length-1,
                                                                                                   seq := LAMBDA (i: below[x!1`length - 1]):
                                                                                                         x!1`seq(1 + i) #) = x!1^(1,x!1`length-1)") (("1" (REPLACES -1) (("1" (EXPAND "occurrences" 1 2) (("1" (EXPAND "finseq_appl") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (DECOMPOSE-EQUALITY) (("1" (EXPAND "^") (("1" (EXPAND "min") (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED "x!2") (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "finseq_appl") (("2" (CASE "(# length := x!1`length - 1,
                                                                                                   seq := LAMBDA (i: below[x!1`length - 1]):
                                                                                                          x!1`seq(1 + i) #) = x!1^(1,length(x!1)-1)") (("1" (REPLACES -1) (("1" (EXPAND "occurrences" 2 2) (("1" (EXPAND "finseq_appl") (("1" (ASSERT) NIL NIL)) NIL)) NIL)) NIL) ("2" (HIDE-ALL-BUT 1) (("2" (DECOMPOSE-EQUALITY) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (SKEEP) (("3" (TYPEPRED "x!2") (("3" (EXPAND "^") (("3" (EXPAND "min") (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (EXPAND "finseq_appl") (("2" (INST -1 "x!1^(1,length(x!1)-1)") (("2" (INST -1 "x") (("2" (SPLIT) (("1" (INST -1 "i-1") (("1" (CASE "delete(x!1 ^ (1, length(x!1) - 1), i - 1) = delete(x!1, i)^(1,length(delete(x!1,i))-1)") (("1" (REPLACES -1) (("1" (PROP) (("1" (EXPAND "occurrences" 1 1) (("1" (EXPAND "delete" 1 1) (("1" (EXPAND "finseq_appl") (("1" (LIFT-IF) (("1" (PROP) (("1" (REVEAL 1 2) (("1" (ASSERT) NIL NIL)) NIL) ("2" (EXPAND "occurrences" 1 2) (("2" (LIFT-IF) (("2" (EXPAND "finseq_appl") (("2" (PROP) (("1" (ASSERT) NIL NIL) ("2" (HIDE-ALL-BUT (-1 1 4)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("3" (EXPAND "occurrences" 2 2) (("3" (LIFT-IF) (("3" (PROP) (("3" (EXPAND "finseq_appl") (("3" (HIDE-ALL-BUT (-1 2 4)) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE -2 2) (("2" (GRIND) NIL NIL)) NIL) ("3" (EXPAND "occurrences" 1 1) (("3" (LIFT-IF) (("3" (PROP) (("1" (REVEAL 1 2) (("1" (HIDE-ALL-BUT (-1 1 5)) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (EXPAND "finseq_appl") (("2" (HIDE-ALL-BUT (-2 3 4)) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (EXPAND "finseq_appl") (("3" (HIDE-ALL-BUT (-1 4 5)) (("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("4" (EXPAND "occurrences" 2) (("4" (LIFT-IF) (("4" (EXPAND "finseq_appl") (("4" (LIFT-IF) (("4" (PROP) (("1" (REVEAL 1 2) (("1" (HIDE-ALL-BUT (-2 1 2)) (("1" (GRIND) NIL NIL)) NIL)) NIL) ("2" (REVEAL 1 2) (("2" (HIDE-ALL-BUT (-1 1 2)) (("2" (GRIND) NIL NIL)) NIL)) NIL) ("3" (LIFT-IF) (("3" (PROP) (("1" (ASSERT) NIL NIL) ("2" (HIDE-ALL-BUT (-1 1 6)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("4" (LIFT-IF) (("4" (PROP) (("4" (HIDE-ALL-BUT (-1 2 6)) (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ("2" (HIDE -1 3) (("2" (REVEAL 2 3) (("2" (DECOMPOSE-EQUALITY 3) (("1" (GRIND) NIL NIL) ("2" (DECOMPOSE-EQUALITY 1) (("1" (TYPEPRED "x!2") (("1" (GRIND) NIL NIL)) NIL) ("2" (GRIND) NIL NIL)) NIL) ("3" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("3" (REVEAL 1 2) (("3" (HIDE-ALL-BUT (1 2 3 4)) (("3" (GRIND) NIL NIL)) NIL)) NIL) ("4" (REVEAL 1 2) (("4" (HIDE-ALL-BUT (1 2 3 4)) (("4" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (REVEAL 1 2) (("2" (HIDE-ALL-BUT (1 2 3 4)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL) ("2" (REVEAL 1 2) (("2" (HIDE-ALL-BUT (1 2 3 4)) (("2" (GRIND) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((NOT CONST-DECL "[bool -> bool]" |booleans| NIL) (|real_lt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|i| SKOLEM-CONST-DECL "below[length(x!1)]" |sorting_seq| NIL) (|x!1| SKOLEM-CONST-DECL "finite_sequence[T]" |sorting_seq| NIL) (AND CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (TRUE CONST-DECL "bool" |booleans| NIL) (|odd_minus_odd_is_even| APPLICATION-JUDGEMENT "even_int" |integers| NIL) (|even_minus_odd_is_odd| APPLICATION-JUDGEMENT "odd_int" |integers| NIL) (|int_plus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|min| CONST-DECL "{p: real | p <= m AND p <= n}" |real_defs| NIL) (IFF CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (+ CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|nnint_plus_posint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|int_min| APPLICATION-JUDGEMENT "{k: int | k <= i AND k <= j}" |real_defs| NIL) (|real_gt_is_strict_total_order| NAME-JUDGEMENT "(strict_total_order?[real])" |real_props| NIL) (|real_ge_is_total_order| NAME-JUDGEMENT "(total_order?[real])" |real_props| NIL) (^ CONST-DECL "finseq" |finite_sequences| NIL) (|empty_seq| CONST-DECL "finseq" |finite_sequences| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (IMPLIES CONST-DECL "[bool, bool -> bool]" |booleans| NIL) (IF CONST-DECL "[boolean, T, T -> T]" |if_def| NIL) (= CONST-DECL "[T, T -> boolean]" |equalities| NIL) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|occurrences| DEF-DECL "nat" |sorting_seq| NIL) (|delete| CONST-DECL "finseq" |seq_extras| |structures|) (|numfield| NONEMPTY-TYPE-EQ-DECL NIL |number_fields| NIL) (- CONST-DECL "[numfield, numfield -> numfield]" |number_fields| NIL) (|wf_nat| FORMULA-DECL NIL |naturalnumbers| NIL) (< CONST-DECL "bool" |reals| NIL) (|naturalnumber| TYPE-EQ-DECL NIL |naturalnumbers| NIL) (>= CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|measure_induction| FORMULA-DECL NIL |measure_induction| NIL) (|well_founded?| CONST-DECL "bool" |orders| NIL) (|pred| TYPE-EQ-DECL NIL |defined_types| NIL)) NIL)) (|delete_insert_same_permutes_TCC1| 0 (|delete_insert_same_permutes_TCC1-1| |nil| 3779122592 ("" (SUBTYPE-TCC) NIL NIL) ((|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|delete| CONST-DECL "finseq" |seq_extras| |structures|) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL)) NIL (|delete_insert_same_permutes| SUBTYPE "sorting_seq.j" "upto[length(delete[T](v, i))]"))) (|delete_insert_same_permutes| 0 (|delete_insert_same_permutes-1| |nil| 3779122814 ("" (SKEEP) (("" (SKEEP) (("" (EXPAND "permutations") (("" (SKEEP) (("" (LEMMA "occ_in_delete") (("" (LEMMA "occ_in_insert") (("" (INST -2 "v" "x" "i") (("" (PROP) (("1" (INST -3 "delete(v,i)" "x" "finseq_appl[T](v)(i)" "j") (("1" (ASSERT) NIL NIL)) NIL) ("2" (INST -2 "delete(v,i)" "x" "finseq_appl[T](v)(i)" "j") (("2" (ASSERT) NIL NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL)) NIL) ((|occ_in_insert| FORMULA-DECL NIL |sorting_seq| NIL) (|posint_plus_nnint_is_posint| APPLICATION-JUDGEMENT "posint" |integers| NIL) (|minus_nzint_is_nzint| APPLICATION-JUDGEMENT "nzint" |integers| NIL) (|int_minus_int_is_int| APPLICATION-JUDGEMENT "int" |integers| NIL) (|upto| NONEMPTY-TYPE-EQ-DECL NIL |nat_types| NIL) (<= CONST-DECL "bool" |reals| NIL) (|finseq_appl| CONST-DECL "[below[length(fs)] -> T]" |finite_sequences| NIL) (|delete| CONST-DECL "finseq" |seq_extras| |structures|) (|finseq| TYPE-EQ-DECL NIL |finite_sequences| NIL) (< CONST-DECL "bool" |reals| NIL) (>= CONST-DECL "bool" |reals| NIL) (|int| NONEMPTY-TYPE-EQ-DECL NIL |integers| NIL) (|integer_pred| CONST-DECL "[rational -> boolean]" |integers| NIL) (|rational| NONEMPTY-TYPE-FROM-DECL NIL |rationals| NIL) (|rational_pred| CONST-DECL "[real -> boolean]" |rationals| NIL) (> CONST-DECL "bool" |reals| NIL) (|bool| NONEMPTY-TYPE-EQ-DECL NIL |booleans| NIL) (|real| NONEMPTY-TYPE-FROM-DECL NIL |reals| NIL) (|real_pred| CONST-DECL "[number_field -> boolean]" |reals| NIL) (|number_field| NONEMPTY-TYPE-FROM-DECL NIL |number_fields| NIL) (|number_field_pred| CONST-DECL "[number -> boolean]" |number_fields| NIL) (|boolean| NONEMPTY-TYPE-DECL NIL |booleans| NIL) (|number| NONEMPTY-TYPE-DECL NIL |numbers| NIL) (|finite_sequence| TYPE-EQ-DECL NIL |finite_sequences| NIL) (T FORMAL-TYPE-DECL NIL |sorting_seq| NIL) (|below| TYPE-EQ-DECL NIL |nat_types| NIL) (|nat| NONEMPTY-TYPE-EQ-DECL NIL |naturalnumbers| NIL) (|occ_in_delete| FORMULA-DECL NIL |sorting_seq| NIL) (|permutations| CONST-DECL "bool" |sorting_seq| NIL)) NIL)))
