basic_ops[base: above(1), (importing fixed_point_format[base]) format: fixed_point_format, round: [real -> int]]
		: THEORY
BEGIN

  importing basic_defs[base, format, round]

  add_fxp(a,b: fixed_point)
  : fixed_point
  = let result: int = a`representation + b`representation 
    in  if -format`max <= result <= format`max
        then make_fixed_point(result)
	else max_fxp endif

  sub_fxp(a,b: fixed_point)
  : fixed_point
  = let result: int = a`representation - b`representation 
    in  if -format`max <= result <= format`max
        then make_fixed_point(result)
	else max_fxp endif

  mul_fxp(a,b: fixed_point)
  : fixed_point
  = let result: int
        = round(a`representation * b`representation * base^(-format`scaling_factor))
    in  if result > format`max then max_fxp
    	elsif result < -format`max then min_fxp
	else make_fixed_point(result) endif

END basic_ops
