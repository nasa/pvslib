(list_lemmas
 (every_reverse 0
  (every_reverse-1 nil 3810908539
   ("" (lemma "every_nth[T]")
    (("" (lemma "nth_reverse[T]")
      (("" (induct "l")
        (("1" (skeep)
          (("1" (expand reverse 1) (("1" (propax) nil nil)) nil)) nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (expand reverse 1)
              (("2" (inst -1 "P")
                (("2" (expand every -2)
                  (("2" (flatten -2)
                    (("2" (assert)
                      (("2" (inst -5 "P" "cons(cons1_var, null)")
                        (("2" (hide -4)
                          (("2" (grind)
                            (("2" (lemma "every_append[T]")
                              (("2"
                                (inst
                                 -1
                                 "P"
                                 "reverse(cons2_var)"
                                 "cons(cons1_var, null)")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nth_reverse formula-decl nil list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (every_append formula-decl nil list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (reverse def-decl "list[T]" list_props nil) nil
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (every_nth formula-decl nil list_props nil)
    (T formal-type-decl nil list_lemmas nil))
   shostak))
 (max_length_TCC1 0
  (max_length_TCC1-1 nil 3810907533
   ("" (skeep) (("" (assert) nil nil)) nil) nil nil
   (max_length subtype "list_lemmas.L"
    "(list_adt[list_adt[list_lemmas.T].list].cons?)")))
 (max_length_TCC2 0
  (max_length_TCC2-1 nil 3810907533
   ("" (skeep) (("" (expand length 2 2) (("" (assert) nil nil)) nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil
   (max_length termination
    "list_lemmas.max_length(list_adt[list_adt[list_lemmas.T].list].cdr(list_lemmas.L))"
    "nil")))
 (zip_TCC1 0
  (zip_TCC1-1 nil 3810907533 ("" (skeep) (("" (assert) nil nil)) nil)
   nil nil
   (zip subtype "list_lemmas.l1" "(list_adt[list_lemmas.T].cons?)")))
 (zip_TCC2 0
  (zip_TCC2-1 nil 3810907533
   ("" (skeep)
    (("" (assert)
      (("" (typepred "l2")
        (("" (expand length -1) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (T formal-type-decl nil list_lemmas nil)
    (list type-decl nil list_adt nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil))
   nil
   (zip subtype "list_lemmas.l2" "(list_adt[list_lemmas.T].cons?)")))
 (zip_TCC3 0
  (zip_TCC3-1 nil 3810907533
   ("" (skeep)
    (("" (typepred "l2")
      (("" (expand length -1)
        (("" (assert)
          (("" (lift-if -1)
            (("" (split -1)
              (("1" (flatten) (("1" (assert) nil nil)) nil)
               ("2" (flatten) (("2" (assert) nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil list_lemmas nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (zip subtype "list_adt[list_lemmas.T].cdr(list_lemmas.l2)"
    "{ll: list_adt[list_lemmas.T].list | list_props[list_lemmas.T].length(ll) = list_props[list_lemmas.T].length(list_adt[list_lemmas.T].cdr(list_lemmas.l1))}")))
 (zip_TCC4 0
  (zip_TCC4-1 nil 3810907533
   ("" (skeep) (("" (expand length 2 2) (("" (assert) nil nil)) nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   nil
   (zip termination
    "list_lemmas.zip(list_adt[list_lemmas.T].cdr(list_lemmas.l1), list_adt[list_lemmas.T].cdr(list_lemmas.l2))"
    "nil")))
 (combo_list_TCC1 0
  (combo_list_TCC1-1 nil 3810907533
   ("" (skeep)
    (("" (lemma "length_appendn[T]")
      (("" (inst?)
        (("" (replace -1)
          (("" (lemma "length_appendn[T]")
            (("" (inst -1 "l1" "length(l2)")
              (("" (replace -1) (("" (assert) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil list_lemmas nil)
    (length_appendn formula-decl nil more_list_props structures)
    (nnint_times_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length def-decl "nat" list_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (list type-decl nil list_adt nil))
   nil
   (combo_list subtype
    "more_list_props[list_lemmas.T].^(list_lemmas.l2, list_props[list_lemmas.T].length(list_lemmas.l1))"
    "{ll: list_adt[list_lemmas.T].list | list_props[list_lemmas.T].length(ll) = list_props[list_lemmas.T].length(more_list_props[list_lemmas.T].^(list_lemmas.l1, list_props[list_lemmas.T].length(list_lemmas.l2)))}")))
 (append_left_inj 0
  (append_left_inj-1 nil 3810908541
   ("" (skeep)
    (("" (lemma "list_extensionality[T]")
      (("" (lemma "nth_append_below[T]")
        (("" (lemma "length_append[T]")
          (("" (inst? -1)
            (("" (replace -4)
              (("" (lemma "length_append[T]")
                (("" (inst -1 "l2" "l")
                  (("" (replace -1)
                    (("" (hide -1)
                      (("" (assert)
                        (("" (inst -3 "l1" "l2")
                          (("" (flatten -3)
                            (("" (hide -3)
                              ((""
                                (assert)
                                ((""
                                  (skeep)
                                  ((""
                                    (inst -2 "n" "l1" "l")
                                    ((""
                                      (typepred "n")
                                      ((""
                                        (assert)
                                        ((""
                                          (hide -1)
                                          ((""
                                            (lemma
                                             "nth_append_below[T]")
                                            ((""
                                              (inst -1 "n" "l2" "l")
                                              (("" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil list_lemmas nil)
    (list_extensionality formula-decl nil more_list_props structures)
    (length_append formula-decl nil list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (list type-decl nil list_adt nil)
    (nth_append_below formula-decl nil more_list_props structures))
   shostak))
 (caret_swap 0
  (caret_swap-1 nil 3811087739
   ("" (induct "n")
    (("1" (expand "^")
      (("1" (expand "^")
        (("1" (skeep)
          (("1" (rewrite "append_null_right")
            (("1" (expand "append") (("1" (propax) nil nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand "^" 1 1)
          (("2" (inst?)
            (("2" (expand "^" 1 2)
              (("2" (replace -1)
                (("2" (rewrite "append_assoc") nil nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((append_assoc formula-decl nil list_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (append_null_right formula-decl nil more_list_props structures)
    (nat_induction formula-decl nil naturalnumbers nil)
    (append def-decl "list[T]" list_props nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil) nil
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil list_lemmas nil)
    (pred type-eq-decl nil defined_types nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (caret_to_append_TCC1 0
  (caret_to_append_TCC1-1 nil 3811086967 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil
   (caret_to_append subtype
    "((number_fields.-)(list_lemmas.m, list_lemmas.n))" "nat")))
 (caret_to_append 0
  (caret_to_append-1 nil 3811086968
   (""
    (case "FORALL (l: list[T], m, n, k: nat):
        m > n AND k = m-n IMPLIES l ^ m = append(l ^ n, l ^ (m - n))")
    (("1" (skeep)
      (("1" (inst?)
        (("1" (inst -1 "m-n")
          (("1" (assert) nil nil) ("2" (assert) nil nil)) nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (induct "k")
        (("1" (skeep) (("1" (assert) nil nil)) nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (case "j=0")
              (("1" (replace -1)
                (("1" (move-terms -4 r 2)
                  (("1" (replace -4 :dir rl)
                    (("1" (assert)
                      (("1" (rewrite "caret_swap")
                        (("1" (expand "^" 1 3)
                          (("1" (expand "^" 1 3)
                            (("1" (rewrite "append_null_right") nil
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (move-terms -3 l 2)
                (("2" (inst -1 "l" "m-1" "n")
                  (("1" (assert)
                    (("1" (expand "^" 2 3)
                      (("1" (rewrite "append_assoc" 2 :dir rl)
                        (("1" (rewrite "caret_swap" 2 :dir rl)
                          (("1" (expand "^" 2 2)
                            (("1" (rewrite "append_assoc" 2)
                              (("1"
                                (replace -1 :dir rl)
                                (("1"
                                  (expand "^" 2 1)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (assert) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (skeep) (("3" (assert) nil nil)) nil))
        nil))
      nil)
     ("3" (skeep) (("3" (assert) nil nil)) nil))
    nil)
   ((+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (even_plus_odd_is_odd application-judgement "odd_int" integers nil)
    (append_null_right formula-decl nil more_list_props structures)
    (odd_plus_even_is_odd application-judgement "odd_int" integers nil)
    (odd_minus_odd_is_even application-judgement "even_int" integers
     nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (odd_plus_odd_is_even application-judgement "even_int" integers
     nil)
    (even_minus_odd_is_odd application-judgement "odd_int" integers
     nil)
    (caret_swap formula-decl nil list_lemmas nil) nil
    (append_assoc formula-decl nil list_props nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil nil
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (T formal-type-decl nil list_lemmas nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (> const-decl "bool" reals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil (append def-decl "list[T]" list_props nil))
   shostak))
 (append_carat 0
  (append_carat-1 nil 3810908543
   ("" (skeep)
    (("" (lemma "caret_to_append")
      (("" (case "n=0")
        (("1" (replace -1)
          (("1" (assert)
            (("1" (expand "^" -4 1)
              (("1" (rewrite "append_null_right") nil nil)) nil))
            nil))
          nil)
         ("2" (inst -1 "(: w :)" "m" "m-n")
          (("1" (assert)
            (("1" (replace -1)
              (("1" (rewrite "append_assoc" -3 :dir rl)
                (("1" (lemma "append_left_inj")
                  (("1" (inst?) (("1" (assert) nil nil)) nil)) nil))
                nil))
              nil))
            nil)
           ("2" (assert) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((caret_to_append formula-decl nil list_lemmas nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (append_left_inj formula-decl nil list_lemmas nil)
    (append def-decl "list[T]" list_props nil)
    (append_assoc formula-decl nil list_props nil) nil
    (append_null_right formula-decl nil more_list_props structures)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil list_lemmas nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil))
   shostak))
 (append_list 0
  (append_list-1 nil 3813415663
   ("" (skeep)
    (("" (lemma "list_extensionality[T]")
      (("" (inst -1 "l1" "l3")
        (("" (assert)
          (("" (skeep)
            (("" (hide 2)
              (("" (lemma "nth_append[T]")
                (("" (inst-cp -1 "l1" "l2" "n")
                  (("" (inst -1 "l3" "l4" "n")
                    (("" (assert)
                      (("" (lemma "list_extensionality[T]")
                        (("" (inst?)
                          (("" (flatten)
                            (("" (hide -2)
                              ((""
                                (split -1)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (inst -2 "n")
                                    (("1" (assert) nil nil)
                                     ("2"
                                      (typepred "n")
                                      (("2"
                                        (lemma "length_append[T]")
                                        (("2"
                                          (inst?)
                                          (("2" (assert) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2" (propax) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil list_lemmas nil)
    (list_extensionality formula-decl nil more_list_props structures)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (append def-decl "list[T]" list_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (length_append formula-decl nil list_props nil) nil nil nil
    (nth_append formula-decl nil more_list_props structures)
    (list type-decl nil list_adt nil))
   shostak))
 (add_lists_TCC1 0
  (add_lists_TCC1-1 nil 3810907533
   ("" (skeep) (("" (assert) nil nil)) nil) nil nil
   (add_lists subtype "list_lemmas.l1" "(list_adt[nat].cons?)")))
 (add_lists_TCC2 0
  (add_lists_TCC2-1 nil 3810907533
   ("" (skeep) (("" (assert) nil nil)) nil) nil nil
   (add_lists subtype "list_lemmas.l2" "(list_adt[nat].cons?)")))
 (add_lists_TCC3 0
  (add_lists_TCC3-1 nil 3810907533
   ("" (skeep)
    (("" (expand length 3 3)
      (("" (assert)
        (("" (expand length 3 4) (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   nil
   (add_lists termination
              "list_lemmas.add_lists(list_adt[nat].cdr(list_lemmas.l1), list_adt[nat].cdr(list_lemmas.l2))"
              "nil")))
 (add_lists_length 0
  (add_lists_length-1 nil 3882462317
   ("" (induct "l1")
    (("1" (skeep) (("1" (grind) nil nil)) nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand "add_lists" 1)
          (("2" (lift-if 1)
            (("2" (split 1)
              (("1" (flatten) (("1" (grind) nil nil)) nil)
               ("2" (flatten)
                (("2" (inst -1 "cdr(l2)")
                  (("2" (expand "length" 2 1) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (add_lists def-decl "list[nat]" list_lemmas nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   shostak))
 (add_list_nth_TCC1 0
  (add_list_nth_TCC1-1 nil 3859279826 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (length def-decl "nat" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (add_list_nth subtype "list_lemmas.n" "below[length[nat](l1)]")))
 (add_list_nth_TCC2 0
  (add_list_nth_TCC2-1 nil 3859279826 ("" (subtype-tcc) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (length def-decl "nat" list_props nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (add_list_nth subtype "list_lemmas.n" "below[length[nat](l2)]")))
 (add_list_nth_TCC3 0
  (add_list_nth_TCC3-1 nil 3859279826
   ("" (skeep)
    (("" (lemma "add_lists_length")
      (("" (inst?) (("" (typepred "n") (("" (assert) nil nil)) nil))
        nil))
      nil))
    nil)
   ((add_lists_length formula-decl nil list_lemmas nil)
    (length def-decl "nat" list_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (<= const-decl "bool" reals nil) (< const-decl "bool" reals nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (add_list_nth subtype "list_lemmas.n"
    "below[length[nat](add_lists(l1, l2))]")))
 (add_list_nth 0
  (add_list_nth-1 nil 3859279833
   (""
    (case "FORALL (a,b:nat, l1, l2: list[nat], n: nat | n < min(length(l1), length(l2))): length(l1)=a AND length(l2)=b IMPLIES nth(l1, n) + nth(l2, n) = nth(add_lists(l1, l2), n)")
    (("1" (skeep)
      (("1" (inst?) (("1" (inst -1 "length(l1)" "length(l2)") nil nil))
        nil))
      nil)
     ("2" (hide 2)
      (("2" (induct a)
        (("1" (skeep)
          (("1" (typepred n)
            (("1" (expand min) (("1" (assert) nil nil)) nil)) nil))
          nil)
         ("2" (skeep)
          (("2" (skeep)
            (("2" (expand add_lists 1)
              (("2" (assert)
                (("2" (lift-if 1)
                  (("2" (assert)
                    (("2" (split 1)
                      (("1" (flatten)
                        (("1" (expand length -3)
                          (("1" (assert) nil nil)) nil))
                        nil)
                       ("2" (flatten)
                        (("2" (split 2)
                          (("1" (flatten)
                            (("1" (typepred n)
                              (("1"
                                (expand min)
                                (("1"
                                  (assert)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil)
                           ("2" (flatten)
                            (("2" (case "n = 0")
                              (("1"
                                (replace -1)
                                (("1"
                                  (expand nth 2)
                                  (("1" (propax) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (expand nth 3)
                                (("2"
                                  (assert)
                                  (("2"
                                    (inst
                                     -1
                                     "b-1"
                                     "cdr(l1)"
                                     "cdr(l2)"
                                     "n-1")
                                    (("1"
                                      (expand length -2)
                                      (("1"
                                        (expand length -3)
                                        (("1" (assert) nil nil))
                                        nil))
                                      nil)
                                     ("2"
                                      (typepred n)
                                      (("2"
                                        (expand length -1)
                                        (("2"
                                          (expand min)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil)
                                     ("3"
                                      (expand length -2)
                                      (("3" (assert) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("3" (hide 2)
          (("3" (induct a)
            (("1" (skeep)
              (("1" (typepred n) (("1" (grind) nil nil)) nil)) nil)
             ("2" (skeep)
              (("2" (skeep)
                (("2" (typepred n)
                  (("2" (expand add_lists 1)
                    (("2" (assert)
                      (("2" (lift-if 1)
                        (("2" (assert)
                          (("2" (split 1)
                            (("1" (propax) nil nil)
                             ("2" (flatten)
                              (("2"
                                (split 2)
                                (("1" (propax) nil nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (expand length 2)
                                    (("2"
                                      (expand length -3)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (expand length -4)
                                          (("2"
                                            (inst
                                             -2
                                             "b-1"
                                             "cdr(l1)"
                                             "cdr(l2)"
                                             "n-1")
                                            (("1" (assert) nil nil)
                                             ("2"
                                              (expand length -1)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("4" (assert)
          (("4" (skeep)
            (("4" (typepred n) (("4" (grind) nil nil)) nil)) nil))
          nil)
         ("5" (skeep) (("5" (typepred n) (("5" (grind) nil nil)) nil))
          nil))
        nil))
      nil)
     ("3" (induct a)
      (("1" (skeep) (("1" (typepred n) (("1" (grind) nil nil)) nil))
        nil)
       ("2" (skeep)
        (("2" (hide 2)
          (("2" (skeep)
            (("2" (expand add_lists 1)
              (("2" (lift-if)
                (("2" (split 1)
                  (("1" (flatten)
                    (("1" (expand length -3) (("1" (assert) nil nil))
                      nil))
                    nil)
                   ("2" (flatten)
                    (("2" (split 2)
                      (("1" (flatten)
                        (("1" (typepred n) (("1" (grind) nil nil))
                          nil))
                        nil)
                       ("2" (flatten)
                        (("2" (expand length 2)
                          (("2"
                            (inst -1 "b-1" "cdr(l1)" "cdr(l2)" "n-1")
                            (("1" (assert)
                              (("1"
                                (expand length -1)
                                (("1"
                                  (expand length -2)
                                  (("1" (assert) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (typepred n)
                              (("2"
                                (expand length -1)
                                (("2"
                                  (assert)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil)
                             ("3" (expand length -2)
                              (("3" (assert) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skeep) (("4" (typepred n) (("4" (grind) nil nil)) nil)) nil)
     ("5" (skeep) (("5" (typepred n) (("5" (grind) nil nil)) nil))
      nil))
    nil)
   (nil nil nil nil
    (posint_min application-judgement "{k: posint | k <= i AND k <= j}"
     real_defs nil)
    nil nil nil
    (int_minus_int_is_int application-judgement "int" integers nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil) nil
    nil nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (pred type-eq-decl nil defined_types nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (< const-decl "bool" reals nil) (<= const-decl "bool" reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (length def-decl "nat" list_props nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (add_lists def-decl "list[nat]" list_lemmas nil))
   shostak))
 (list_length_n_TCC1 0
  (list_length_n_TCC1-1 nil 3810907533
   ("" (assert) (("" (skeep) (("" (assert) nil nil)) nil)) nil)
   ((real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil))
   nil
   (list_length_n subtype "((number_fields.-)(list_lemmas.n, 1))"
                  "nat")))
 (list_length_n_TCC2 0
  (list_length_n_TCC2-1 nil 3810907533
   ("" (skeep) (("" (assert) nil nil)) nil)
   ((int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (list_length_n termination
                  "list_lemmas.list_length_n((number_fields.-)(list_lemmas.n, 1))"
                  "nil")))
 (ex_list_n 0
  (ex_list_n-1 nil 3810908544 ("" (eval-formula) nil nil)
   ((boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil))
   shostak))
 (add_list_length 0
  (add_list_length-1 nil 3810908545
   ("" (induct "l1")
    (("1" (skeep)
      (("1" (expand "add_lists")
        (("1" (expand "length" 1 2)
          (("1" (assert)
            (("1" (expand "max")
              (("1" (assert)
                (("1" (lift-if 1)
                  (("1" (split 1)
                    (("1" (propax) nil nil)
                     ("2" (flatten) (("2" (assert) nil nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("2" (skeep)
      (("2" (induct "l2")
        (("1" (expand "add_lists" +)
          (("1" (expand "length" 1 3)
            (("1" (expand "max")
              (("1" (lift-if 1)
                (("1" (split 1)
                  (("1" (flatten) (("1" (assert) nil nil)) nil)
                   ("2" (propax) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil)
         ("2" (skeep)
          (("2" (expand "add_lists" 1)
            (("2" (inst -2 "cons2_var_1")
              (("2" (expand "length" +)
                (("2" (assert)
                  (("2" (hide -1)
                    (("2" (expand "max")
                      (("2" (lift-if 1)
                        (("2" (split 1)
                          (("1" (flatten) (("1" (assert) nil nil)) nil)
                           ("2" (flatten) (("2" (assert) nil nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((posrat_max application-judgement "{s: posrat | s >= q AND s >= r}"
     real_defs nil)
    (posint_max application-judgement "{k: posint | i <= k AND j <= k}"
     real_defs nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_max application-judgement "{k: int | i <= k AND j <= k}"
     real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}"
     real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (add_lists def-decl "list[nat]" list_lemmas nil)
    (length def-decl "nat" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil))
   shostak))
 (list_length_n 0
                (list_length_n-1 nil 3810908545
                 ("" (induct "n")
                  (("1" (expand "list_length_n")
                    (("1" (expand "length") (("1" (propax) nil nil))
                      nil))
                    nil)
                   ("2" (skeep)
                    (("2" (expand "list_length_n" +)
                      (("2" (expand "length" +)
                        (("2" (rewrite "add_list_length")
                          (("2" (rewrite "length_appendn")
                            (("2" (assert)
                              (("2"
                                (expand "max")
                                (("2" (assert) nil nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil)
                 ((length_appendn formula-decl nil more_list_props
                   structures)
                  (nnint_times_nnint_is_nnint application-judgement
                   "nonneg_int" integers nil)
                  (length_singleton formula-decl nil more_list_props
                   structures)
                  (max const-decl "{p: real | p >= m AND p >= n}"
                       real_defs nil)
                  (nat_max application-judgement
                   "{k: nat | i <= k AND j <= k}" real_defs nil)
                  (nonneg_rat_max application-judgement
                   "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
                  (cons adt-constructor-decl "[[T, list] -> (cons?)]"
                        list_adt nil)
                  (cons? adt-recognizer-decl "[list -> boolean]"
                   list_adt nil)
                  nil
                  (add_list_length formula-decl nil list_lemmas nil)
                  (nat_induction formula-decl nil naturalnumbers nil)
                  (list_length_n def-decl "list[nat]" list_lemmas nil)
                  (length def-decl "nat" list_props nil)
                  (AND const-decl "[bool, bool -> bool]" booleans nil)
                  nil (PRED type-eq-decl nil defined_types nil)
                  (list type-decl nil list_adt nil)
                  (= const-decl "[T, T -> boolean]" equalities nil)
                  (pred type-eq-decl nil defined_types nil)
                  (nat nonempty-type-eq-decl nil naturalnumbers nil)
                  (>= const-decl "bool" reals nil)
                  (bool nonempty-type-eq-decl nil booleans nil)
                  (int nonempty-type-eq-decl nil integers nil)
                  (integer_pred const-decl "[rational -> boolean]"
                                integers nil)
                  (rational nonempty-type-from-decl nil rationals nil)
                  (rational_pred const-decl "[real -> boolean]"
                                 rationals nil)
                  (real nonempty-type-from-decl nil reals nil)
                  (real_pred const-decl "[number_field -> boolean]"
                             reals nil)
                  (number_field nonempty-type-from-decl nil
                   number_fields nil)
                  (number_field_pred const-decl "[number -> boolean]"
                   number_fields nil)
                  (boolean nonempty-type-decl nil booleans nil)
                  (number nonempty-type-decl nil numbers nil))
                 shostak))
 (list_n_nth_TCC1 0
  (list_n_nth_TCC1-1 nil 3859278972
   ("" (skeep)
    (("" (lemma "list_length_n")
      (("" (inst?) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((list_length_n formula-decl nil list_lemmas nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number nonempty-type-decl nil numbers nil))
   nil
   (list_n_nth subtype "list_lemmas.i"
    "below[length[nat](list_length_n(n))]")))
 (list_n_nth 0
  (list_n_nth-1 nil 3859278972
   ("" (induct n)
    (("1" (skeep) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (typepred i)
          (("2" (expand list_length_n 1)
            (("2" (case i=0)
              (("1" (expand nth 1) (("1" (assert) nil nil)) nil)
               ("2" (expand nth 2)
                (("2" (assert)
                  (("2" (lemma "add_list_nth")
                    (("2" (inst?)
                      (("1" (inst -3 "i-1")
                        (("1" (replace -3)
                          (("1" (replace -1 2 rl)
                            (("1" (assert)
                              (("1"
                                (case
                                 "FORALL(i:nat,k:below(i)): nth((:1:)^i,k) = 1")
                                (("1"
                                  (inst -1 "j" "i-1")
                                  (("1" (assert) nil nil))
                                  nil)
                                 ("2"
                                  (induct i)
                                  (("1" (skeep) nil nil)
                                   ("2"
                                    (skeep)
                                    (("2"
                                      (skeep)
                                      (("2"
                                        (expand "^" 1)
                                        (("2"
                                          (case "k=0")
                                          (("1"
                                            (expand nth 1)
                                            (("1"
                                              (assert)
                                              (("1"
                                                (lemma
                                                 "car_append[nat]")
                                                (("1"
                                                  (inst?)
                                                  (("1"
                                                    (assert)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil)
                                           ("2"
                                            (expand nth 2)
                                            (("2"
                                              (assert)
                                              (("2"
                                                (lemma
                                                 "cdr_append[nat]")
                                                (("2"
                                                  (inst?)
                                                  (("2"
                                                    (replace -1)
                                                    (("2"
                                                      (assert)
                                                      (("2"
                                                        (lemma
                                                         "append_null_left[nat]")
                                                        (("2"
                                                          (inst?)
                                                          (("2"
                                                            (replace
                                                             -1)
                                                            (("2"
                                                              (inst
                                                               -3
                                                               "k-1")
                                                              nil
                                                              nil))
                                                            nil))
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil)
                                   ("3"
                                    (skeep)
                                    (("3"
                                      (typepred k)
                                      (("3"
                                        (case
                                         "FORALL(i:nat): length((:1:)^i) = i")
                                        (("1"
                                          (inst?)
                                          (("1" (assert) nil nil))
                                          nil)
                                         ("2"
                                          (induct i)
                                          (("1"
                                            (assert)
                                            (("1" (grind) nil nil))
                                            nil)
                                           ("2"
                                            (skeep)
                                            (("2"
                                              (expand "^" 1)
                                              (("2"
                                                (lemma
                                                 "cons_append[nat]")
                                                (("2"
                                                  (inst
                                                   -1
                                                   "(: 1 :) ^ j!1"
                                                   "1")
                                                  (("2"
                                                    (grind)
                                                    nil
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("3"
                                  (skeep)
                                  (("3"
                                    (case
                                     "FORALL(i:nat): length((:1:)^i) = i")
                                    (("1"
                                      (inst?)
                                      (("1" (grind) nil nil))
                                      nil)
                                     ("2"
                                      (induct i)
                                      (("1" (grind) nil nil)
                                       ("2"
                                        (skeep)
                                        (("2"
                                          (expand "^" 1)
                                          (("2"
                                            (lemma "cons_append[nat]")
                                            (("2"
                                              (inst
                                               -1
                                               "(: 1 :) ^ j!1"
                                               "1")
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (lemma "list_length_n")
                        (("2" (inst?)
                          (("2" (replace -1 1 rl)
                            (("2"
                              (case "FORALL(i:nat): length((:1:)^i) = i")
                              (("1"
                                (inst?)
                                (("1"
                                  (replace -1)
                                  (("1"
                                    (typepred i)
                                    (("1"
                                      (assert)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (induct i)
                                (("1" (grind) nil nil)
                                 ("2"
                                  (skeep)
                                  (("2"
                                    (expand "^" 1)
                                    (("2"
                                      (lemma "cons_append[nat]")
                                      (("2"
                                        (inst -1 "(: 1 :) ^ j!1" "1")
                                        (("2"
                                          (assert)
                                          (("2" (grind) nil nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (skeep)
      (("3" (lemma "list_length_n")
        (("3" (inst?) (("3" (typepred i) (("3" (assert) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((NOT const-decl "[bool -> bool]" booleans nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}"
     real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil (<= const-decl "bool" reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil) nil
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (int_plus_int_is_int application-judgement "int" integers nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (car_append formula-decl nil more_list_props structures)
    (append_null_left formula-decl nil more_list_props structures)
    (cdr_append formula-decl nil more_list_props structures)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (append def-decl "list[T]" list_props nil)
    (cons_append formula-decl nil more_list_props structures)
    (list_length_n formula-decl nil list_lemmas nil)
    (add_list_nth formula-decl nil list_lemmas nil)
    (nat_induction formula-decl nil naturalnumbers nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (pred type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (list_length_n def-decl "list[nat]" list_lemmas nil))
   shostak))
 (every_filter 0
  (every_filter-1 nil 3812719936 ("" (induct-and-simplify "l") nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (pred type-eq-decl nil defined_types nil) nil
    (T formal-type-decl nil list_lemmas nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (every_of_filter 0
  (every_of_filter-1 nil 3813054937
   ("" (induct-and-simplify "l") nil nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (pred type-eq-decl nil defined_types nil) nil
    (T formal-type-decl nil list_lemmas nil)
    (list_induction formula-decl nil list_adt nil))
   shostak))
 (filter_exists_cons 0
  (filter_exists_cons-1 nil 3813329521
   ("" (skolem 1 ("_" "P"))
    (("" (induct "l")
      (("1" (flatten)
        (("1" (skeep)
          (("1" (typepred "i") (("1" (assert) nil nil)) nil)) nil))
        nil)
       ("2" (skeep)
        (("2" (skeep :preds? T)
          (("2" (assert)
            (("2" (case "i=0")
              (("1" (expand "nth" -4)
                (("1" (assert)
                  (("1" (expand "filter" 1) (("1" (propax) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (expand "length" -1)
                (("2" (expand "filter" 2)
                  (("2" (assert)
                    (("2" (lift-if 2)
                      (("2" (split 2)
                        (("1" (flatten) (("1" (assert) nil nil)) nil)
                         ("2" (flatten)
                          (("2" (assert)
                            (("2" (expand "nth" -2)
                              (("2" (inst 4 "i-1") nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (length def-decl "nat" list_props nil)
    (below type-eq-decl nil naturalnumbers nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (pred type-eq-decl nil defined_types nil) nil
    (T formal-type-decl nil list_lemmas nil)
    (list_induction formula-decl nil list_adt nil)
    (length_null formula-decl nil more_list_props structures)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil))
   shostak))
 (cons_filter_exists 0
  (cons_filter_exists-1 nil 3813572960
   ("" (induct "l")
    (("1" (skeep)
      (("1" (expand "filter" -1) (("1" (propax) nil nil)) nil)) nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand "filter" -2)
          (("2" (lift-if -2)
            (("2" (split -2)
              (("1" (flatten)
                (("1" (inst 1 "0")
                  (("1" (expand "nth" 1) (("1" (propax) nil nil)) nil)
                   ("2" (expand "length" 1) (("2" (assert) nil nil))
                    nil))
                  nil))
                nil)
               ("2" (flatten)
                (("2" (inst -2 "P")
                  (("2" (assert)
                    (("2" (skeep :preds? T)
                      (("2" (inst 2 "i+1")
                        (("1" (expand "nth" 2) (("1" (propax) nil nil))
                          nil)
                         ("2" (expand "length" 1)
                          (("2" (assert) nil nil)) nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    nil nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    nil
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (list_induction formula-decl nil list_adt nil)
    (T formal-type-decl nil list_lemmas nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil) nil
    (pred type-eq-decl nil defined_types nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   nil))
 (length_rdc_TCC1 0
  (length_rdc_TCC1-1 nil 3813404417 ("" (subtype-tcc) nil nil) nil nil
   (length_rdc subtype "list_lemmas.l1"
    "{l: list_adt[list_lemmas.T].list | (booleans.NOT)(list_adt[list_lemmas.T].null?(l))}")))
 (length_rdc 0
  (length_rdc-1 nil 3813404499
   ("" (skeep)
    (("" (lemma "rdc_rac[T]")
      (("" (inst?)
        (("" (both-sides-f -1 "length")
          (("" (rewrite "length_append[T]") (("" (assert) nil nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil list_lemmas nil)
    (rdc_rac formula-decl nil more_list_props structures)
    (bijective? const-decl "bool" functions nil)
    (id const-decl "(bijective?[T, T])" identity nil)
    (TRUE const-decl "bool" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (append def-decl "list[T]" list_props nil)
    (rdc const-decl "list[T]" more_list_props structures)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (rac const-decl "T" more_list_props structures)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length_singleton formula-decl nil more_list_props structures)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (length_append formula-decl nil list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (nth_rdc_TCC1 0
  (nth_rdc_TCC1-1 nil 3813404417
   ("" (skeep)
    (("" (lemma "length_rdc")
      (("" (inst?) (("" (assert) nil nil)) nil)) nil))
    nil)
   ((length_rdc formula-decl nil list_lemmas nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil)
    (T formal-type-decl nil list_lemmas nil))
   nil
   (nth_rdc subtype "list_lemmas.i" "below[length[T](rdc[T](l1))]")))
 (nth_rdc_TCC2 0
  (nth_rdc_TCC2-1 nil 3813404417 ("" (subtype-tcc) nil nil)
   ((T formal-type-decl nil list_lemmas nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (>= const-decl "bool" reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil))
   nil (nth_rdc subtype "list_lemmas.i" "below[length[T](l1)]")))
 (nth_rdc 0
  (nth_rdc-1 nil 3813404688
   ("" (skeep)
    (("" (rewrite "rdc_rac" 1 :dir rl)
      (("" (lemma "nth_append[T]")
        (("" (inst?)
          (("" (assert)
            (("" (rewrite "length_append" -2)
              (("" (assert)
                (("" (replace -1) (("" (rewrite "rdc_rac" 1) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((rdc_rac formula-decl nil more_list_props structures)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (T formal-type-decl nil list_lemmas nil)
    (rdc const-decl "list[T]" more_list_props structures)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cons adt-constructor-decl "[[T, list] -> (cons?)]" list_adt nil)
    (rac const-decl "T" more_list_props structures)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (length_append formula-decl nil list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (length_singleton formula-decl nil more_list_props structures)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (nnint_plus_nnint_is_nnint application-judgement "nonneg_int"
     integers nil)
    (nth_append formula-decl nil more_list_props structures))
   shostak))
 (rdc_cdr_TCC1 0
  (rdc_cdr_TCC1-1 nil 3813570772 ("" (subtype-tcc) nil nil) nil nil
   (rdc_cdr subtype "list_adt[list_lemmas.T].cdr(list_lemmas.l)"
    "{l: list_adt[list_lemmas.T].list | (booleans.NOT)(list_adt[list_lemmas.T].null?(l))}")))
 (rdc_cdr_TCC2 0
  (rdc_cdr_TCC2-1 nil 3813570772 ("" (subtype-tcc) nil nil) nil nil
   (rdc_cdr subtype "list_lemmas.l"
    "{l: list_adt[list_lemmas.T].list | (booleans.NOT)(list_adt[list_lemmas.T].null?(l))}")))
 (rdc_cdr_TCC3 0
  (rdc_cdr_TCC3-1 nil 3813570772
   ("" (skeep)
    (("" (assert)
      (("" (lemma "length_rdc")
        (("" (inst?) (("" (assert) (("" (grind) nil nil)) nil)) nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil list_lemmas nil)
    (list type-decl nil list_adt nil)
    (boolean nonempty-type-decl nil booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reverse def-decl "list[T]" list_props nil)
    (rdc const-decl "list[T]" more_list_props structures)
    (length def-decl "nat" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (length_rdc formula-decl nil list_lemmas nil))
   nil
   (rdc_cdr subtype "more_list_props[list_lemmas.T].rdc(list_lemmas.l)"
    "(list_adt[list_lemmas.T].cons?)")))
 (rdc_cdr 0
  (rdc_cdr-1 nil 3813571236
   ("" (skeep)
    (("" (lemma "list_extensionality[T]")
      (("" (inst -1 " rdc(cdr(l))" "cdr(rdc(l))")
        (("" (assert)
          (("" (split 1)
            (("1" (lemma "length_rdc")
              (("1" (inst-cp -1 "l")
                (("1" (assert)
                  (("1" (inst -1 "cdr(l)")
                    (("1" (assert)
                      (("1" (replace -1)
                        (("1" (expand "length" -2 1)
                          (("1" (lift-if -2)
                            (("1" (split -2)
                              (("1"
                                (flatten)
                                (("1"
                                  (assert)
                                  (("1" (grind) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (assert)
                                  (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil)
             ("2" (hide 2)
              (("2" (skeep)
                (("2" (lemma "nth_rdc")
                  (("2" (inst -1 "cdr(l)" "n")
                    (("2" (assert)
                      (("2" (typepred "n")
                        (("2" (lemma "length_rdc")
                          (("2" (inst -1 "cdr(l)")
                            (("2" (assert)
                              (("2"
                                (replace -3)
                                (("2"
                                  (lemma "nth_rdc")
                                  (("2"
                                    (inst -1 "l" "n+1")
                                    (("2"
                                      (expand "nth" -1)
                                      (("2"
                                        (assert)
                                        (("2"
                                          (typepred "n")
                                          (("2"
                                            (expand "length" 1 1)
                                            (("2" (assert) nil nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((T formal-type-decl nil list_lemmas nil)
    (list_extensionality formula-decl nil more_list_props structures)
    (nth_rdc formula-decl nil list_lemmas nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nth def-decl "T" list_props nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (below type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (length_rdc formula-decl nil list_lemmas nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (length def-decl "nat" list_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (reverse def-decl "list[T]" list_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (rdc const-decl "list[T]" more_list_props structures)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (list type-decl nil list_adt nil))
   shostak))
 (min_list_TCC1 0
  (min_list_TCC1-1 nil 3882461239
   ("" (skeep*)
    (("" (grind) (("" (typepred "i") (("" (grind) nil nil)) nil)) nil))
    nil)
   ((length def-decl "nat" list_props nil)
    (nth def-decl "T" list_props nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (min_list subtype "list_adt[real].car(list_lemmas.l)"
    "{t: reals.real | FORALL (i: naturalnumbers.below(list_props[real].length(list_lemmas.l))): booleans.AND(reals.<=(t, list_props[real].nth(list_lemmas.l, i)), EXISTS (i: naturalnumbers.below(list_props[real].length(list_lemmas.l))): t = list_props[real].nth(list_lemmas.l, i))}")))
 (min_list_TCC2 0
  (min_list_TCC2-1 nil 3882461239
   ("" (skeep) (("" (grind) nil nil)) nil)
   ((nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (length def-decl "nat" list_props nil))
   nil
   (min_list subtype "list_adt[real].cdr(list_lemmas.l)"
    "{l: list_adt[real].list | list_adt[real].cons?(l)}")))
 (min_list_TCC3 0
  (min_list_TCC3-1 nil 3882461239 ("" (termination-tcc) nil nil)
   ((length def-decl "nat" list_props nil)) nil
   (min_list termination
    "list_lemmas.min_list(list_adt[real].cdr(list_lemmas.l))" "nil")))
 (min_list_TCC4 0
  (min_list_TCC4-1 nil 3882461239
   ("" (skeep)
    (("" (skeep)
      (("" (typepred "v(cdr(l))")
        (("" (split 2)
          (("1" (case "i=0")
            (("1" (grind) nil nil)
             ("2" (inst -1 "i-1")
              (("1" (expand "nth" 2) (("1" (assert) nil nil)) nil)
               ("2" (grind)
                (("2" (typepred "i")
                  (("2" (expand "length" -1) (("2" (assert) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (inst 1 "0") (("2" (grind) nil nil)) nil))
          nil))
        nil))
      nil))
    nil)
   ((real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (< const-decl "bool" reals nil) (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil) nil
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (length def-decl "nat" list_props nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (below type-eq-decl nil naturalnumbers nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil nat_types nil)
    (nth def-decl "T" list_props nil)
    (= const-decl "[T, T -> boolean]" equalities nil))
   nil
   (min_list subtype "list_adt[real].car(list_lemmas.l)"
    "{t: reals.real | FORALL (i: naturalnumbers.below(list_props[real].length(list_lemmas.l))): booleans.AND(reals.<=(t, list_props[real].nth(list_lemmas.l, i)), EXISTS (i: naturalnumbers.below(list_props[real].length(list_lemmas.l))): t = list_props[real].nth(list_lemmas.l, i))}")))
 (min_list_TCC5 0
  (min_list_TCC5-1 nil 3882461239
   ("" (skeep*)
    (("" (typepred "v(cdr(l))")
      (("" (typepred "v!1(cdr(l))")
        (("" (case "i=0")
          (("1" (replace -1)
            (("1" (expand "nth" 3 1)
              (("1" (assert)
                (("1" (inst-cp -2 "0")
                  (("1" (inst-cp -4 "0")
                    (("1" (flatten)
                      (("1" (skeep*)
                        (("1" (inst -2 "i!2")
                          (("1" (inst -5 "i!1")
                            (("1" (flatten)
                              (("1"
                                (assert)
                                (("1"
                                  (inst 3 "i!1+1")
                                  (("1"
                                    (expand "nth" 3)
                                    (("1" (propax) nil nil))
                                    nil)
                                   ("2"
                                    (assert)
                                    (("2"
                                      (hide-all-but (1))
                                      (("2"
                                        (typepred "i!1")
                                        (("2" (grind) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil)
                   ("2" (hide-all-but (1 2)) (("2" (grind) nil nil))
                    nil))
                  nil))
                nil))
              nil))
            nil)
           ("2" (inst-cp -1 "i-1")
            (("1" (inst-cp -3 "i-1")
              (("1" (flatten)
                (("1" (skeep*)
                  (("1" (assert)
                    (("1" (expand "nth" 4 1)
                      (("1" (assert)
                        (("1" (inst 4 "i!1+1")
                          (("1" (expand "nth" 4 1)
                            (("1" (propax) nil nil)) nil)
                           ("2" (hide-all-but 1)
                            (("2" (typepred "i!1")
                              (("2" (grind) nil nil)) nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil)
               ("2" (assert) nil nil))
              nil)
             ("2" (assert)
              (("2" (typepred "i")
                (("2" (hide-all-but (-1 1)) (("2" (grind) nil nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((= const-decl "[T, T -> boolean]" equalities nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (cdr adt-accessor-decl "[(cons?) -> list]" list_adt nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (length def-decl "nat" list_props nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil) nil
    (PRED type-eq-decl nil defined_types nil)
    (list type-decl nil list_adt nil) (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    nil
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (numfield nonempty-type-eq-decl nil number_fields nil)
    (+ const-decl "[numfield, numfield -> numfield]" number_fields nil)
    nil
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    nil nil
    (- const-decl "[numfield, numfield -> numfield]" number_fields nil)
    (int_minus_int_is_int application-judgement "int" integers nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (TRUE const-decl "bool" booleans nil))
   nil
   (min_list subtype
    "list_lemmas.min_list(list_adt[real].cdr(list_lemmas.l))"
    "{t: reals.real | FORALL (i: naturalnumbers.below(list_props[real].length(list_lemmas.l))): booleans.AND(reals.<=(t, list_props[real].nth(list_lemmas.l, i)), EXISTS (i: naturalnumbers.below(list_props[real].length(list_lemmas.l))): t = list_props[real].nth(list_lemmas.l, i))}")))
 (min_lemma_TCC1 0
  (min_lemma_TCC1-1 nil 3882461239
   ("" (skeep) (("" (typepred "l1" "l2") (("" (grind) nil nil)) nil))
    nil)
   ((cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (every adt-def-decl "boolean" list_adt nil)
    (list type-decl nil list_adt nil)
    (PRED type-eq-decl nil defined_types nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (append def-decl "list[T]" list_props nil))
   nil
   (min_lemma subtype
    "list_props[real].append(list_lemmas.l1, list_lemmas.l2)"
    "{l: list_adt[real].list | list_adt[real].cons?(l)}")))
 (min_lemma_TCC2 0
  (min_lemma_TCC2-1 nil 3882461239
   ("" (skeep) (("" (grind) nil nil)) nil) nil nil
   (min_lemma subtype "list_lemmas.l1"
    "{l: list_adt[real].list | list_adt[real].cons?(l)}")))
 (min_lemma 0
  (min_lemma-1 nil 3882530012
   ("" (induct "l1")
    (("1" (skeep) nil nil)
     ("2" (skeep)
      (("2" (skeep)
        (("2" (expand "append" 1 1)
          (("2" (expand "min_list" 1 2)
            (("2" (lift-if 1)
              (("2" (split 1)
                (("1" (flatten)
                  (("1" (case "cons2_var = null")
                    (("1" (replace -1)
                      (("1" (expand "append" 1 1)
                        (("1" (expand "min_list" 1 1)
                          (("1" (lift-if 1)
                            (("1" (split 1)
                              (("1"
                                (flatten)
                                (("1"
                                  (typepred "l2")
                                  (("1" (grind) nil nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (split 2)
                                  (("1"
                                    (flatten)
                                    (("1"
                                      (expand "min" 1 1)
                                      (("1" (assert) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2"
                                      (assert)
                                      (("2"
                                        (expand "min" 2)
                                        (("2" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil)
                     ("2" (inst -2 "l2")
                      (("1" (expand "min_list" 2 1)
                        (("1" (lift-if 2)
                          (("1" (split 2)
                            (("1" (flatten) (("1" (grind) nil nil))
                              nil)
                             ("2" (flatten)
                              (("2"
                                (split 2)
                                (("1"
                                  (flatten)
                                  (("1"
                                    (assert)
                                    (("1"
                                      (replace -3 -1)
                                      (("1"
                                        (expand "min" 1 1)
                                        (("1" (propax) nil nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil)
                                 ("2"
                                  (flatten)
                                  (("2"
                                    (assert)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil)
                       ("2" (assert) nil nil))
                      nil))
                    nil))
                  nil)
                 ("2" (flatten)
                  (("2" (split 2)
                    (("1" (flatten)
                      (("1" (inst -2 "l2")
                        (("1" (expand "min_list" 1 1)
                          (("1" (lift-if 1)
                            (("1" (split 1)
                              (("1"
                                (flatten)
                                (("1"
                                  (grind)
                                  (("1"
                                    (expand "append" -1)
                                    (("1"
                                      (expand "length" 1)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil)
                                   ("2"
                                    (expand "length")
                                    (("2"
                                      (expand "append")
                                      (("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (split 2)
                                  (("1"
                                    (flatten)
                                    (("1" (grind) nil nil))
                                    nil)
                                   ("2"
                                    (flatten)
                                    (("2" (grind) nil nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil)
                     ("2" (flatten)
                      (("2" (inst -1 "l2")
                        (("1" (expand "min_list" 2 1)
                          (("1" (lift-if 2)
                            (("1" (split 2)
                              (("1"
                                (flatten)
                                (("1"
                                  (expand "length" 3)
                                  (("1"
                                    (expand "length" -1)
                                    (("1"
                                      (expand "append" -1)
                                      (("1" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil)
                               ("2"
                                (flatten)
                                (("2"
                                  (split 2)
                                  (("1"
                                    (flatten)
                                    (("1" (grind) nil nil))
                                    nil)
                                   ("2" (flatten) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("3" (hide 2) (("3" (skeep) (("3" (grind) nil nil)) nil)) nil))
    nil)
   ((cons2_var skolem-const-decl "list[real]" list_lemmas nil)
    (posint_plus_nnint_is_posint application-judgement "posint"
     integers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nnint_plus_posint_is_posint application-judgement "posint"
     integers nil)
    (real_le_is_total_order name-judgement "(total_order?[real])"
     real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (null? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (null adt-constructor-decl "(null?)" list_adt nil)
    (list_induction formula-decl nil list_adt nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields
     nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (min_list def-decl "{t: real |
   FORALL (i: below(length(l))):
     t <= nth(l, i) AND EXISTS (i: below(length(l))): t = nth(l, i)}"
     list_lemmas nil)
    (nth def-decl "T" list_props nil)
    (below type-eq-decl nil nat_types nil)
    (<= const-decl "bool" reals nil)
    (below type-eq-decl nil naturalnumbers nil)
    (length def-decl "nat" list_props nil)
    (< const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (list type-decl nil list_adt nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (PRED type-eq-decl nil defined_types nil)
    (every adt-def-decl "boolean" list_adt nil)
    (AND const-decl "[bool, bool -> bool]" booleans nil)
    (cons? adt-recognizer-decl "[list -> boolean]" list_adt nil)
    (append def-decl "list[T]" list_props nil))
   shostak)))

