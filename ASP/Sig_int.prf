(Sig_int
 (v_form_TCC1 0
  (v_form_TCC1-1 nil 3624195772 ("" (termination-tcc) nil nil)
   ((T formal-nonempty-type-decl nil Sig_int nil)
    (s3? const-decl "bool" Sig_prop nil))
   nil (v_form subtype "0" "S3[T]")))
 (v_form_TCC2 0
  (v_form_TCC2-1 nil 3624195772 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[Sig_form])" Sig_form_adt nil)) nil
   (v_form termination "Sig_int.v_form(Sig_int.t1, Sig_int.i)" "nil")))
 (v_form_TCC3 0
  (v_form_TCC3-1 nil 3624195772
   ("" (skeep) (("" (expand "<<") (("" (grind) nil nil)) nil)) nil)
   ((<< adt-def-decl "(strict_well_founded?[Sig_form])" Sig_form_adt nil)) nil
   (v_form termination "Sig_int.v_form(Sig_int.t2, Sig_int.i)" "nil")))
 (v_form_TCC4 0
  (v_form_TCC4-1 nil 3624195772
   ("" (skeep)
    (("" (typepred "v(t1, i)")
      (("" (typepred "v(t2, i)")
        (("" (expand "s3?") (("" (assert) nil nil)) nil)) nil))
      nil))
    nil)
   ((<< adt-def-decl "(strict_well_founded?[Sig_form])" Sig_form_adt nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (I nonempty-type-eq-decl nil Sig_prop nil)
    (S3 type-eq-decl nil Sig_prop nil)
    (Sig_form type-decl nil Sig_form_adt nil)
    (s3? const-decl "bool" Sig_prop nil)
    (T formal-nonempty-type-decl nil Sig_int nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs
     nil))
   nil
   (v_form subtype
    "real_defs.min(Sig_int.v_form(Sig_int.t1, Sig_int.i), Sig_int.v_form(Sig_int.t2, Sig_int.i))"
    "S3[T]")))
 (v_form_TCC5 0
  (v_form_TCC5-1 nil 3624195772 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[Sig_form])" Sig_form_adt nil)) nil
   (v_form termination "Sig_int.v_form(Sig_int.t1, Sig_int.i)" "nil")))
 (v_form_TCC6 0
  (thm "fin" 3624196347 ("" (skosimp) (("" (grind) nil nil)) nil)
   ((<< adt-def-decl "(strict_well_founded?[Sig_form])" Sig_form_adt nil))
   shostak (v_form termination "Sig_int.v_form(Sig_int.t2, Sig_int.i)" "nil"))
  (v_form_TCC6-1 nil 3624195772 ("" (subtype-tcc) nil nil) nil nil
   (v_form termination "Sig_int.v_form(Sig_int.t2, Sig_int.i)" "nil")))
 (v_form_TCC7 0
  (v_form_TCC7-1 nil 3624195772
   ("" (skeep)
    (("" (typepred "v(t1, i)")
      (("" (typepred "v(t2, i)")
        (("" (expand "s3?") (("" (grind) nil nil)) nil)) nil))
      nil))
    nil)
   ((<< adt-def-decl "(strict_well_founded?[Sig_form])" Sig_form_adt nil)
    (strict_well_founded? const-decl "bool" orders nil)
    (pred type-eq-decl nil defined_types nil)
    (I nonempty-type-eq-decl nil Sig_prop nil)
    (S3 type-eq-decl nil Sig_prop nil)
    (Sig_form type-decl nil Sig_form_adt nil)
    (s3? const-decl "bool" Sig_prop nil)
    (T formal-nonempty-type-decl nil Sig_int nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (boolean nonempty-type-decl nil booleans nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs
     nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil))
   nil
   (v_form subtype
    "real_defs.max(Sig_int.v_form(Sig_int.t1, Sig_int.i), Sig_int.v_form(Sig_int.t2, Sig_int.i))"
    "S3[T]")))
 (v_form_TCC8 0
  (v_form_TCC8-1 nil 3624195772 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[Sig_form])" Sig_form_adt nil)) nil
   (v_form termination "Sig_int.v_form(Sig_int.t1, Sig_int.i)" "nil")))
 (v_form_TCC9 0
  (v_form_TCC9-1 nil 3636720901 ("" (termination-tcc) nil nil)
   ((<< adt-def-decl "(strict_well_founded?[Sig_form])" Sig_form_adt nil)) nil
   (v_form termination "Sig_int.v_form(Sig_int.t2, Sig_int.i)" "nil")))
 (v_form_TCC10 0
  (v_form_TCC10-1 nil 3636720901 ("" (subtype-tcc) nil nil)
   ((T formal-nonempty-type-decl nil Sig_int nil)
    (s3? const-decl "bool" Sig_prop nil))
   nil (v_form subtype "2" "S3[T]")))
 (caractv_form_and2 0
  (caractv_form_and2-1 nil 3636786024
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (split)
          (("1" (expand "v_form" -1)
            (("1" (assert)
              (("1" (typepred "v_form(t1, i)")
                (("1" (expand "s3?") (("1" (grind) nil nil)) nil)) nil))
              nil))
            nil)
           ("2" (expand " v_form" -1)
            (("2" (typepred " v_form(t2, i)")
              (("2" (expand "s3?") (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil)
       ("2" (flatten) (("2" (grind) nil nil)) nil))
      nil))
    nil)
   ((nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs
     nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-nonempty-type-decl nil Sig_int nil)
    (s3? const-decl "bool" Sig_prop nil)
    (Sig_form type-decl nil Sig_form_adt nil)
    (S3 type-eq-decl nil Sig_prop nil)
    (I nonempty-type-eq-decl nil Sig_prop nil)
    (v_form def-decl "S3" Sig_int nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil))
   shostak))
 (caractv_form_or2 0
  (caractv_form_or2-1 nil 3636787243
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "v_form" -1)
          (("1" (lemma "max_ge")
            (("1" (inst -1 "v_form(t1, i)" "v_form(t2, i)" "2")
              (("1" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (split)
          (("1" (expand "v_form" 1)
            (("1" (typepred "v_form(t2, i)")
              (("1" (expand "s3?") (("1" (grind) nil nil)) nil)) nil))
            nil)
           ("2" (expand "v_form" 1)
            (("2" (typepred "v_form(t1, i)") (("2" (grind) nil nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((v_form def-decl "S3" Sig_int nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (T formal-nonempty-type-decl nil Sig_int nil)
    (Sig_form type-decl nil Sig_form_adt nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (s3? const-decl "bool" Sig_prop nil) (S3 type-eq-decl nil Sig_prop nil)
    (I nonempty-type-eq-decl nil Sig_prop nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (max_ge formula-decl nil real_defs nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   shostak))
 (caractv_form_imp2 0
  (caractv_form_imp2-1 nil 3634548510
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (expand "v_form" -1)
          (("1" (typepred "v_form(t1, i)")
            (("1" (typepred " v_form(t2, i)") (("1" (grind) nil nil)) nil))
            nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (split)
          (("1" (grind) nil nil) ("2" (grind) nil nil) ("3" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((v_form def-decl "S3" Sig_int nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-nonempty-type-decl nil Sig_int nil)
    (s3? const-decl "bool" Sig_prop nil)
    (Sig_form type-decl nil Sig_form_adt nil)
    (S3 type-eq-decl nil Sig_prop nil)
    (I nonempty-type-eq-decl nil Sig_prop nil))
   shostak))
 (caractv_form_imp0 0
  (caractv_form_imp0-1 nil 3634548295 ("" (skeep) (("" (grind) nil nil)) nil)
   ((v_form def-decl "S3" Sig_int nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil))
   shostak))
 (caractv_form_imp1 0
  (caractv_form_imp1-1 nil 3634548492
   ("" (skeep)
    (("" (split)
      (("1" (flatten)
        (("1" (split)
          (("1" (typepred "v_form(t1, i)") (("1" (grind) nil nil)) nil)
           ("2" (typepred " v_form(t2, i)") (("2" (grind) nil nil)) nil))
          nil))
        nil)
       ("2" (flatten)
        (("2" (typepred " v_form(op_imp(t1, t2), i)") (("2" (grind) nil nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (boolean nonempty-type-decl nil booleans nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (number nonempty-type-decl nil numbers nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (real nonempty-type-from-decl nil reals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (int nonempty-type-eq-decl nil integers nil)
    (>= const-decl "bool" reals nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (T formal-nonempty-type-decl nil Sig_int nil)
    (s3? const-decl "bool" Sig_prop nil)
    (Sig_form type-decl nil Sig_form_adt nil)
    (S3 type-eq-decl nil Sig_prop nil)
    (I nonempty-type-eq-decl nil Sig_prop nil)
    (v_form def-decl "S3" Sig_int nil)
    (op_imp adt-constructor-decl "[[Sig_form, Sig_form] -> (op_imp?)]"
     Sig_form_adt nil)
    (op_imp? adt-recognizer-decl "[Sig_form -> boolean]" Sig_form_adt nil))
   shostak))
 (v_form_total 0
  (v_form_total-1 nil 3636100302
   ("" (induct "t")
    (("1" (skeep) (("1" (grind) nil nil)) nil)
     ("2" (skeep) (("2" (skeep) (("2" (grind) nil nil)) nil)) nil)
     ("3" (skeep) (("3" (skeep) (("3" (grind) nil nil)) nil)) nil)
     ("4" (skeep) (("4" (skeep) (("4" (grind) nil nil)) nil)) nil)
     ("5" (skeep) (("5" (skeep) (("5" (grind) nil nil)) nil)) nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs
     nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs
     nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (Sig_form_induction formula-decl nil Sig_form_adt nil)
    (T formal-nonempty-type-decl nil Sig_int nil)
    (RT const-decl "IC" Sig_prop nil) (IC type-eq-decl nil Sig_prop nil)
    (v_form def-decl "S3" Sig_int nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (I nonempty-type-eq-decl nil Sig_prop nil)
    (S3 type-eq-decl nil Sig_prop nil) (s3? const-decl "bool" Sig_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Sig_form type-decl nil Sig_form_adt nil))
   shostak))
 (caract_val_zero 0
  (caract_val_zero-1 nil 3634630075
   ("" (induct "t")
    (("1" (skeep) (("1" (grind) nil nil)) nil)
     ("2" (skeep) (("2" (skeep) (("2" (grind) nil nil)) nil)) nil)
     ("3" (skeep)
      (("3" (skeep)
        (("3" (split)
          (("1" (flatten) (("1" (grind) nil nil)) nil)
           ("2" (flatten)
            (("2" (inst -2 "i")
              (("2" (inst -3 "i") (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skeep) (("4" (skeep) (("4" (grind) nil nil)) nil)) nil)
     ("5" (skeep)
      (("5" (skeep)
        (("5" (split)
          (("1" (grind) nil nil)
           ("2" (flatten)
            (("2" (inst -2 "i")
              (("2" (inst -3 "i") (("2" (grind) nil nil)) nil)) nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs
     nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs
     nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (Sig_form_induction formula-decl nil Sig_form_adt nil)
    (T formal-nonempty-type-decl nil Sig_int nil)
    (RT const-decl "IC" Sig_prop nil) (IC type-eq-decl nil Sig_prop nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (v_form def-decl "S3" Sig_int nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (I nonempty-type-eq-decl nil Sig_prop nil)
    (S3 type-eq-decl nil Sig_prop nil) (s3? const-decl "bool" Sig_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Sig_form type-decl nil Sig_form_adt nil))
   shostak))
 (val_two 0
  (val_two-1 nil 3634631065
   ("" (induct "t")
    (("1" (skeep) (("1" (grind) nil nil)) nil)
     ("2" (skeep) (("2" (skeep) (("2" (grind) nil nil)) nil)) nil)
     ("3" (skeep)
      (("3" (skeep)
        (("3" (inst -1 i)
          (("3" (inst -2 i)
            (("3" (expand "v_form" -3)
              (("3" (lemma "min_ge")
                (("3"
                  (inst -1 "v_form(op_and1_var, i)" "v_form(op_and2_var, i)"
                   "2")
                  (("3" (flatten)
                    (("3" (split)
                      (("1" (flatten)
                        (("1" (typepred "v_form(op_and1_var, i)")
                          (("1" (typepred "v_form(op_and2_var, i)")
                            (("1" (grind) nil nil)) nil))
                          nil))
                        nil)
                       ("2" (grind) nil nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skeep)
      (("4" (skeep)
        (("4" (inst -1 i)
          (("4" (inst -2 i)
            (("4" (expand "v_form" -3)
              (("4" (expand "v_form" 1)
                (("4" (lemma "max_ge")
                  (("4"
                    (inst -1 "v_form(op_or1_var, i)" "v_form(op_or2_var, i)"
                     "2")
                    (("4" (flatten)
                      (("4" (hide -2)
                        (("4" (assert)
                          (("4" (split)
                            (("1" (typepred "v_form(op_or1_var, i)")
                              (("1" (expand " s3?")
                                (("1" (assert)
                                  (("1" (typepred "v_form(op_or2_var, RT(i))")
                                    (("1" (grind) nil nil)) nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (typepred "v_form(op_or2_var, i)")
                              (("2" (expand "s3?")
                                (("2" (assert)
                                  (("2" (typepred "v_form(op_or1_var, RT(i))")
                                    (("2" (grind) nil nil)) nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep)
      (("5" (skeep)
        (("5" (inst -1 "i")
          (("5" (inst -2 "i")
            (("5" (lemma "caractv_form_imp2")
              (("5" (inst -1 "op_imp1_var" "op_imp2_var" "i")
                (("5" (flatten)
                  (("5" (hide -2)
                    (("5" (assert)
                      (("5" (split)
                        (("1" (hide -4)
                          (("1" (lemma "caract_val_zero")
                            (("1" (inst -1 "op_imp1_var" "i")
                              (("1" (flatten)
                                (("1" (assert) (("1" (grind) nil nil)) nil))
                                nil))
                              nil))
                            nil))
                          nil)
                         ("2" (grind) nil nil)
                         ("3" (flatten)
                          (("3" (lemma "caractv_form_imp2")
                            (("3"
                              (inst -1 "op_imp1_var" "op_imp2_var" "RT(i)")
                              (("3" (flatten)
                                (("3" (hide -1)
                                  (("3" (hide -4 -2)
                                    (("3" (split)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (flatten)
                                        (("2"
                                          (hide 1 3 4)
                                          (("2"
                                            (lemma "caract_val_zero")
                                            (("2"
                                              (inst -1 "op_imp2_var" "i")
                                              (("2"
                                                (flatten)
                                                (("2"
                                                  (hide -1)
                                                  (("2"
                                                    (assert)
                                                    (("2"
                                                      (lemma "v_form_total")
                                                      (("2"
                                                        (inst
                                                         -1
                                                         "op_imp2_var"
                                                         "i")
                                                        (("2"
                                                          (grind)
                                                          nil
                                                          nil))
                                                        nil))
                                                      nil))
                                                    nil))
                                                  nil))
                                                nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((caractv_form_imp2 formula-decl nil Sig_int nil)
    (v_form_total formula-decl nil Sig_int nil)
    (caract_val_zero formula-decl nil Sig_int nil)
    (max_ge formula-decl nil real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (min_ge formula-decl nil real_defs nil)
    (Sig_form_induction formula-decl nil Sig_form_adt nil)
    (T formal-nonempty-type-decl nil Sig_int nil)
    (RT const-decl "IC" Sig_prop nil) (IC type-eq-decl nil Sig_prop nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (v_form def-decl "S3" Sig_int nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (I nonempty-type-eq-decl nil Sig_prop nil)
    (S3 type-eq-decl nil Sig_prop nil) (s3? const-decl "bool" Sig_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Sig_form type-decl nil Sig_form_adt nil))
   shostak))
 (val_one 0
  (val_one-1 nil 3634632481
   ("" (induct "t")
    (("1" (skeep) (("1" (grind) nil nil)) nil)
     ("2" (skeep) (("2" (skeep) (("2" (grind) nil nil)) nil)) nil)
     ("3" (skeep)
      (("3" (skeep)
        (("3" (inst -1 i)
          (("3" (inst -2 i)
            (("3" (expand "v_form" -3)
              (("3" (lemma "min_ge")
                (("3"
                  (inst -1 "v_form(op_and1_var, i)" "v_form(op_and2_var, i)"
                   "1")
                  (("3" (flatten)
                    (("3" (hide -2)
                      (("3" (split)
                        (("1" (flatten)
                          (("1" (split)
                            (("1" (grind) nil nil) ("2" (propax) nil nil))
                            nil))
                          nil)
                         ("2" (propax) nil nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skeep)
      (("4" (skeep)
        (("4" (inst -1 i)
          (("4" (inst -2 i)
            (("4" (expand "v_form" -3 1)
              (("4" (expand "v_form" 1)
                (("4" (lemma "max_ge")
                  (("4"
                    (inst -1 "v_form(op_or1_var, i)" "v_form(op_or2_var, i)"
                     "1")
                    (("4" (flatten)
                      (("4" (hide -2)
                        (("4" (assert)
                          (("4" (split)
                            (("1" (assert)
                              (("1" (typepred "v_form(op_or2_var, RT(i))")
                                (("1" (expand "s3?")
                                  (("1" (assert) (("1" (grind) nil nil)) nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (assert)
                              (("2" (typepred "v_form(op_or1_var, RT(i))")
                                (("2" (expand "s3?") (("2" (grind) nil nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep)
      (("5" (skeep)
        (("5" (expand ">=" -3)
          (("5" (expand "<=" -3)
            (("5" (split)
              (("1" (lemma "val_two")
                (("1" (inst -1 "op_imp(op_imp1_var, op_imp2_var)" "i")
                  (("1" (grind) nil nil)) nil))
                nil)
               ("2" (lemma "caractv_form_imp1")
                (("2" (inst -1 "op_imp1_var" "op_imp2_var" "i")
                  (("2" (flatten)
                    (("2" (hide -2)
                      (("2" (replace -2 -1)
                        (("2" (flatten) (("2" (grind) nil nil)) nil)) nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((op_imp adt-constructor-decl "[[Sig_form, Sig_form] -> (op_imp?)]"
     Sig_form_adt nil)
    (op_imp? adt-recognizer-decl "[Sig_form -> boolean]" Sig_form_adt nil)
    (val_two formula-decl nil Sig_int nil)
    (caractv_form_imp1 formula-decl nil Sig_int nil)
    (<= const-decl "bool" reals nil) (max_ge formula-decl nil real_defs nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs
     nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs
     nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (min_ge formula-decl nil real_defs nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (Sig_form_induction formula-decl nil Sig_form_adt nil)
    (T formal-nonempty-type-decl nil Sig_int nil)
    (RT const-decl "IC" Sig_prop nil) (IC type-eq-decl nil Sig_prop nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (v_form def-decl "S3" Sig_int nil)
    (IMPLIES const-decl "[bool, bool -> bool]" booleans nil)
    (I nonempty-type-eq-decl nil Sig_prop nil)
    (S3 type-eq-decl nil Sig_prop nil) (s3? const-decl "bool" Sig_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Sig_form type-decl nil Sig_form_adt nil))
   shostak))
 (caract_val_nozero 0
  (caract_val_nozero-1 nil 3635574917
   ("" (induct "t")
    (("1" (skeep) (("1" (grind) nil nil)) nil)
     ("2" (skeep) (("2" (skeep) (("2" (grind) nil nil)) nil)) nil)
     ("3" (skeep)
      (("3" (skeep)
        (("3" (inst -1 "i")
          (("3" (inst -2 "i")
            (("3" (lemma "caract_val_zero")
              (("3" (inst -1 "op_and(op_and1_var, op_and2_var)" "i")
                (("3" (flatten) (("3" (grind) nil nil)) nil)) nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("4" (skeep)
      (("4" (skeep)
        (("4" (inst -1 "i")
          (("4" (inst -2 "i")
            (("4" (lemma "caract_val_zero")
              (("4" (inst -1 "op_or(op_or1_var, op_or2_var)" "i")
                (("4" (flatten)
                  (("4" (hide -2)
                    (("4"
                      (typepred
                       "v_form(op_or(op_or1_var, op_or2_var), RT(i))")
                      (("4" (expand "s3?") (("4" (grind) nil nil)) nil)) nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil)
     ("5" (skeep)
      (("5" (skeep)
        (("5" (inst -1 "i")
          (("5" (inst -2 "i")
            (("5" (lemma "caract_val_zero")
              (("5" (inst -1 "op_imp(op_imp1_var, op_imp2_var)" "i")
                (("5" (flatten)
                  (("5" (hide -2)
                    (("5"
                      (typepred
                       "v_form(op_imp(op_imp1_var, op_imp2_var), RT(i))")
                      (("5" (expand " s3?")
                        (("5" (assert)
                          (("5" (split)
                            (("1" (split)
                              (("1" (grind) nil nil)
                               ("2" (hide 2)
                                (("2" (split)
                                  (("1" (propax) nil nil)
                                   ("2" (split)
                                    (("1" (grind) nil nil)
                                     ("2" (split)
                                      (("1" (propax) nil nil)
                                       ("2"
                                        (hide -2)
                                        (("2"
                                          (lemma "caract_val_zero")
                                          (("2"
                                            (inst
                                             -1
                                             "op_imp(op_imp1_var, op_imp2_var)"
                                             "i")
                                            (("2"
                                              (assert)
                                              (("2" (grind) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil)
                             ("2" (split)
                              (("1" (split)
                                (("1" (split)
                                  (("1" (split)
                                    (("1" (grind) nil nil)
                                     ("2" (propax) nil nil))
                                    nil)
                                   ("2" (split)
                                    (("1" (propax) nil nil)
                                     ("2" (grind) nil nil))
                                    nil))
                                  nil)
                                 ("2" (propax) nil nil))
                                nil)
                               ("2" (split)
                                (("1" (propax) nil nil)
                                 ("2" (split)
                                  (("1" (split)
                                    (("1" (grind) nil nil)
                                     ("2" (propax) nil nil))
                                    nil)
                                   ("2" (split)
                                    (("1" (propax) nil nil)
                                     ("2" (split)
                                      (("1"
                                        (flatten)
                                        (("1"
                                          (hide -2 2 3 4 5 6)
                                          (("1"
                                            (lemma " val_one")
                                            (("1"
                                              (inst
                                               -1
                                               "op_imp(op_imp1_var, op_imp2_var)"
                                               "i")
                                              (("1" (assert) nil nil))
                                              nil))
                                            nil))
                                          nil))
                                        nil)
                                       ("2" (grind) nil nil))
                                      nil))
                                    nil))
                                  nil))
                                nil))
                              nil))
                            nil))
                          nil))
                        nil))
                      nil))
                    nil))
                  nil))
                nil))
              nil))
            nil))
          nil))
        nil))
      nil))
    nil)
   ((val_one formula-decl nil Sig_int nil)
    (op_imp? adt-recognizer-decl "[Sig_form -> boolean]" Sig_form_adt nil)
    (op_imp adt-constructor-decl "[[Sig_form, Sig_form] -> (op_imp?)]"
     Sig_form_adt nil)
    (NOT const-decl "[bool -> bool]" booleans nil)
    (real_le_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (nat_max application-judgement "{k: nat | i <= k AND j <= k}" real_defs
     nil)
    (nonneg_rat_max application-judgement
     "{s: nonneg_rat | s >= q AND s >= r}" real_defs nil)
    (real_lt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (max const-decl "{p: real | p >= m AND p >= n}" real_defs nil)
    (op_or? adt-recognizer-decl "[Sig_form -> boolean]" Sig_form_adt nil)
    (op_or adt-constructor-decl "[[Sig_form, Sig_form] -> (op_or?)]"
     Sig_form_adt nil)
    (caract_val_zero formula-decl nil Sig_int nil)
    (min const-decl "{p: real | p <= m AND p <= n}" real_defs nil)
    (real_gt_is_strict_total_order name-judgement
     "(strict_total_order?[real])" real_props nil)
    (nat_min application-judgement "{k: nat | k <= i AND k <= j}" real_defs
     nil)
    (op_and? adt-recognizer-decl "[Sig_form -> boolean]" Sig_form_adt nil)
    (op_and adt-constructor-decl "[[Sig_form, Sig_form] -> (op_and?)]"
     Sig_form_adt nil)
    (real_ge_is_total_order name-judgement "(total_order?[real])" real_props
     nil)
    (Sig_form_induction formula-decl nil Sig_form_adt nil)
    (T formal-nonempty-type-decl nil Sig_int nil)
    (RT const-decl "IC" Sig_prop nil) (IC type-eq-decl nil Sig_prop nil)
    (OR const-decl "[bool, bool -> bool]" booleans nil)
    (= const-decl "[T, T -> boolean]" equalities nil)
    (v_form def-decl "S3" Sig_int nil)
    (IFF const-decl "[bool, bool -> bool]" booleans nil)
    (I nonempty-type-eq-decl nil Sig_prop nil)
    (S3 type-eq-decl nil Sig_prop nil) (s3? const-decl "bool" Sig_prop nil)
    (nat nonempty-type-eq-decl nil naturalnumbers nil)
    (>= const-decl "bool" reals nil)
    (bool nonempty-type-eq-decl nil booleans nil)
    (int nonempty-type-eq-decl nil integers nil)
    (integer_pred const-decl "[rational -> boolean]" integers nil)
    (rational nonempty-type-from-decl nil rationals nil)
    (rational_pred const-decl "[real -> boolean]" rationals nil)
    (real nonempty-type-from-decl nil reals nil)
    (real_pred const-decl "[number_field -> boolean]" reals nil)
    (number_field nonempty-type-from-decl nil number_fields nil)
    (number_field_pred const-decl "[number -> boolean]" number_fields nil)
    (number nonempty-type-decl nil numbers nil)
    (boolean nonempty-type-decl nil booleans nil)
    (Sig_form type-decl nil Sig_form_adt nil))
   shostak)))

